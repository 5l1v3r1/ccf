 
<head>
<meta name="HunterCmd" charset="utf-8">

<link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link id="cssfile" rel="stylesheet" type="text/css" href="https://rawcdn.githack.com/huntercmd/blog/master/config/css/light.css">
<script src="https://rawcdn.githack.com/huntercmd/blog/d9beff1/config/css/skin.js"></script>
<script src="https://rawcdn.githack.com/huntercmd/blog/master/config/css/classie.js"></script>


<title>HunterCmd</title>
</head>

<body class="cbp-spmenu-push">

<nav class="cbp-spmenu cbp-spmenu-vertical cbp-spmenu-left" id="menu-s1" style="width: 320px;overflow: auto;
">

<h1>Table of contents</h1>
<ul>
<li><a href="#24. USENIX Security Symposium 2015:Washington, D.C., USA">24. USENIX Security Symposium 2015:Washington, D.C., USA</a><ul>
<li><a href="#Paper Num: 67 || Session Num: 21">Paper Num: 67 || Session Num: 21</a></li>
<li><a href="#Measurement: We Didn't Start the Fire    3">Measurement: We Didn't Start the Fire    3</a><ul>
<li><a href="#1. Post-Mortem of a Zombie: Conficker Cleanup After Six Years.">1. Post-Mortem of a Zombie: Conficker Cleanup After Six Years.</a></li>
<li><a href="#2. Mo(bile">2. Mo(bile) Money, Mo(bile) Problems: Analysis of Branchless Banking Applications in the Developing World.</a> Money, Mo(bile) Problems: Analysis of Branchless Banking Applications in the Developing World.)</li>
<li><a href="#3. Measuring the Longitudinal Evolution of the Online Anonymous Marketplace Ecosystem.">3. Measuring the Longitudinal Evolution of the Online Anonymous Marketplace Ecosystem.</a></li>
</ul>
</li>
<li><a href="#Tic-Attack-Toe    3">Tic-Attack-Toe    3</a><ul>
<li><a href="#4. All Your Biases Belong to Us: Breaking RC4 in WPA-TKIP and TLS.">4. All Your Biases Belong to Us: Breaking RC4 in WPA-TKIP and TLS.</a></li>
<li><a href="#5. Attacks Only Get Better: Password Recovery Attacks Against RC4 in TLS.">5. Attacks Only Get Better: Password Recovery Attacks Against RC4 in TLS.</a></li>
<li><a href="#6. Eclipse Attacks on Bitcoin's Peer-to-Peer Network.">6. Eclipse Attacks on Bitcoin's Peer-to-Peer Network.</a></li>
</ul>
</li>
<li><a href="#Sock It To Me: TLS No Less    4">Sock It To Me: TLS No Less    4</a><ul>
<li><a href="#7. Protocol State Fuzzing of TLS Implementations.">7. Protocol State Fuzzing of TLS Implementations.</a></li>
<li><a href="#8. Verified Correctness and Security of OpenSSL HMAC.">8. Verified Correctness and Security of OpenSSL HMAC.</a></li>
<li><a href="#9. Not-Quite-So-Broken TLS: Lessons in Re-Engineering a Security Protocol Specification and Implementation.">9. Not-Quite-So-Broken TLS: Lessons in Re-Engineering a Security Protocol Specification and Implementation.</a></li>
<li><a href="#10. To Pin or Not to Pin-Helping App Developers Bullet Proof Their TLS Connections.">10. To Pin or Not to Pin-Helping App Developers Bullet Proof Their TLS Connections.</a></li>
</ul>
</li>
<li><a href="#Word Crimes    3">Word Crimes    3</a><ul>
<li><a href="#11. Compiler-instrumented, Dynamic Secret-Redaction of Legacy Processes for Attacker Deception.">11. Compiler-instrumented, Dynamic Secret-Redaction of Legacy Processes for Attacker Deception.</a></li>
<li><a href="#12. Control-Flow Bending: On the Effectiveness of Control-Flow Integrity.">12. Control-Flow Bending: On the Effectiveness of Control-Flow Integrity.</a></li>
<li><a href="#13. Automatic Generation of Data-Oriented Exploits.">13. Automatic Generation of Data-Oriented Exploits.</a></li>
</ul>
</li>
<li><a href="#Forget Me Not    4">Forget Me Not    4</a><ul>
<li><a href="#14. De-anonymizing Programmers via Code Stylometry.">14. De-anonymizing Programmers via Code Stylometry.</a></li>
<li><a href="#15. RAPTOR: Routing Attacks on Privacy in Tor.">15. RAPTOR: Routing Attacks on Privacy in Tor.</a></li>
<li><a href="#16. Circuit Fingerprinting Attacks: Passive Deanonymization of Tor Hidden Services.">16. Circuit Fingerprinting Attacks: Passive Deanonymization of Tor Hidden Services.</a></li>
<li><a href="#17. SecGraph: A Uniform and Open-source Evaluation System for Graph Data Anonymization and De-anonymization.">17. SecGraph: A Uniform and Open-source Evaluation System for Graph Data Anonymization and De-anonymization.</a></li>
</ul>
</li>
<li><a href="#Now You're Just Something That I Used to Code    3">Now You're Just Something That I Used to Code    3</a><ul>
<li><a href="#18. Under-Constrained Symbolic Execution: Correctness Checking for Real Code.">18. Under-Constrained Symbolic Execution: Correctness Checking for Real Code.</a></li>
<li><a href="#19. TaintPipe: Pipelined Symbolic Taint Analysis.">19. TaintPipe: Pipelined Symbolic Taint Analysis.</a></li>
<li><a href="#20. Type Casting Verification: Stopping an Emerging Attack Vector.">20. Type Casting Verification: Stopping an Emerging Attack Vector.</a></li>
</ul>
</li>
<li><a href="#Operating System Security: It's All About the Base    3">Operating System Security: It's All About the Base    3</a><ul>
<li><a href="#21. Trustworthy Whole-System Provenance for the Linux Kernel.">21. Trustworthy Whole-System Provenance for the Linux Kernel.</a></li>
<li><a href="#22. Securing Self-Virtualizing Ethernet Devices.">22. Securing Self-Virtualizing Ethernet Devices.</a></li>
<li><a href="#23. EASEAndroid: Automatic Policy Analysis and Refinement for Security Enhanced Android via Large-Scale Semi-Supervised Learning.">23. EASEAndroid: Automatic Policy Analysis and Refinement for Security Enhanced Android via Large-Scale Semi-Supervised Learning.</a></li>
</ul>
</li>
<li><a href="#Ace Ventura: PETS Detective    3">Ace Ventura: PETS Detective    3</a><ul>
<li><a href="#24. Marionette: A Programmable Network Traffic Obfuscation System.">24. Marionette: A Programmable Network Traffic Obfuscation System.</a></li>
<li><a href="#25. CONIKS: Bringing Key Transparency to End Users.">25. CONIKS: Bringing Key Transparency to End Users.</a></li>
<li><a href="#26. Investigating the Computer Security Practices and Needs of Journalists.">26. Investigating the Computer Security Practices and Needs of Journalists.</a></li>
</ul>
</li>
<li><a href="#ORAMorama!    3">ORAMorama!    3</a><ul>
<li><a href="#27. Constants Count: Practical Improvements to Oblivious RAM.">27. Constants Count: Practical Improvements to Oblivious RAM.</a></li>
<li><a href="#28. Raccoon: Closing Digital Side-Channels through Obfuscated Execution.">28. Raccoon: Closing Digital Side-Channels through Obfuscated Execution.</a></li>
<li><a href="#29. M2R: Enabling Stronger Privacy in MapReduce Computation.">29. M2R: Enabling Stronger Privacy in MapReduce Computation.</a></li>
</ul>
</li>
<li><a href="#But Maybe All You Need Is Something to Trust    3">But Maybe All You Need Is Something to Trust    3</a><ul>
<li><a href="#30. Measuring Real-World Accuracies and Biases in Modeling Password Guessability.">30. Measuring Real-World Accuracies and Biases in Modeling Password Guessability.</a></li>
<li><a href="#31. Sound-Proof: Usable Two-Factor Authentication Based on Ambient Sound.">31. Sound-Proof: Usable Two-Factor Authentication Based on Ambient Sound.</a></li>
<li><a href="#32. Android Permissions Remystified: A Field Study on Contextual Integrity.">32. Android Permissions Remystified: A Field Study on Contextual Integrity.</a></li>
</ul>
</li>
<li><a href="#PELCGB    3">PELCGB    3</a><ul>
<li><a href="#33. Phasing: Private Set Intersection Using Permutation-based Hashing.">33. Phasing: Private Set Intersection Using Permutation-based Hashing.</a></li>
<li><a href="#34. Faster Secure Computation through Automatic Parallelization.">34. Faster Secure Computation through Automatic Parallelization.</a></li>
<li><a href="#35. The Pythia PRF Service.">35. The Pythia PRF Service.</a></li>
</ul>
</li>
<li><a href="#And the Hackers Gonna Hack, Hack, Hack, Hack, Hack    3">And the Hackers Gonna Hack, Hack, Hack, Hack, Hack    3</a><ul>
<li><a href="#36. EVILCOHORT: Detecting Communities of Malicious Accounts on Online Services.">36. EVILCOHORT: Detecting Communities of Malicious Accounts on Online Services.</a></li>
<li><a href="#37. Trends and Lessons from Three Years Fighting Malicious Extensions.">37. Trends and Lessons from Three Years Fighting Malicious Extensions.</a></li>
<li><a href="#38. Meerkat: Detecting Website Defacements through Image-based Object Recognition.">38. Meerkat: Detecting Website Defacements through Image-based Object Recognition.</a></li>
</ul>
</li>
<li><a href="#It's a Binary Joke: Either You Get It, or You Don't    3">It's a Binary Joke: Either You Get It, or You Don't    3</a><ul>
<li><a href="#39. Recognizing Functions in Binaries with Neural Networks.">39. Recognizing Functions in Binaries with Neural Networks.</a></li>
<li><a href="#40. Reassembleable Disassembling.">40. Reassembleable Disassembling.</a></li>
<li><a href="#41. How the ELF Ruined Christmas.">41. How the ELF Ruined Christmas.</a></li>
</ul>
</li>
<li><a href="#Pain in the App    3">Pain in the App    3</a><ul>
<li><a href="#42. Finding Unknown Malice in 10 Seconds: Mass Vetting for New Threats at the Google-Play Scale.">42. Finding Unknown Malice in 10 Seconds: Mass Vetting for New Threats at the Google-Play Scale.</a></li>
<li><a href="#43. You Shouldn't Collect My Secrets: Thwarting Sensitive Keystroke Leakage in Mobile IME Apps.">43. You Shouldn't Collect My Secrets: Thwarting Sensitive Keystroke Leakage in Mobile IME Apps.</a></li>
<li><a href="#44. Boxify: Full-fledged App Sandboxing for Stock Android.">44. Boxify: Full-fledged App Sandboxing for Stock Android.</a></li>
</ul>
</li>
<li><a href="#Oh, What a Tangled Web We Weave    3">Oh, What a Tangled Web We Weave    3</a><ul>
<li><a href="#45. Cookies Lack Integrity: Real-World Implications.">45. Cookies Lack Integrity: Real-World Implications.</a></li>
<li><a href="#46. The Unexpected Dangers of Dynamic JavaScript.">46. The Unexpected Dangers of Dynamic JavaScript.</a></li>
<li><a href="#47. ZigZag: Automatically Hardening Web Applications Against Client-side Validation Vulnerabilities.">47. ZigZag: Automatically Hardening Web Applications Against Client-side Validation Vulnerabilities.</a></li>
</ul>
</li>
<li><a href="#The World's Address: An App That's Worn    3">The World's Address: An App That's Worn    3</a><ul>
<li><a href="#48. Anatomization and Protection of Mobile Apps' Location Privacy Threats.">48. Anatomization and Protection of Mobile Apps' Location Privacy Threats.</a></li>
<li><a href="#49. LinkDroid: Reducing Unregulated Aggregation of App Usage Behaviors.">49. LinkDroid: Reducing Unregulated Aggregation of App Usage Behaviors.</a></li>
<li><a href="#50. PowerSpy: Location Tracking Using Mobile Device Power Analysis.">50. PowerSpy: Location Tracking Using Mobile Device Power Analysis.</a></li>
</ul>
</li>
<li><a href="#ADDioS!    3">ADDioS!    3</a><ul>
<li><a href="#51. In the Compression Hornet's Nest: A Security Study of Data Compression in Network Services.">51. In the Compression Hornet's Nest: A Security Study of Data Compression in Network Services.</a></li>
<li><a href="#52. Bohatei: Flexible and Elastic DDoS Defense.">52. Bohatei: Flexible and Elastic DDoS Defense.</a></li>
<li><a href="#53. Boxed Out: Blocking Cellular Interconnect Bypass Fraud at the Network Edge.">53. Boxed Out: Blocking Cellular Interconnect Bypass Fraud at the Network Edge.</a></li>
</ul>
</li>
<li><a href="#Attacks: I Won't Let You Down    3">Attacks: I Won't Let You Down    3</a><ul>
<li><a href="#54. GSMem: Data Exfiltration from Air-Gapped Computers over GSM Frequencies.">54. GSMem: Data Exfiltration from Air-Gapped Computers over GSM Frequencies.</a></li>
<li><a href="#55. Thermal Covert Channels on Multi-core Platforms.">55. Thermal Covert Channels on Multi-core Platforms.</a></li>
<li><a href="#56. Rocking Drones with Intentional Sound Noise on Gyroscopic Sensors.">56. Rocking Drones with Intentional Sound Noise on Gyroscopic Sensors.</a></li>
</ul>
</li>
<li><a href="#How Do You Secure a Cloud and Pin It Down?    3">How Do You Secure a Cloud and Pin It Down?    3</a><ul>
<li><a href="#57. Cache Template Attacks: Automating Attacks on Inclusive Last-Level Caches.">57. Cache Template Attacks: Automating Attacks on Inclusive Last-Level Caches.</a></li>
<li><a href="#58. A Placement Vulnerability Study in Multi-Tenant Public Clouds.">58. A Placement Vulnerability Study in Multi-Tenant Public Clouds.</a></li>
<li><a href="#59. A Measurement Study on Co-residence Threat inside the Cloud.">59. A Measurement Study on Co-residence Threat inside the Cloud.</a></li>
</ul>
</li>
<li><a href="#Knock Knock. Who's There? Icy. Icy Who? I See You Too    4">Knock Knock. Who's There? Icy. Icy Who? I See You Too    4</a><ul>
<li><a href="#60. Towards Discovering and Understanding Task Hijacking in Android.">60. Towards Discovering and Understanding Task Hijacking in Android.</a></li>
<li><a href="#61. Cashtags: Protecting the Input and Display of Sensitive Data.">61. Cashtags: Protecting the Input and Display of Sensitive Data.</a></li>
<li><a href="#62. SUPOR: Precise and Scalable Sensitive User Input Detection for Android Apps.">62. SUPOR: Precise and Scalable Sensitive User Input Detection for Android Apps.</a></li>
<li><a href="#63. UIPicker: User-Input Privacy Identification in Mobile Applications.">63. UIPicker: User-Input Privacy Identification in Mobile Applications.</a></li>
</ul>
</li>
<li><a href="#How Do You Solve a Problem Like M-al-ware?    4">How Do You Solve a Problem Like M-al-ware?    4</a><ul>
<li><a href="#64. Cloudy with a Chance of Breach: Forecasting Cyber Security Incidents.">64. Cloudy with a Chance of Breach: Forecasting Cyber Security Incidents.</a></li>
<li><a href="#65. WebWitness: Investigating, Categorizing, and Mitigating Malware Download Paths.">65. WebWitness: Investigating, Categorizing, and Mitigating Malware Download Paths.</a></li>
<li><a href="#66. Vulnerability Disclosure in the Age of Social Media: Exploiting Twitter for Predicting Real-World Exploits.">66. Vulnerability Disclosure in the Age of Social Media: Exploiting Twitter for Predicting Real-World Exploits.</a></li>
<li><a href="#67. Needles in a Haystack: Mining Information from Public Dynamic Analysis Sandboxes for Malware Intelligence.">67. Needles in a Haystack: Mining Information from Public Dynamic Analysis Sandboxes for Malware Intelligence.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav><h1 id="24. USENIX Security Symposium 2015:Washington, D.C., USA">24. USENIX Security Symposium 2015:Washington, D.C., USA</h1>
<p><a href="https://www.usenix.org/conference/usenixsecurity15">24th USENIX Security Symposium, USENIX Security 15, Washington, D.C., USA, August 12-14, 2015.</a> USENIX Association
【<a href="http://dblp.uni-trier.de/db/conf/uss/uss2015.html">DBLP Link</a>】</p>
<h2 id="Paper Num: 67 || Session Num: 21">Paper Num: 67 || Session Num: 21</h2>
<ul>
<li><a href="#ADDioS!    3">ADDioS!    3</a></li>
<li><a href="#Ace Ventura: PETS Detective    3">Ace Ventura: PETS Detective    3</a></li>
<li><a href="#And the Hackers Gonna Hack, Hack, Hack, Hack, Hack    3">And the Hackers Gonna Hack, Hack, Hack, Hack, Hack    3</a></li>
<li><a href="#Attacks: I Won't Let You Down    3">Attacks: I Won't Let You Down    3</a></li>
<li><a href="#But Maybe All You Need Is Something to Trust    3">But Maybe All You Need Is Something to Trust    3</a></li>
<li><a href="#Forget Me Not    4">Forget Me Not    4</a></li>
<li><a href="#How Do You Secure a Cloud and Pin It Down?    3">How Do You Secure a Cloud and Pin It Down?    3</a></li>
<li><a href="#How Do You Solve a Problem Like M-al-ware?    4">How Do You Solve a Problem Like M-al-ware?    4</a></li>
<li><a href="#It's a Binary Joke: Either You Get It, or You Don't    3">It's a Binary Joke: Either You Get It, or You Don't    3</a></li>
<li><a href="#Knock Knock. Who's There? Icy. Icy Who? I See You Too    4">Knock Knock. Who's There? Icy. Icy Who? I See You Too    4</a></li>
<li><a href="#Measurement: We Didn't Start the Fire    3">Measurement: We Didn't Start the Fire    3</a></li>
<li><a href="#Now You're Just Something That I Used to Code    3">Now You're Just Something That I Used to Code    3</a></li>
<li><a href="#ORAMorama!    3">ORAMorama!    3</a></li>
<li><a href="#Oh, What a Tangled Web We Weave    3">Oh, What a Tangled Web We Weave    3</a></li>
<li><a href="#Operating System Security: It's All About the Base    3">Operating System Security: It's All About the Base    3</a></li>
<li><a href="#PELCGB    3">PELCGB    3</a></li>
<li><a href="#Pain in the App    3">Pain in the App    3</a></li>
<li><a href="#Sock It To Me: TLS No Less    4">Sock It To Me: TLS No Less    4</a></li>
<li><a href="#The World's Address: An App That's Worn    3">The World's Address: An App That's Worn    3</a></li>
<li><a href="#Tic-Attack-Toe    3">Tic-Attack-Toe    3</a></li>
<li><a href="#Word Crimes    3">Word Crimes    3</a></li>
</ul>
<h2 id="Measurement: We Didn't Start the Fire    3">Measurement: We Didn't Start the Fire    3</h2>
<h3 id="1. Post-Mortem of a Zombie: Conficker Cleanup After Six Years.">1. Post-Mortem of a Zombie: Conficker Cleanup After Six Years.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/asghari">Paper Link</a>】    【Pages】:1-16</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Asghari:Hadi">Hadi Asghari</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Ciere:Michael">Michael Ciere</a> ; <a href="http://dblp.uni-trier.de/pers/hd/e/Eeten:Michel_J=_G=_van">Michel J. G. van Eeten</a></p>
<p>【Abstract】:
Research on botnet mitigation has focused predominantly on methods to technically disrupt the commandand- control infrastructure. Much less is known about the effectiveness of large-scale efforts to clean up infected machines. We analyze longitudinal data from the sinkhole of Conficker, one the largest botnets ever seen, to assess the impact of what has been emerging as a best practice: national anti-botnet initiatives that support largescale cleanup of end user machines. It has been six years since the Conficker botnet was sinkholed. The attackers have abandoned it. Still, nearly a million machines remain infected. Conficker provides us with a unique opportunity to estimate cleanup rates, because there are relatively few interfering factors at work. This paper is the first to propose a systematic approach to transform noisy sinkhole data into comparative infection metrics and normalized estimates of cleanup rates. We compare the growth, peak, and decay of Conficker across countries. We find that institutional differences, such as ICT development or unlicensed software use, explain much of the variance, while the national anti-botnet centers have had no visible impact. Cleanup seems even slower than the replacement of machines running Windows XP. In general, the infected users appear outside the reach of current remediation practices. Some ISPs may have judged the neutralized botnet an insufficient threat to merit remediation. These machines can however be magnets for other threats — we find an overlap between GameoverZeus and Conficker infections. We conclude by reflecting on what this means for the future of botnet mitigation.</p>
<p>【Keywords】:</p>
<h3 id="2. Mo(bile) Money, Mo(bile) Problems: Analysis of Branchless Banking Applications in the Developing World.">2. Mo(bile) Money, Mo(bile) Problems: Analysis of Branchless Banking Applications in the Developing World.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/reaves">Paper Link</a>】    【Pages】:17-32</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/r/Reaves:Bradley">Bradley Reaves</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Scaife:Nolen">Nolen Scaife</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bates:Adam_M=">Adam M. Bates</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Traynor:Patrick">Patrick Traynor</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Butler:Kevin_R=_B=">Kevin R. B. Butler</a></p>
<p>【Abstract】:
Mobile money, also known as branchless banking, brings much-needed financial services to the unbanked in the developing world. Leveraging ubiquitous cellular networks, these services are now being deployed as smart phone apps, providing an electronic payment infrastructure where alternatives such as credit cards generally do not exist. Although widely marketed as a more secure option to cash, these applications are often not subject to the traditional regulations applied in the financial sector, leaving doubt as to the veracity of such claims. In this paper, we evaluate these claims and perform the first in-depth measurement analysis of branchless banking applications. We first perform an automated analysis of all 46 known Android mobile money apps across the 246 known mobile money providers and demonstrate that automated analysis fails to provide reliable insights. We subsequently perform comprehensive manual teardown of the registration, login, and transaction procedures of a diverse 15% of these apps. We uncover pervasive and systemic vulnerabilities spanning botched certification validation, do-it-yourself cryptography, and myriad other forms of information leakage that allow an attacker to impersonate legitimate users, modify transactions in flight, and steal financial records. These findings confirm that the majority of these apps fail to provide the protections needed by financial services. Finally, through inspection of providers’ terms of service, we also discover that liability for these problems unfairly rests on the shoulders of the customer, threatening to erode trust in branchless banking and hinder efforts for global financial inclusion.</p>
<p>【Keywords】:</p>
<h3 id="3. Measuring the Longitudinal Evolution of the Online Anonymous Marketplace Ecosystem.">3. Measuring the Longitudinal Evolution of the Online Anonymous Marketplace Ecosystem.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/soska">Paper Link</a>】    【Pages】:33-48</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Soska:Kyle">Kyle Soska</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Christin:Nicolas">Nicolas Christin</a></p>
<p>【Abstract】:
February 2011 saw the emergence of Silk Road, the first successful online anonymous marketplace, in which buyers and sellers could transact with anonymity properties far superior to those available in alternative online or offline means of commerce. Business on Silk Road, primarily involving narcotics trafficking, rapidly boomed, and competitors emerged. At the same time, law enforcement did not sit idle, and eventually managed to shut down Silk Road in October 2013 and arrest its operator. Far from causing the demise of this novel form of commerce, the Silk Road take-down spawned an entire, dynamic, online anonymous marketplace ecosystem, which has continued to evolve to this day. This paper presents a long-term measurement analysis of a large portion of this online anonymous marketplace ecosystem, including 16 different marketplaces, over more than two years (2013– 2015). By using long-term measurements, and combining our own data collection with publicly available previous efforts, we offer a detailed understanding of the growth of the online anonymous marketplace ecosystem. We are able to document the evolution of the types of goods being sold, and assess the effect (or lack thereof) of adversarial events, such as law enforcement operations or large-scale frauds, on the overall size of the economy. We also provide insights into how vendors are diversifying and replicating across marketplaces, and how vendor security practices (e.g., PGP adoption) are evolving. These different aspects help us understand how traditional, physical-world criminal activities are developing an online presence, in the same manner traditional commerce diversified online in the 1990s.</p>
<p>【Keywords】:</p>
<h2 id="Tic-Attack-Toe    3">Tic-Attack-Toe    3</h2>
<h3 id="4. All Your Biases Belong to Us: Breaking RC4 in WPA-TKIP and TLS.">4. All Your Biases Belong to Us: Breaking RC4 in WPA-TKIP and TLS.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/vanhoef">Paper Link</a>】    【Pages】:97-112</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/v/Vanhoef:Mathy">Mathy Vanhoef</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Piessens:Frank">Frank Piessens</a></p>
<p>【Abstract】:
We present new biases in RC4, break the Wi-Fi Protected Access Temporal Key Integrity Protocol (WPA-TKIP), and design a practical plaintext recovery attack against the Transport Layer Security (TLS) protocol. To empirically find new biases in the RC4 keystream we use statistical hypothesis tests. This reveals many new biases in the initial keystream bytes, as well as several new longterm biases. Our fixed-plaintext recovery algorithms are capable of using multiple types of biases, and return a list of plaintext candidates in decreasing likelihood. To break WPA-TKIP we introduce a method to generate a large number of identical packets. This packet is decrypted by generating its plaintext candidate list, and using redundant packet structure to prune bad candidates. From the decrypted packet we derive the TKIP MIC key, which can be used to inject and decrypt packets. In practice the attack can be executed within an hour. We also attack TLS as used by HTTPS, where we show how to decrypt a secure cookie with a success rate of 94% using 9•227 ciphertexts. This is done by injecting known data around the cookie, abusing this using Mantin’s ABSAB bias, and brute-forcing the cookie by traversing the plaintext candidates. Using our traffic generation technique, we are able to execute the attack in merely 75 hours.</p>
<p>【Keywords】:</p>
<h3 id="5. Attacks Only Get Better: Password Recovery Attacks Against RC4 in TLS.">5. Attacks Only Get Better: Password Recovery Attacks Against RC4 in TLS.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/garman">Paper Link</a>】    【Pages】:113-128</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/g/Garman:Christina">Christina Garman</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Paterson:Kenneth_G=">Kenneth G. Paterson</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Merwe:Thyla_van_der">Thyla van der Merwe</a></p>
<p>【Abstract】:
Despite recent high-profile attacks on the RC4 algorithm in TLS, its usage is still running at about 30% of all TLS traffic. We provide new attacks against RC4 in TLS that are focussed on recovering user passwords, still the pre-eminent means of user authentication on the Internet today. Our new attacks use a generally applicable Bayesian inference approach to transform a priori information about passwords in combination with gathered ciphertexts into a posteriori likelihoods for passwords. We report on extensive simulations of the attacks. We also report on a “proof of concept” implementation of the attacks for a specific application layer protocol, namely BasicAuth. Our work validates the truism that attacks only get better with time: we obtain good success rates in recovering user passwords with 226 encryptions, whereas the previous generation of attacks required around 234 encryptions to recover an HTTP session cookie.</p>
<p>【Keywords】:</p>
<h3 id="6. Eclipse Attacks on Bitcoin's Peer-to-Peer Network.">6. Eclipse Attacks on Bitcoin's Peer-to-Peer Network.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/heilman">Paper Link</a>】    【Pages】:129-144</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/h/Heilman:Ethan">Ethan Heilman</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kendler:Alison">Alison Kendler</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zohar:Aviv">Aviv Zohar</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Goldberg:Sharon">Sharon Goldberg</a></p>
<p>【Abstract】:
We present eclipse attacks on bitcoin’s peer-to-peer network. Our attack allows an adversary controlling a sufficient number of IP addresses to monopolize all connections to and from a victim bitcoin node. The attacker can then exploit the victim for attacks on bitcoin’s mining and consensus system, including N-confirmation double spending, selfish mining, and adversarial forks in the blockchain. We take a detailed look at bitcoin’s peer-to-peer network, and quantify the resources involved in our attack via probabilistic analysis, Monte Carlo simulations, measurements and experiments with live bitcoin nodes. Finally, we present countermeasures, inspired by botnet architectures, that are designed to raise the bar for eclipse attacks while preserving the openness and decentralization of bitcoin’s current network architecture.</p>
<p>【Keywords】:</p>
<h2 id="Sock It To Me: TLS No Less    4">Sock It To Me: TLS No Less    4</h2>
<h3 id="7. Protocol State Fuzzing of TLS Implementations.">7. Protocol State Fuzzing of TLS Implementations.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/de-ruiter">Paper Link</a>】    【Pages】:193-206</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/r/Ruiter:Joeri_de">Joeri de Ruiter</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Poll:Erik">Erik Poll</a></p>
<p>【Abstract】:
We describe a largely automated and systematic analysis of TLS implementations by what we call ‘protocol state fuzzing’: we use state machine learning to infer state machines from protocol implementations, using only blackbox testing, and then inspect the inferred state machines to look for spurious behaviour which might be an indication of flaws in the program logic. For detecting the presence of spurious behaviour the approach is almost fully automatic: we automatically obtain state machines and any spurious behaviour is then trivial to see. Detecting whether the spurious behaviour introduces exploitable security weaknesses does require manual investigation. Still, we take the point of view that any spurious functionality in a security protocol implementation is dangerous and should be removed. We analysed both server- and client-side implementations with a test harness that supports several key exchange algorithms and the option of client certificate authentication. We show that this approach can catch an interesting class of implementation flaws that is apparently common in security protocol implementations: in three of the TLS implementations analysed new security flaws were found (in GnuTLS, the Java Secure Socket Extension, and OpenSSL). This shows that protocol state fuzzing is a useful technique to systematically analyse security protocol implementations. As our analysis of different TLS implementations resulted in different and unique state machines for each one, the technique can also be used for fingerprinting TLS implementations.</p>
<p>【Keywords】:</p>
<h3 id="8. Verified Correctness and Security of OpenSSL HMAC.">8. Verified Correctness and Security of OpenSSL HMAC.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/beringer">Paper Link</a>】    【Pages】:207-221</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Beringer:Lennart">Lennart Beringer</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Petcher:Adam">Adam Petcher</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Ye:Katherine_Q=">Katherine Q. Ye</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Appel:Andrew_W=">Andrew W. Appel</a></p>
<p>【Abstract】:
We have proved, with machine-checked proofs in Coq, that an OpenSSL implementation of HMAC with SHA- 256 correctly implements its FIPS functional specification and that its functional specification guarantees the expected cryptographic properties. This is the first machine-checked cryptographic proof that combines a source-program implementation proof, a compilercorrectness proof, and a cryptographic-security proof, with no gaps at the specification interfaces. The verification was done using three systems within the Coq proof assistant: the Foundational Cryptography Framework, to verify crypto properties of functional specs; the Verified Software Toolchain, to verify C programs w.r.t. functional specs; and CompCert, for verified compilation of C to assembly language.</p>
<p>【Keywords】:</p>
<h3 id="9. Not-Quite-So-Broken TLS: Lessons in Re-Engineering a Security Protocol Specification and Implementation.">9. Not-Quite-So-Broken TLS: Lessons in Re-Engineering a Security Protocol Specification and Implementation.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/kaloper-mersinjak">Paper Link</a>】    【Pages】:223-238</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/k/Kaloper=Mersinjak:David">David Kaloper-Mersinjak</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Mehnert:Hannes">Hannes Mehnert</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Madhavapeddy:Anil">Anil Madhavapeddy</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Sewell:Peter">Peter Sewell</a></p>
<p>【Abstract】:
Transport Layer Security (TLS) implementations have a history of security flaws. The immediate causes of these are often programming errors, e.g. in memory management, but the root causes are more fundamental: the challenges of interpreting the ambiguous prose specification, the complexities inherent in large APIs and code bases, inherently unsafe programming choices, and the impossibility of directly testing conformance between implementations and the specification. We present nqsb-TLS, the result of our re-engineered approach to security protocol specification and implementation that addresses these root causes. The same code serves two roles: it is both a specification of TLS, executable as a test oracle to check conformance of traces from arbitrary implementations, and a usable implementation of TLS; a modular and declarative programming style provides clean separation between its components. Many security flaws are thus excluded by construction. nqsb-TLS can be used in standalone Unix applications, which we demonstrate with a messaging client, and can also be compiled into Xen unikernels (specialised virtual machine image) with a trusted computing base (TCB) that is 4% of a standalone system running a standard Linux/OpenSSL stack, with all network traffic being handled in a memory-safe language; this supports applications including HTTPS, IMAP, Git, and Websocket clients and servers. Despite the dual-role design, the high-level implementation style, and the functional programming language we still achieve reasonable performance, with the same handshake performance as OpenSSL and 73% – 84% for bulk throughput.</p>
<p>【Keywords】:</p>
<h3 id="10. To Pin or Not to Pin-Helping App Developers Bullet Proof Their TLS Connections.">10. To Pin or Not to Pin-Helping App Developers Bullet Proof Their TLS Connections.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/oltrogge">Paper Link</a>】    【Pages】:239-254</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/o/Oltrogge:Marten">Marten Oltrogge</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Acar:Yasemin">Yasemin Acar</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Dechand:Sergej">Sergej Dechand</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Smith_0001:Matthew">Matthew Smith</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Fahl:Sascha">Sascha Fahl</a></p>
<p>【Abstract】:
For increased security during TLS certificate validation, a common recommendation is to use a variation of pinning. Especially non-browser software developers are encouraged to limit the number of trusted certificates to a minimum, since the default CA-based approach is known to be vulnerable to serious security threats. The decision for or against pinning is always a tradeoff between increasing security and keeping maintenance efforts at an acceptable level. In this paper, we present an extensive study on the applicability of pinning for non-browser software by analyzing 639,283 Android apps. Conservatively, we propose pinning as an appropriate strategy for 11,547 (1.8%) apps or for 45,247 TLS connections (4.25%) in our sample set. With a more optimistic classification of borderline cases, we propose pinning for consideration for 58,817 (9.1%) apps or for 140,020 (3.8%1) TLS connections. This weakens the assumption that pinning is a widely usable strategy for TLS security in non-browser software. However, in a nominalactual comparison, we find that only 45 apps actually implement pinning. We collected developer feedback from 45 respondents and learned that only a quarter of them grasp the concept of pinning, but still find pinning too complex to use. Based on their feedback, we built an easy-to-use web-application that supports developers in the decision process and guides them through the correct deployment of a pinning-protected TLS implementation.</p>
<p>【Keywords】:</p>
<h2 id="Word Crimes    3">Word Crimes    3</h2>
<h3 id="11. Compiler-instrumented, Dynamic Secret-Redaction of Legacy Processes for Attacker Deception.">11. Compiler-instrumented, Dynamic Secret-Redaction of Legacy Processes for Attacker Deception.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/araujo">Paper Link</a>】    【Pages】:145-159</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Araujo:Frederico">Frederico Araujo</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Hamlen:Kevin_W=">Kevin W. Hamlen</a></p>
<p>【Abstract】:
An enhanced dynamic taint-tracking semantics is presented and implemented, facilitating fast and precise runtime secret redaction from legacy processes, such as those compiled from C/C++. The enhanced semantics reduce the annotation burden imposed upon developers seeking to add secret-redaction capabilities to legacy code, while curtailing over-tainting and label creep. An implementation for LLVM’s DataFlow Sanitizer automatically instruments taint-tracking and secretredaction support into annotated C/C++ programs at compile-time, yielding programs that can self-censor their address spaces in response to emerging cyber-attacks. The technology is applied to produce the first information flow-based honey-patching architecture for the Apache web server. Rather than merely blocking intrusions, the modified server deceptively diverts attacker connections to secret-sanitized process clones that monitor attacker activities and disinform adversaries with honey-data.</p>
<p>【Keywords】:</p>
<h3 id="12. Control-Flow Bending: On the Effectiveness of Control-Flow Integrity.">12. Control-Flow Bending: On the Effectiveness of Control-Flow Integrity.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/carlini">Paper Link</a>】    【Pages】:161-176</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/c/Carlini:Nicholas">Nicholas Carlini</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Barresi:Antonio">Antonio Barresi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Payer:Mathias">Mathias Payer</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wagner:David">David Wagner</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Gross:Thomas_R=">Thomas R. Gross</a></p>
<p>【Abstract】:
Control-Flow Integrity (CFI) is a defense which prevents control-flow hijacking attacks. While recent research has shown that coarse-grained CFI does not stop attacks, fine-grained CFI is believed to be secure. We argue that assessing the effectiveness of practical CFI implementations is non-trivial and that common evaluation metrics fail to do so. We then evaluate fullyprecise static CFI — the most restrictive CFI policy that does not break functionality — and reveal limitations in its security. Using a generalization of non-control-data attacks which we call Control-Flow Bending (CFB), we show how an attacker can leverage a memory corruption vulnerability to achieve Turing-complete computation on memory using just calls to the standard library. We use this attack technique to evaluate fully-precise static CFI on six real binaries and show that in five out of six cases, powerful attacks are still possible. Our results suggest that CFI may not be a reliable defense against memory corruption vulnerabilities. We further evaluate shadow stacks in combination with CFI and find that their presence for security is necessary: deploying shadow stacks removes arbitrary code execution capabilities of attackers in three of six cases.</p>
<p>【Keywords】:</p>
<h3 id="13. Automatic Generation of Data-Oriented Exploits.">13. Automatic Generation of Data-Oriented Exploits.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/hu">Paper Link</a>】    【Pages】:177-192</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/h/Hu:Hong">Hong Hu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Chua:Zheng_Leong">Zheng Leong Chua</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Adrian:Sendroiu">Sendroiu Adrian</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Saxena:Prateek">Prateek Saxena</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Liang:Zhenkai">Zhenkai Liang</a></p>
<p>【Abstract】:
As defense solutions against control-flow hijacking attacks gain wide deployment, control-oriented exploits from memory errors become difficult. As an alternative, attacks targeting non-control data do not require diverting the application’s control flow during an attack. Although it is known that such data-oriented attacks can mount significant damage, no systematic methods to automatically construct them from memory errors have been developed. In this work, we develop a new technique called data-flow stitching, which systematically finds ways to join data flows in the program to generate data-oriented exploits. We build a prototype embodying our technique in a tool called FLOWSTITCH that works directly on Windows and Linux binaries. In our experiments, we find that FLOWSTITCH automatically constructs 16 previously unknown and three known data-oriented attacks from eight real-world vulnerable programs. All the automatically-crafted exploits respect fine-grained CFI and DEP constraints, and 10 out of the 19 exploits work with standard ASLR defenses enabled. The constructed exploits can cause significant damage, such as disclosure of sensitive information (e.g., passwords and encryption keys) and escalation of privilege.</p>
<p>【Keywords】:</p>
<h2 id="Forget Me Not    4">Forget Me Not    4</h2>
<h3 id="14. De-anonymizing Programmers via Code Stylometry.">14. De-anonymizing Programmers via Code Stylometry.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/caliskan-islam">Paper Link</a>】    【Pages】:255-270</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/i/Islam:Aylin_Caliskan">Aylin Caliskan Islam</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Harang:Richard_E=">Richard E. Harang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Liu:Andrew">Andrew Liu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/Narayanan:Arvind">Arvind Narayanan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/v/Voss:Clare_R=">Clare R. Voss</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yamaguchi:Fabian">Fabian Yamaguchi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Greenstadt:Rachel">Rachel Greenstadt</a></p>
<p>【Abstract】:
Source code authorship attribution is a significant privacy threat to anonymous code contributors. However, it may also enable attribution of successful attacks from code left behind on an infected system, or aid in resolving copyright, copyleft, and plagiarism issues in the programming fields. In this work, we investigate machine learning methods to de-anonymize source code authors of C/C++ using coding style. Our Code Stylometry Feature Set is a novel representation of coding style found in source code that reflects coding style from properties derived from abstract syntax trees. Our random forest and abstract syntax tree-based approach attributes more authors (1,600 and 250) with significantly higher accuracy (94% and 98%) on a larger data set (Google Code Jam) than has been previously achieved. Furthermore, these novel features are robust, difficult to obfuscate, and can be used in other programming languages, such as Python. We also find that (i) the code resulting from difficult programming tasks is easier to attribute than easier tasks and (ii) skilled programmers (who can complete the more difficult tasks) are easier to attribute than less skilled programmers.</p>
<p>【Keywords】:</p>
<h3 id="15. RAPTOR: Routing Attacks on Privacy in Tor.">15. RAPTOR: Routing Attacks on Privacy in Tor.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/sun">Paper Link</a>】    【Pages】:271-286</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Sun:Yixin">Yixin Sun</a> ; <a href="http://dblp.uni-trier.de/pers/hd/e/Edmundson:Anne">Anne Edmundson</a> ; <a href="http://dblp.uni-trier.de/pers/hd/v/Vanbever:Laurent">Laurent Vanbever</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Li:Oscar">Oscar Li</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Rexford:Jennifer">Jennifer Rexford</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Chiang:Mung">Mung Chiang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Mittal:Prateek">Prateek Mittal</a></p>
<p>【Abstract】:
The Tor network is a widely used system for anonymous communication. However, Tor is known to be vulnerable to attackers who can observe traffic at both ends of the communication path. In this paper, we show that prior attacks are just the tip of the iceberg. We present a suite of new attacks, called Raptor, that can be launched by Autonomous Systems (ASes) to compromise user anonymity. First, AS-level adversaries can exploit the asymmetric nature of Internet routing to increase the chance of observing at least one direction of user traffic at both ends of the communication. Second, AS-level adversaries can exploit natural churn in Internet routing to lie on the BGP paths for more users over time. Third, strategic adversaries can manipulate Internet routing via BGP hijacks (to discover the users using specific Tor guard nodes) and interceptions (to perform traffic analysis). We demonstrate the feasibility of Raptor attacks by analyzing historical BGP data and Traceroute data as well as performing real-world attacks on the live Tor network, while ensuring that we do not harm real users. In addition, we outline the design of two monitoring frameworks to counter these attacks: BGP monitoring to detect control-plane attacks, and Traceroute monitoring to detect data-plane anomalies. Overall, our work motivates the design of anonymity systems that are aware of the dynamics of Internet routing.</p>
<p>【Keywords】:</p>
<h3 id="16. Circuit Fingerprinting Attacks: Passive Deanonymization of Tor Hidden Services.">16. Circuit Fingerprinting Attacks: Passive Deanonymization of Tor Hidden Services.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/kwon">Paper Link</a>】    【Pages】:287-302</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/k/Kwon:Albert">Albert Kwon</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/AlSabah:Mashael">Mashael AlSabah</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lazar:David">David Lazar</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Dacier:Marc">Marc Dacier</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Devadas:Srinivas">Srinivas Devadas</a></p>
<p>【Abstract】:
This paper sheds light on crucial weaknesses in the design of hidden services that allow us to break the anonymity of hidden service clients and operators passively. In particular, we show that the circuits, paths established through the Tor network, used to communicate with hidden services exhibit a very different behavior compared to a general circuit. We propose two attacks, under two slightly different threat models, that could identify a hidden service client or operator using these weaknesses. We found that we can identify the users’ involvement with hidden services with more than 98% true positive rate and less than 0.1% false positive rate with the first attack, and 99% true positive rate and 0.07% false positive rate with the second. We then revisit the threat model of previous website fingerprinting attacks, and show that previous results are directly applicable, with greater efficiency, in the realm of hidden services. Indeed, we show that we can correctly determine which of the 50 monitored pages the client is visiting with 88% true positive rate and false positive rate as low as 2.9%, and correctly deanonymize 50 monitored hidden service servers with true positive rate of 88% and false positive rate of 7.8% in an open world setting.</p>
<p>【Keywords】:</p>
<h3 id="17. SecGraph: A Uniform and Open-source Evaluation System for Graph Data Anonymization and De-anonymization.">17. SecGraph: A Uniform and Open-source Evaluation System for Graph Data Anonymization and De-anonymization.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/ji">Paper Link</a>】    【Pages】:303-318</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/j/Ji:Shouling">Shouling Ji</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Li:Weiqing">Weiqing Li</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Mittal:Prateek">Prateek Mittal</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Hu:Xin">Xin Hu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Beyah:Raheem_A=">Raheem A. Beyah</a></p>
<p>【Abstract】:
In this paper, we analyze and systematize the state-ofthe- art graph data privacy and utility techniques. Specifically, we propose and develop SecGraph (available at [1]), a uniform and open-source Secure Graph data sharing/publishing system. In SecGraph, we systematically study, implement, and evaluate 11 graph data anonymization algorithms, 19 data utility metrics, and 15 modern Structure-based De-Anonymization (SDA) attacks. To the best of our knowledge, SecGraph is the first such system that enables data owners to anonymize data by state-of-the-art anonymization techniques, measure the data’s utility, and evaluate the data’s vulnerability against modern De-Anonymization (DA) attacks. In addition, SecGraph enables researchers to conduct fair analysis and evaluation of existing and newly developed anonymization/DA techniques. Leveraging SecGraph, we conduct extensive experiments to systematically evaluate the existing graph data anonymization and DA techniques. The results demonstrate that (i) most anonymization schemes can partially or conditionally preserve most graph utilities while losing some application utility; (ii) no DA attack is optimum in all scenarios. The DA performance depends on several factors, e.g., similarity between anonymized and auxiliary data, graph density, and DA heuristics; and (iii) all the state-of-the-art anonymization schemes are vulnerable to several or all of the modern SDA attacks. The degree of vulnerability of each anonymization scheme depends on how much and which data utility it preserves.</p>
<p>【Keywords】:</p>
<h2 id="Now You're Just Something That I Used to Code    3">Now You're Just Something That I Used to Code    3</h2>
<h3 id="18. Under-Constrained Symbolic Execution: Correctness Checking for Real Code.">18. Under-Constrained Symbolic Execution: Correctness Checking for Real Code.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/ramos">Paper Link</a>】    【Pages】:49-64</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/r/Ramos:David_A=">David A. Ramos</a> ; <a href="http://dblp.uni-trier.de/pers/hd/e/Engler:Dawson_R=">Dawson R. Engler</a></p>
<p>【Abstract】:
Software bugs are a well-known source of security vulnerabilities. One technique for finding bugs, symbolic execution, considers all possible inputs to a program but suffers from scalability limitations. This paper uses a variant, under-constrained symbolic execution, that improves scalability by directly checking individual functions, rather than whole programs. We present UC-KLEE, a novel, scalable framework for checking C/C++ systems code, along with two use cases. First, we use UC-KLEE to check whether patches introduce crashes. We check over 800 patches from BIND and OpenSSL and find 12 bugs, including two OpenSSL denial-of-service vulnerabilities. We also verify (with caveats) that 115 patches do not introduce crashes. Second, we use UC-KLEE as a generalized checking framework and implement checkers to find memory leaks, uninitialized data, and unsafe user input. We evaluate the checkers on over 20,000 functions from BIND, OpenSSL, and the Linux kernel, find 67 bugs, and verify that hundreds of functions are leak free and that thousands of functions do not access uninitialized data.</p>
<p>【Keywords】:</p>
<h3 id="19. TaintPipe: Pipelined Symbolic Taint Analysis.">19. TaintPipe: Pipelined Symbolic Taint Analysis.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/ming">Paper Link</a>】    【Pages】:65-80</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Ming:Jiang">Jiang Ming</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wu:Dinghao">Dinghao Wu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/x/Xiao:Gaoyao">Gaoyao Xiao</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Jun">Jun Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Liu_0005:Peng">Peng Liu</a></p>
<p>【Abstract】:
Taint analysis has a wide variety of compelling applications in security tasks, from software attack detection to data lifetime analysis. Static taint analysis propagates taint values following all possible paths with no need for concrete execution, but is generally less accurate than dynamic analysis. Unfortunately, the high performance penalty incurred by dynamic taint analyses makes its deployment impractical in production systems. To ameliorate this performance bottleneck, recent research efforts aim to decouple data flow tracking logic from program execution. We continue this line of research in this paper and propose pipelined symbolic taint analysis, a novel technique for parallelizing and pipelining taint analysis to take advantage of ubiquitous multi-core platforms. We have developed a prototype system called TaintPipe. TaintPipe performs very lightweight runtime logging to produce compact control flow profiles, and spawns multiple threads as different stages of a pipeline to carry out symbolic taint analysis in parallel. Our experiments show that TaintPipe imposes low overhead on application runtime performance and accelerates taint analysis significantly. Compared to a state-of-the-art inlined dynamic data flow tracking tool, TaintPipe achieves 2:38 times speedup for taint analysis on SPEC 2006 and 2:43 times for a set of common utilities, respectively. In addition, we demonstrate the strength of TaintPipe such as natural support of multi-tag taint analysis with several security applications.</p>
<p>【Keywords】:</p>
<h3 id="20. Type Casting Verification: Stopping an Emerging Attack Vector.">20. Type Casting Verification: Stopping an Emerging Attack Vector.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/lee">Paper Link</a>】    【Pages】:81-96</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Lee:Byoungyoung">Byoungyoung Lee</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Song:Chengyu">Chengyu Song</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kim:Taesoo">Taesoo Kim</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lee:Wenke">Wenke Lee</a></p>
<p>【Abstract】:
Many applications such as the Chrome and Firefox browsers are largely implemented in C++ for its performance and modularity. Type casting, which converts one type of an object to another, plays an essential role in enabling polymorphism in C++ because it allows a program to utilize certain general or specific implementations in the class hierarchies. However, if not correctly used, it may return unsafe and incorrectly casted values, leading to so-called bad-casting or type-confusion vulnerabilities. Since a bad-casted pointer violates a programmer’s intended pointer semantics and enables an attacker to corrupt memory, bad-casting has critical security implications similar to those of other memory corruption vulnerabilities. Despite the increasing number of bad-casting vulnerabilities, the bad-casting detection problem has not been addressed by the security community. In this paper, we present CAVER, a runtime bad-casting detection tool. It performs program instrumentation at compile time and uses a new runtime type tracing mechanism—the type hierarchy table—to overcome the limitation of existing approaches and efficiently verify type casting dynamically. In particular, CAVER can be easily and automatically adopted to target applications, achieves broader detection coverage, and incurs reasonable runtime overhead. We have applied CAVER to largescale software including Chrome and Firefox browsers, and discovered 11 previously unknown security vulnerabilities: nine in GNU libstdc++ and two in Firefox, all of which have been confirmed and subsequently fixed by vendors. Our evaluation showed that CAVER imposes up to 7.6% and 64.6% overhead for performance-intensive benchmarks on the Chromium and Firefox browsers, respectively.</p>
<p>【Keywords】:</p>
<h2 id="Operating System Security: It's All About the Base    3">Operating System Security: It's All About the Base    3</h2>
<h3 id="21. Trustworthy Whole-System Provenance for the Linux Kernel.">21. Trustworthy Whole-System Provenance for the Linux Kernel.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/bates">Paper Link</a>】    【Pages】:319-334</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Bates:Adam_M=">Adam M. Bates</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tian:Dave">Dave Tian</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Butler:Kevin_R=_B=">Kevin R. B. Butler</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Moyer:Thomas">Thomas Moyer</a></p>
<p>【Abstract】:
In a provenance-aware system, mechanisms gather and report metadata that describes the history of each object being processed on the system, allowing users to understand how data objects came to exist in their present state. However, while past work has demonstrated the usefulness of provenance, less attention has been given to securing provenance-aware systems. Provenance itself is a ripe attack vector, and its authenticity and integrity must be guaranteed before it can be put to use. We present Linux Provenance Modules (LPM), the first general framework for the development of provenance-aware systems. We demonstrate that LPM creates a trusted provenance-aware execution environment, collecting complete whole-system provenance while imposing as little as 2.7% performance overhead on normal system operation. LPM introduces new mechanisms for secure provenance layering and authenticated communication between provenance-aware hosts, and also interoperates with existing mechanisms to provide strong security assurances. To demonstrate the potential uses of LPM, we design a Provenance-Based Data Loss Prevention (PB-DLP) system. We implement PBDLP as a file transfer application that blocks the transmission of files derived from sensitive ancestors while imposing just tens of milliseconds overhead. LPM is the first step towards widespread deployment of trustworthy provenance-aware applications.</p>
<p>【Keywords】:</p>
<h3 id="22. Securing Self-Virtualizing Ethernet Devices.">22. Securing Self-Virtualizing Ethernet Devices.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/smolyar">Paper Link</a>】    【Pages】:335-350</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Smolyar:Igor">Igor Smolyar</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Ben=Yehuda:Muli">Muli Ben-Yehuda</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tsafrir:Dan">Dan Tsafrir</a></p>
<p>【Abstract】:
Single root I/O virtualization (SRIOV) is a hardware/ software interface that allows devices to “self virtualize” and thereby remove the host from the critical I/O path. SRIOV thus brings near bare-metal performance to untrusted guest virtual machines (VMs) in public clouds, enterprise data centers, and high-performance computing setups. We identify a design flaw in current Ethernet SRIOV NIC deployments that enables untrusted VMs to completely control the throughput and latency of other, unrelated VMs. The attack exploits Ethernet ”pause” frames, which enable network flow control functionality. We experimentally launch the attack across several NIC models and find that it is effective and highly accurate, with substantial consequences if left unmitigated: (1) to be safe, NIC vendors will have to modify their NICs so as to filter pause frames originating from SRIOV instances; (2) in the meantime, administrators will have to either trust their VMs, or configure their switches to ignore pause frames, thus relinquishing flow control, which might severely degrade networking performance. We present the Virtualization-Aware Network Flow Controller (VANFC), a software-based SRIOV NIC prototype that overcomes the attack. VANFC filters pause frames from malicious virtual machines without any loss of performance, while keeping SRIOV and Ethernet flow control hardware/software interfaces intact.</p>
<p>【Keywords】:</p>
<h3 id="23. EASEAndroid: Automatic Policy Analysis and Refinement for Security Enhanced Android via Large-Scale Semi-Supervised Learning.">23. EASEAndroid: Automatic Policy Analysis and Refinement for Security Enhanced Android via Large-Scale Semi-Supervised Learning.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/wang-ruowen">Paper Link</a>】    【Pages】:351-366</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Ruowen">Ruowen Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/e/Enck:William">William Enck</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Reeves:Douglas_S=">Douglas S. Reeves</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Xinwen">Xinwen Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/Ning:Peng">Peng Ning</a> ; <a href="http://dblp.uni-trier.de/pers/hd/x/Xu:Dingbang">Dingbang Xu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhou:Wu">Wu Zhou</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Azab:Ahmed_M=">Ahmed M. Azab</a></p>
<p>【Abstract】:
Mandatory protection systems such as SELinux and SEAndroid harden operating system integrity. Unfortunately, policy development is error prone and requires lengthy refinement using audit logs from deployed systems. While prior work has studied SELinux policy in detail, SEAndroid is relatively new and has received little attention. SEAndroid policy engineering differs significantly from SELinux: Android fundamentally differs from traditional Linux; the same policy is used on millions of devices for which new audit logs are continually available; and audit logs contain a mix of benign and malicious accesses. In this paper, we propose EASEAndroid, the first SEAndroid analytic platform for automatic policy analysis and refinement. Our key insight is that the policy refinement process can be modeled and automated using semi-supervised learning. Given an existing policy and a small set of known access patterns, EASEAndroid continually expands the knowledge base as new audit logs become available, producing suggestions for policy refinement. We evaluate EASEAndroid on 1.3 million audit logs from real-world devices. EASEAndroid successfully learns 2,518 new access patterns and generates 331 new policy rules. During this process, EASEAndroid discovers eight categories of attack access patterns in real devices, two of which are new attacks directly against the SEAndroid MAC mechanism.</p>
<p>【Keywords】:</p>
<h2 id="Ace Ventura: PETS Detective    3">Ace Ventura: PETS Detective    3</h2>
<h3 id="24. Marionette: A Programmable Network Traffic Obfuscation System.">24. Marionette: A Programmable Network Traffic Obfuscation System.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/dyer">Paper Link</a>】    【Pages】:367-382</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/d/Dyer:Kevin_P=">Kevin P. Dyer</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Coull:Scott_E=">Scott E. Coull</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shrimpton:Thomas">Thomas Shrimpton</a></p>
<p>【Abstract】:
Recently, a number of obfuscation systems have been developed to aid in censorship circumvention scenarios where encrypted network traffic is filtered. In this paper, we present Marionette, the first programmable network traffic obfuscation system capable of simultaneously controlling encrypted traffic features at a variety of levels, including ciphertext formats, stateful protocol semantics, and statistical properties. The behavior of the system is directed by a powerful type of probabilistic automata and specified in a user-friendly domain-specific language, which allows the user to easily adjust their obfuscation strategy to meet the unique needs of their network environment. In fact, the Marionette system is capable of emulating many existing obfuscation systems, and enables developers to explore a breadth of protocols and depth of traffic features that have, so far, been unattainable. We evaluate Marionette through a series of case studies inspired by censor capabilities demonstrated in the real-world and research literature, including passive network monitors, stateful proxies, and active probing. The results of our experiments not only show that Marionette provides outstanding flexibility and control over traffic features, but it is also capable of achieving throughput of up to 6:7Mbps when generating RFCcompliant cover traffic.</p>
<p>【Keywords】:</p>
<h3 id="25. CONIKS: Bringing Key Transparency to End Users.">25. CONIKS: Bringing Key Transparency to End Users.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/melara">Paper Link</a>】    【Pages】:383-398</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Melara:Marcela_S=">Marcela S. Melara</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Blankstein:Aaron">Aaron Blankstein</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bonneau:Joseph">Joseph Bonneau</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Felten:Edward_W=">Edward W. Felten</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Freedman:Michael_J=">Michael J. Freedman</a></p>
<p>【Abstract】:
We present CONIKS, an end-user key verification service capable of integration in end-to-end encrypted communication systems. CONIKS builds on transparency log proposals for web server certificates but solves several new challenges specific to key verification for end users. CONIKS obviates the need for global third-party monitors and enables users to efficiently monitor their own key bindings for consistency, downloading less than 20 kB per day to do so even for a provider with billions of users. CONIKS users and providers can collectively audit providers for non-equivocation, and this requires downloading a constant 2.5 kB per provider per day. Additionally, CONIKS preserves the level of privacy offered by today’s major communication services, hiding the list of usernames present and even allowing providers to conceal the total number of users in the system.</p>
<p>【Keywords】:</p>
<h3 id="26. Investigating the Computer Security Practices and Needs of Journalists.">26. Investigating the Computer Security Practices and Needs of Journalists.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/mcgregor">Paper Link</a>】    【Pages】:399-414</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/McGregor:Susan_E=">Susan E. McGregor</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Charters:Polina">Polina Charters</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Holliday:Tobin">Tobin Holliday</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Roesner:Franziska">Franziska Roesner</a></p>
<p>【Abstract】:
Though journalists are often cited as potential users of computer security technologies, their practices and mental models have not been deeply studied by the academic computer security community. Such an understanding, however, is critical to developing technical solutions that can address the real needs of journalists and integrate into their existing practices. We seek to provide that insight in this paper, by investigating the general and computer security practices of 15 journalists in the U.S. and France via in-depth, semi-structured interviews. Among our findings is evidence that existing security tools fail not only due to usability issues but when they actively interfere with other aspects of the journalistic process; that communication methods are typically driven by sources rather than journalists; and that journalists’ organizations play an important role in influencing journalists’ behaviors. Based on these and other findings, we make recommendations to the computer security community for improvements to existing tools and future lines of research.</p>
<p>【Keywords】:</p>
<h2 id="ORAMorama!    3">ORAMorama!    3</h2>
<h3 id="27. Constants Count: Practical Improvements to Oblivious RAM.">27. Constants Count: Practical Improvements to Oblivious RAM.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/ren-ling">Paper Link</a>】    【Pages】:415-430</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/r/Ren_0001:Ling">Ling Ren</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Fletcher:Christopher_W=">Christopher W. Fletcher</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kwon:Albert">Albert Kwon</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Stefanov:Emil">Emil Stefanov</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shi:Elaine">Elaine Shi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Dijk:Marten_van">Marten van Dijk</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Devadas:Srinivas">Srinivas Devadas</a></p>
<p>【Abstract】:
Oblivious RAM (ORAM) is a cryptographic primitive that hides memory access patterns as seen by untrusted storage. This paper proposes Ring ORAM, the most bandwidth-efficient ORAM scheme for the small client storage setting in both theory and practice. Ring ORAM is the first tree-based ORAM whose bandwidth is independent of the ORAM bucket size, a property that unlocks multiple performance improvements. First, Ring ORAM’s overall bandwidth is 2.3x to 4x better than Path ORAM, the prior-art scheme for small client storage. Second, if memory can perform simple untrusted computation, Ring ORAM achieves constant online bandwidth (~ 60x improvement over Path ORAM for practical parameters). As a case study, we show Ring ORAM speeds up program completion time in a secure processor by 1.5x relative to Path ORAM. On the theory side, Ring ORAM features a tighter and significantly simpler analysis than Path ORAM.</p>
<p>【Keywords】:</p>
<h3 id="28. Raccoon: Closing Digital Side-Channels through Obfuscated Execution.">28. Raccoon: Closing Digital Side-Channels through Obfuscated Execution.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/rane">Paper Link</a>】    【Pages】:431-446</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/r/Rane:Ashay">Ashay Rane</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lin:Calvin">Calvin Lin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tiwari:Mohit">Mohit Tiwari</a></p>
<p>【Abstract】:
Side-channel attacks monitor some aspect of a computer system’s behavior to infer the values of secret data. Numerous side-channels have been exploited, including those that monitor caches, the branch predictor, and the memory address bus. This paper presents a method of defending against a broad class of side-channel attacks, which we refer to as digital side-channel attacks. The key idea is to obfuscate the program at the source code level to provide the illusion that many extraneous program paths are executed. This paper describes the technical issues involved in using this idea to provide confidentiality while minimizing execution overhead. We argue about the correctness and security of our compiler transformations and demonstrate that our transformations are safe in the context of a modern processor. Our empirical evaluation shows that our solution is 8.9x faster than prior work (GhostRider [20]) that specifically defends against memory trace-based side-channel attacks.</p>
<p>【Keywords】:</p>
<h3 id="29. M2R: Enabling Stronger Privacy in MapReduce Computation.">29. M2R: Enabling Stronger Privacy in MapReduce Computation.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/dinh">Paper Link</a>】    【Pages】:447-462</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/d/Dinh:Tien_Tuan_Anh">Tien Tuan Anh Dinh</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Saxena:Prateek">Prateek Saxena</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Chang:Ee=Chien">Ee-Chien Chang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/o/Ooi:Beng_Chin">Beng Chin Ooi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Chunwang">Chunwang Zhang</a></p>
<p>【Abstract】:
New big-data analysis platforms can enable distributed computation on encrypted data by utilizing trusted computing primitives available in commodity server hardware. We study techniques for ensuring privacy preserving computation in the popular MapReduce framework. In this paper, we first show that protecting only individual units of distributed computation (e.g. map and reduce units), as proposed in recent works, leaves several important channels of information leakage exposed to the adversary. Next, we analyze a variety of design choices in achieving a stronger notion of private execution that is the analogue of using a distributed oblivious-RAM (ORAM) across the platform. We develop a simple solution which avoids using the expensive ORAM construction, and incurs only an additive logarithmic factor of overhead to the latency. We implement our solution in a system called M2R, which enhances an existing Hadoop implementation, and evaluate it on seven standard MapReduce benchmarks. We show that it is easy to port most existing applications to M2R by changing fewer than 43 lines of code. M2R adds fewer than 500 lines of code to the TCB, which is less than 0:16% of the Hadoop codebase. M2R offers a factor of 1:3x to 44:6x lower overhead than extensions of previous solutions with equivalent privacy. M2R adds a total of 17% to 130% overhead over the insecure baseline solution that ignores the leakage channels M2R addresses.</p>
<p>【Keywords】:</p>
<h2 id="But Maybe All You Need Is Something to Trust    3">But Maybe All You Need Is Something to Trust    3</h2>
<h3 id="30. Measuring Real-World Accuracies and Biases in Modeling Password Guessability.">30. Measuring Real-World Accuracies and Biases in Modeling Password Guessability.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/ur">Paper Link</a>】    【Pages】:463-481</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/u/Ur:Blase">Blase Ur</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Segreti:Sean_M=">Sean M. Segreti</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bauer:Lujo">Lujo Bauer</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Christin:Nicolas">Nicolas Christin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Cranor:Lorrie_Faith">Lorrie Faith Cranor</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Komanduri:Saranga">Saranga Komanduri</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kurilova:Darya">Darya Kurilova</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Mazurek:Michelle_L=">Michelle L. Mazurek</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Melicher:William">William Melicher</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shay:Richard">Richard Shay</a></p>
<p>【Abstract】:
Parameterized password guessability—how many guesses a particular cracking algorithm with particular training data would take to guess a password—has become a common metric of password security. Unlike statistical metrics, it aims to model real-world attackers and to provide per-password strength estimates. We investigate how cracking approaches often used by researchers compare to real-world cracking by professionals, as well as how the choice of approach biases research conclusions. We find that semi-automated cracking by professionals outperforms popular fully automated approaches, but can be approximated by combining multiple such approaches. These approaches are only effective, however, with careful configuration and tuning; in commonly used default configurations, they underestimate the real-world guessability of passwords. We find that analyses of large password sets are often robust to the algorithm used for guessing as long as it is configured effectively. However, cracking algorithms differ systematically in their effectiveness guessing passwords with certain common features (e.g., character substitutions). This has important implications for analyzing the security of specific password characteristics or of individual passwords (e.g., in a password meter or security audit). Our results highlight the danger of relying only on a single cracking algorithm as a measure of password strength and constitute the first scientific evidence that automated guessing can often approximate guessing by professionals.</p>
<p>【Keywords】:</p>
<h3 id="31. Sound-Proof: Usable Two-Factor Authentication Based on Ambient Sound.">31. Sound-Proof: Usable Two-Factor Authentication Based on Ambient Sound.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/karapanos">Paper Link</a>】    【Pages】:483-498</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/k/Karapanos:Nikolaos">Nikolaos Karapanos</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Marforio:Claudio">Claudio Marforio</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Soriente:Claudio">Claudio Soriente</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Capkun:Srdjan">Srdjan Capkun</a></p>
<p>【Abstract】:
Two-factor authentication protects online accounts even if passwords are leaked. Most users, however, prefer password-only authentication. One reason why twofactor authentication is so unpopular is the extra steps that the user must complete in order to log in. Currently deployed two-factor authentication mechanisms require the user to interact with his phone to, for example, copy a verification code to the browser. Two-factor authentication schemes that eliminate user-phone interaction exist, but require additional software to be deployed. In this paper we propose Sound-Proof, a usable and deployable two-factor authentication mechanism. Sound-Proof does not require interaction between the user and his phone. In Sound-Proof the second authentication factor is the proximity of the user’s phone to the device being used to log in. The proximity of the two devices is verified by comparing the ambient noise recorded by their microphones. Audio recording and comparison are transparent to the user, so that the user experience is similar to the one of password-only authentication. Sound-Proof can be easily deployed as it works with current phones and major browsers without plugins. We build a prototype for both Android and iOS. We provide empirical evidence that ambient noise is a robust discriminant to determine the proximity of two devices both indoors and outdoors, and even if the phone is in a pocket or purse. We conduct a user study designed to compare the perceived usability of Sound-Proof with Google 2-Step Verification. Participants ranked Sound- Proof as more usable and the majority would be willing to use Sound-Proof even for scenarios in which two-factor authentication is optional.</p>
<p>【Keywords】:</p>
<h3 id="32. Android Permissions Remystified: A Field Study on Contextual Integrity.">32. Android Permissions Remystified: A Field Study on Contextual Integrity.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/wijesekera">Paper Link</a>】    【Pages】:499-514</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/w/Wijesekera:Primal">Primal Wijesekera</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Baokar:Arjun">Arjun Baokar</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Hosseini:Ashkan">Ashkan Hosseini</a> ; <a href="http://dblp.uni-trier.de/pers/hd/e/Egelman:Serge">Serge Egelman</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wagner:David">David Wagner</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Beznosov:Konstantin">Konstantin Beznosov</a></p>
<p>【Abstract】:
We instrumented the Android platform to collect data regarding how often and under what circumstances smartphone applications access protected resources regulated by permissions. We performed a 36-person field study to explore the notion of “contextual integrity,” i.e., how often applications access protected resources when users are not expecting it. Based on our collection of 27M data points and exit interviews with participants, we examine the situations in which users would like the ability to deny applications access to protected resources. At least 80% of our participants would have preferred to prevent at least one permission request, and overall, they stated a desire to block over a third of all requests. Our findings pave the way for future systems to automatically determine the situations in which users would want to be confronted with security decisions.</p>
<p>【Keywords】:</p>
<h2 id="PELCGB    3">PELCGB    3</h2>
<h3 id="33. Phasing: Private Set Intersection Using Permutation-based Hashing.">33. Phasing: Private Set Intersection Using Permutation-based Hashing.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/pinkas">Paper Link</a>】    【Pages】:515-530</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/p/Pinkas:Benny">Benny Pinkas</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Schneider_0003:Thomas">Thomas Schneider</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Segev:Gil">Gil Segev</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zohner:Michael">Michael Zohner</a></p>
<p>【Abstract】:
Private Set Intersection (PSI) allows two parties to compute the intersection of private sets while revealing nothing more than the intersection itself. PSI needs to be applied to large data sets in scenarios such as measurement of ad conversion rates, data sharing, or contact discovery. Existing PSI protocols do not scale up well, and therefore some applications use insecure solutions instead. We describe a new approach for designing PSI protocols based on permutation-based hashing, which enables to reduce the length of items mapped to bins while ensuring that no collisions occur. We denote this approach as Phasing, for Permutation-based Hashing Set Intersection. Phasing can dramatically improve the performance of PSI protocols whose overhead depends on the length of the representations of input items. We apply Phasing to design a new approach for circuit-based PSI protocols. The resulting protocol is up to 5 times faster than the previously best Sort-Compare- Shuffle circuit of Huang et al. (NDSS 2012). We also apply Phasing to the OT-based PSI protocol of Pinkas et al. (USENIX Security 2014), which is the fastest PSI protocol to date. Together with additional improvements that reduce the computation complexity by a logarithmic factor, the resulting protocol improves run-time by a factor of up to 20 and can also have similar communication overhead as the previously best PSI protocol in that respect. The new protocol is only moderately less efficient than an insecure PSI protocol that is currently used by real-world applications, and is therefore the first secure PSI protocol that is scalable to the demands and the constraints of current real-world settings.</p>
<p>【Keywords】:</p>
<h3 id="34. Faster Secure Computation through Automatic Parallelization.">34. Faster Secure Computation through Automatic Parallelization.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/buescher">Paper Link</a>】    【Pages】:531-546</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/B=uuml=scher:Niklas">Niklas Büscher</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Katzenbeisser_0001:Stefan">Stefan Katzenbeisser</a></p>
<p>【Abstract】:
Secure two-party computation (TPC) based on Yao’s garbled circuits has seen a lot of progress over the past decade. Yet, compared with generic computation, TPC is still multiple orders of magnitude slower. To improve the efficiency of secure computation based on Yao’s protocol, we propose a practical parallelization scheme. Its advances over existing parallelization approaches are twofold. First, we present a compiler that detects parallelism at the source code level and automatically transforms C code into parallel circuits. Second, by switching the roles of circuit generator and evaluator between both computing parties in the semi-honest model, our scheme makes better use of computation and network resources. This inter-party parallelization approach leads to significant efficiency increases already on single-core hardware without compromising security. Multiple implementations illustrate the practicality of our approach. For instance, we report speed-ups of up to 2.18 on 2 cores and 4.36 on 4 cores for the example application of parallel modular exponentiation.</p>
<p>【Keywords】:</p>
<h3 id="35. The Pythia PRF Service.">35. The Pythia PRF Service.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/everspaugh">Paper Link</a>】    【Pages】:547-562</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/e/Everspaugh:Adam">Adam Everspaugh</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Chatterjee:Rahul">Rahul Chatterjee</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Scott:Samuel">Samuel Scott</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Juels:Ari">Ari Juels</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Ristenpart:Thomas">Thomas Ristenpart</a></p>
<p>【Abstract】:
Conventional cryptographic services such as hardware-security modules and software-based keymanagement systems offer the ability to apply a pseudorandom function (PRF) such as HMAC to inputs of a client’s choosing. These services are used, for example, to harden stored password hashes against offline brute-force attacks. We propose a modern PRF service called PYTHIA designed to offer a level of flexibility, security, and easeof- deployability lacking in prior approaches. The keystone of PYTHIA is a new cryptographic primitive called a verifiable partially-oblivious PRF that reveals a portion of an input message to the service but hides the rest. We give a construction that additionally supports efficient bulk rotation of previously obtained PRF values to new keys. Performance measurements show that our construction, which relies on bilinear pairings and zero-knowledge proofs, is highly practical. We also give accompanying formal definitions and proofs of security. We implement PYTHIA as a multi-tenant, scalable PRF service that can scale up to hundreds of millions of distinct client applications on commodity systems. In our prototype implementation, query latencies are 15 ms in local-area settings and throughput is within a factor of two of a standard HTTPS server. We further report on implementations of two applications using PYTHIA, showing how to bring its security benefits to a new enterprise password storage system and a new brainwallet system for Bitcoin.</p>
<p>【Keywords】:</p>
<h2 id="And the Hackers Gonna Hack, Hack, Hack, Hack, Hack    3">And the Hackers Gonna Hack, Hack, Hack, Hack, Hack    3</h2>
<h3 id="36. EVILCOHORT: Detecting Communities of Malicious Accounts on Online Services.">36. EVILCOHORT: Detecting Communities of Malicious Accounts on Online Services.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/stringhini">Paper Link</a>】    【Pages】:563-578</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Stringhini:Gianluca">Gianluca Stringhini</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Mourlanne:Pierre">Pierre Mourlanne</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Jacob:Gr=eacute=goire">Grégoire Jacob</a> ; <a href="http://dblp.uni-trier.de/pers/hd/e/Egele:Manuel">Manuel Egele</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kruegel:Christopher">Christopher Kruegel</a> ; <a href="http://dblp.uni-trier.de/pers/hd/v/Vigna:Giovanni">Giovanni Vigna</a></p>
<p>【Abstract】:
Cybercriminals misuse accounts on online services (e.g., webmails and online social networks) to perform malicious activity, such as spreading malicious content or stealing sensitive information. In this paper, we show that accounts that are accessed by botnets are a popular choice by cybercriminals. Since botnets are composed of a finite number of infected computers, we observe that cybercriminals tend to have their bots connect to multiple online accounts to perform malicious activity. We present EVILCOHORT, a system that detects online accounts that are accessed by a common set of infected machines. EVILCOHORT only needs the mapping between an online account and an IP address to operate, and can therefore detect malicious accounts on any online service (webmail services, online social networks, storage services) regardless of the type of malicious activity that these accounts perform. Unlike previous work, our system can identify malicious accounts that are controlled by botnets but do not post any malicious content (e.g., spam) on the service. We evaluated EVILCOHORT on multiple online services of different types (a webmail service and four online social networks), and show that it accurately identifies malicious accounts.</p>
<p>【Keywords】:</p>
<h3 id="37. Trends and Lessons from Three Years Fighting Malicious Extensions.">37. Trends and Lessons from Three Years Fighting Malicious Extensions.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/jagpal">Paper Link</a>】    【Pages】:579-593</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/j/Jagpal:Nav">Nav Jagpal</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Dingle:Eric">Eric Dingle</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Gravel:Jean=Philippe">Jean-Philippe Gravel</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Mavrommatis:Panayiotis">Panayiotis Mavrommatis</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Provos:Niels">Niels Provos</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Rajab:Moheeb_Abu">Moheeb Abu Rajab</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Thomas:Kurt">Kurt Thomas</a></p>
<p>【Abstract】:
In this work we expose wide-spread efforts by criminals to abuse the Chrome Web Store as a platform for distributing malicious extensions. A central component of our study is the design and implementation of WebEval, the first system that broadly identifies malicious extensions with a concrete, measurable detection rate of 96.5%. Over the last three years we detected 9,523 malicious extensions: nearly 10% of every extension submitted to the store. Despite a short window of operation—we removed 50% of malware within 25 minutes of creation— a handful of under 100 extensions escaped immediate detection and infected over 50 million Chrome users. Our results highlight that the extension abuse ecosystem is drastically different from malicious binaries: miscreants profit from web traffic and user tracking rather than email spam or banking theft.</p>
<p>【Keywords】:</p>
<h3 id="38. Meerkat: Detecting Website Defacements through Image-based Object Recognition.">38. Meerkat: Detecting Website Defacements through Image-based Object Recognition.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/borgolte">Paper Link</a>】    【Pages】:595-610</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Borgolte:Kevin">Kevin Borgolte</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kruegel:Christopher">Christopher Kruegel</a> ; <a href="http://dblp.uni-trier.de/pers/hd/v/Vigna:Giovanni">Giovanni Vigna</a></p>
<p>【Abstract】:
Website defacements and website vandalism can inflict significant harm on the website owner through the loss of sales, the loss in reputation, or because of legal ramifications. Prior work on website defacements detection focused on detecting unauthorized changes to the web server, e.g., via host-based intrusion detection systems or file-based integrity checks. However, most prior approaches lack the capabilities to detect the most prevailing defacement techniques used today: code and/or data injection attacks, and DNS hijacking. This is because these attacks do not actually modify the code or configuration of the website, but instead they introduce new content or redirect the user to a different website. In this paper, we approach the problem of defacement detection from a different angle: we use computer vision techniques to recognize if a website was defaced, similarly to how a human analyst decides if a website was defaced when viewing it in a web browser. We introduce MEERKAT, a defacement detection system that requires no prior knowledge about the website’s content or its structure, but only its URL. Upon detection of a defacement, the system notifies the website operator that his website is defaced, who can then take appropriate action. To detect defacements, MEERKAT automatically learns high-level features from screenshots of defaced websites by combining recent advances in machine learning, like stacked autoencoders and deep neural networks, with techniques from computer vision. These features are then used to create models that allow for the detection of newly-defaced websites. We show the practicality ofMEERKAT on the largest website defacement dataset to date, comprising of 10,053,772 defacements observed between January 1998 and May 2014, and 2,554,905 legitimate websites. Overall, MEERKAT achieves true positive rates between 97.422% and 98.816%, false positive rates between 0.547% and 1.528%, and Bayesian detection rates between 98.583% and 99.845%, thus significantly outperforming existing approaches.</p>
<p>【Keywords】:</p>
<h2 id="It's a Binary Joke: Either You Get It, or You Don't    3">It's a Binary Joke: Either You Get It, or You Don't    3</h2>
<h3 id="39. Recognizing Functions in Binaries with Neural Networks.">39. Recognizing Functions in Binaries with Neural Networks.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/shin">Paper Link</a>】    【Pages】:611-626</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Shin:Eui_Chul_Richard">Eui Chul Richard Shin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Song:Dawn">Dawn Song</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Moazzezi:Reza">Reza Moazzezi</a></p>
<p>【Abstract】:
Binary analysis facilitates many important applications like malware detection and automatically fixing vulnerable software. In this paper, we propose to apply artificial neural networks to solve important yet difficult problems in binary analysis. Specifically, we tackle the problem of function identification, a crucial first step in many binary analysis techniques. Although neural networks have undergone a renaissance in the past few years, achieving breakthrough results in multiple application domains such as visual object recognition, language modeling, and speech recognition, no researchers have yet attempted to apply these techniques to problems in binary analysis. Using a dataset from prior work, we show that recurrent neural networks can identify functions in binaries with greater accuracy and efficiency than the state-of-the-art machine-learning-based method. We can train the model an order of magnitude faster and evaluate it on binaries hundreds of times faster. Furthermore, it halves the error rate on six out of eight benchmarks, and performs comparably on the remaining two.</p>
<p>【Keywords】:</p>
<h3 id="40. Reassembleable Disassembling.">40. Reassembleable Disassembling.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/wang-shuai">Paper Link</a>】    【Pages】:627-642</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Shuai">Shuai Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Pei">Pei Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wu:Dinghao">Dinghao Wu</a></p>
<p>【Abstract】:
Reverse engineering has many important applications in computer security, one of which is retrofitting software for safety and security hardening when source code is not available. By surveying available commercial and academic reverse engineering tools, we surprisingly found that no existing tool is able to disassemble executable binaries into assembly code that can be correctly assembled back in a fully automated manner, even for simple programs. Actually in many cases, the resulted disassembled code is far from a state that an assembler accepts, which is hard to fix even by manual effort. This has become a severe obstacle. People have tried to overcome it by patching or duplicating new code sections for retrofitting of executables, which is not only inefficient but also cumbersome and restrictive on what retrofitting techniques can be applied to. In this paper, we present UROBOROS, a tool that can disassemble executables to the extent that the generated code can be assembled back to working binaries without manual effort. By empirically studying 244 binaries, we summarize a set of rules that can make the disassembled code relocatable, which is the key to reassembleable disassembling. With UROBOROS, the disassembly-reassembly process can be repeated thousands of times. We have implemented a prototype of UROBOROS and tested over the whole set of GNU Coreutils, SPEC2006, and a set of other real-world application and server programs. The experiment results show that our tool is effective with a very modest cost.</p>
<p>【Keywords】:</p>
<h3 id="41. How the ELF Ruined Christmas.">41. How the ELF Ruined Christmas.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/di-frederico">Paper Link</a>】    【Pages】:643-658</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/f/Federico:Alessandro_Di">Alessandro Di Federico</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Cama:Amat">Amat Cama</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shoshitaishvili:Yan">Yan Shoshitaishvili</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kruegel:Christopher">Christopher Kruegel</a> ; <a href="http://dblp.uni-trier.de/pers/hd/v/Vigna:Giovanni">Giovanni Vigna</a></p>
<p>【Abstract】:
Throughout the last few decades, computer software has experienced an arms race between exploitation techniques leveraging memory corruption and detection/protection mechanisms. Effective mitigation techniques, such as Address Space Layout Randomization, have significantly increased the difficulty of successfully exploiting a vulnerability. A modern exploit is often two-stage: a first information disclosure step to identify the memory layout, and a second step with the actual exploit. However, because of the wide range of conditions under which memory corruption occurs, retrieving memory layout information from the program is not always possible. In this paper, we present a technique that uses the dynamic loader’s ability to identify the locations of critical functions directly and call them, without requiring an information leak. We identified several fundamental weak points in the design of ELF standard and dynamic loader implementations that can be exploited to resolve and execute arbitrary library functions. Through these, we are able to bypass specific security mitigation techniques, including partial and full RELRO, which are specifically designed to protect ELF data-structures from being coopted by attackers. We implemented a prototype tool, Leakless, and evaluated it against different dynamic loader implementations, previous attack techniques, and reallife case studies to determine the impact of our findings. Among other implications, Leakless provides attackers with reliable and non-invasive attacks, less likely to trigger intrusion detection systems.</p>
<p>【Keywords】:</p>
<h2 id="Pain in the App    3">Pain in the App    3</h2>
<h3 id="42. Finding Unknown Malice in 10 Seconds: Mass Vetting for New Threats at the Google-Play Scale.">42. Finding Unknown Malice in 10 Seconds: Mass Vetting for New Threats at the Google-Play Scale.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/chen-kai">Paper Link</a>】    【Pages】:659-674</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/c/Chen_0012:Kai">Kai Chen</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Peng">Peng Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lee:Yeonjoon">Yeonjoon Lee</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang:XiaoFeng">XiaoFeng Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Nan">Nan Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Huang:Heqing">Heqing Huang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zou:Wei">Wei Zou</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Liu_0005:Peng">Peng Liu</a></p>
<p>【Abstract】:
An app market’s vetting process is expected to be scalable and effective. However, today’s vetting mechanisms are slow and less capable of catching new threats. In our research, we found that a more powerful solution can be found by exploiting the way Android malware is constructed and disseminated, which is typically through repackaging legitimate apps with similar malicious components. As a result, such attack payloads often stand out from those of the same repackaging origin and also show up in the apps not supposed to relate to each other. Based upon this observation, we developed a new technique, called MassVet, for vetting apps at a massive scale, without knowing what malware looks like and how it behaves. Unlike existing detection mechanisms, which often utilize heavyweight program analysis techniques, our approach simply compares a submitted app with all those already on a market, focusing on the difference between those sharing a similar UI structure (indicating a possible repackaging relation), and the commonality among those seemingly unrelated. Once public libraries and other legitimate code reuse are removed, such diff/common program components become highly suspicious. In our research, we built this “DiffCom” analysis on top of an efficient similarity comparison algorithm, which maps the salient features of an app’s UI structure or a method’s control-flow graph to a value for a fast comparison. We implemented MassVet over a stream processing engine and evaluated it nearly 1.2 million apps from 33 app markets around the world, the scale of Google Play. Our study shows that the technique can vet an app within 10 seconds at a low false detection rate. Also, it outperformed all 54 scanners in VirusTotal (NOD32, Symantec, McAfee, etc.) in terms of detection coverage, capturing over a hundred thousand malicious apps, including over 20 likely zero-day malware and those installed millions of times. A close look at these apps brings to light intriguing new observations: e.g., Google’s detection strategy and malware authors’ countermoves that cause the mysterious disappearance and reappearance of some Google Play apps.</p>
<p>【Keywords】:</p>
<h3 id="43. You Shouldn't Collect My Secrets: Thwarting Sensitive Keystroke Leakage in Mobile IME Apps.">43. You Shouldn't Collect My Secrets: Thwarting Sensitive Keystroke Leakage in Mobile IME Apps.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/chen-jin">Paper Link</a>】    【Pages】:657-690</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/c/Chen:Jin">Jin Chen</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Chen:Haibo">Haibo Chen</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bauman:Erick">Erick Bauman</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lin:Zhiqiang">Zhiqiang Lin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zang:Binyu">Binyu Zang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Guan:Haibing">Haibing Guan</a></p>
<p>【Abstract】:
IME (input method editor) apps are the primary means of interaction on mobile touch screen devices and thus are usually granted with access to a wealth of private user input. In order to understand the (in)security of mobile IME apps, this paper first performs a systematic study and uncovers that many IME apps may (intentionally or unintentionally) leak users’ sensitive data to the outside world (mainly due to the incentives of improving the user’s experience). To thwart the threat of sensitive information leakage while retaining the benefits of an improved user experience, this paper then proposes I-BOX, an app-transparent oblivious sandbox that minimizes sensitive input leakage by confining untrusted IME apps to predefined security policies. Several key challenges have to be addressed due to the proprietary and closed-source nature of most IME apps and the fact that an IME app can arbitrarily store and transform user input before sending it out. By designing system-level transactional execution, I-BOX works seamlessly and transparently with IME apps. Specifically, I-BOX first checkpoints an IME app’s state before the first keystroke of an input, monitors and analyzes the user’s input, and rolls back the state to the checkpoint if it detects the potential danger that sensitive input may be leaked. A proof of concept I-BOX prototype has been built for Android and tested with a set of popular IME apps. Experimental results show that I-BOX is able to thwart the leakage of sensitive input for untrusted IME apps, while incurring very small runtime overhead and little impact on user experience.</p>
<p>【Keywords】:</p>
<h3 id="44. Boxify: Full-fledged App Sandboxing for Stock Android.">44. Boxify: Full-fledged App Sandboxing for Stock Android.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/backes">Paper Link</a>】    【Pages】:691-706</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Backes_0001:Michael">Michael Backes</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bugiel:Sven">Sven Bugiel</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Hammer_0001:Christian">Christian Hammer</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Schranz:Oliver">Oliver Schranz</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Styp=Rekowsky:Philipp_von">Philipp von Styp-Rekowsky</a></p>
<p>【Abstract】:
We present the first concept for full-fledged app sandboxing on stock Android. Our approach is based on application virtualization and process-based privilege separation to securely encapsulate untrusted apps in an isolated environment. In contrast to all related work on stock Android, we eliminate the necessity to modify the code of monitored apps, and thereby overcome existing legal concerns and deployment problems that rewriting-based approaches have been facing. We realize our concept as a regular Android app called Boxify that can be deployed without firmware modifications or root privileges. A systematic evaluation of Boxify demonstrates its capability to enforce established security policies without incurring a significant runtime performance overhead.</p>
<p>【Keywords】:</p>
<h2 id="Oh, What a Tangled Web We Weave    3">Oh, What a Tangled Web We Weave    3</h2>
<h3 id="45. Cookies Lack Integrity: Real-World Implications.">45. Cookies Lack Integrity: Real-World Implications.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/zheng">Paper Link</a>】    【Pages】:707-721</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/z/Zheng:Xiaofeng">Xiaofeng Zheng</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Jiang:Jian">Jian Jiang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Liang:Jinjin">Jinjin Liang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Duan:Hai=Xin">Hai-Xin Duan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Chen:Shuo">Shuo Chen</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wan:Tao">Tao Wan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Weaver:Nicholas">Nicholas Weaver</a></p>
<p>【Abstract】:
A cookie can contain a “secure” flag, indicating that it should be only sent over an HTTPS connection. Yet there is no corresponding flag to indicate how a cookie was set: attackers who act as a man-in-the-middle even temporarily on an HTTP session can inject cookies which will be attached to subsequent HTTPS connections. Similar attacks can also be launched by a web attacker from a related domain. Although an acknowledged threat, it has not yet been studied thoroughly. This paper aims to fill this gap with an in-depth empirical assessment of cookie injection attacks. We find that cookie-related vulnerabilities are present in important sites (such as Google and Bank of America), and can be made worse by the implementation weaknesses we discovered in major web browsers (such as Chrome, Firefox, and Safari). Our successful attacks have included privacy violation, online victimization, and even financial loss and account hijacking. We also discuss mitigation strategies such as HSTS, possible browser changes, and present a proof-of-concept browser extension to provide better cookie isolation between HTTP and HTTPS, and between related domains.</p>
<p>【Keywords】:</p>
<h3 id="46. The Unexpected Dangers of Dynamic JavaScript.">46. The Unexpected Dangers of Dynamic JavaScript.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/lekies">Paper Link</a>】    【Pages】:723-735</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Lekies:Sebastian">Sebastian Lekies</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Stock:Ben">Ben Stock</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wentzel:Martin">Martin Wentzel</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Johns:Martin">Martin Johns</a></p>
<p>【Abstract】:
Modern Web sites frequently generate JavaScript on-the-fly via server-side scripting, incorporating personalized user data in the process. In general, cross-domain access to such sensitive resources is prevented by the Same- Origin Policy. The inclusion of remote scripts via the HTML script tag, however, is exempt from this policy. This exemption allows an adversary to import and execute dynamically generated scripts while a user visits an attacker-controlled Web site. By observing the execution behavior and the side effects the inclusion of the dynamic script causes, the attacker is able to leak private user data leading to severe consequences ranging from privacy violations up to full compromise of user accounts. Although this issues has been known for several years under the term Cross-Site Script Inclusion, it has not been analyzed in-depth on the Web. Therefore, to systematically investigate the issue, we conduct a study on its prevalence in a set of 150 top-ranked domains. We observe that a third of the surveyed sites utilize dynamic JavaScript. After evaluating the effectiveness of the deployed countermeasures, we show that more than 80% of the sites are susceptible to attacks via remote script inclusion. Given the results of our study, we provide a secure and functionally equivalent alternative to the use of dynamic scripts.</p>
<p>【Keywords】:</p>
<h3 id="47. ZigZag: Automatically Hardening Web Applications Against Client-side Validation Vulnerabilities.">47. ZigZag: Automatically Hardening Web Applications Against Client-side Validation Vulnerabilities.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/weissbacher">Paper Link</a>】    【Pages】:737-752</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/w/Weissbacher:Michael">Michael Weissbacher</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Robertson:William_K=">William K. Robertson</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kirda:Engin">Engin Kirda</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kruegel:Christopher">Christopher Kruegel</a> ; <a href="http://dblp.uni-trier.de/pers/hd/v/Vigna:Giovanni">Giovanni Vigna</a></p>
<p>【Abstract】:
Modern web applications are increasingly moving program code to the client in the form of JavaScript. With the growing adoption of HTML5 APIs such as <code>postMessage</code>, client-side validation (CSV) vulnerabilities are consequently becoming increasingly important to address as well. However, while detecting and preventing attacks against web applications is a well-studied topic on the server, considerably less work has been performed for the client. Exacerbating this issue is the problem that defenses against CSVs must, in the general case, fundamentally exist in the browser, rendering current server-side defenses inadequate. In this paper, we present ZigZag, a system for hardening JavaScript-based web applications against clientside validation attacks. ZigZag transparently instruments client-side code to perform dynamic invariant detection on security-sensitive code, generating models that describe how—and with whom—client-side components interact. ZigZag is capable of handling templated JavaScript, avoiding full re-instrumentation when JavaScript programs are structurally similar. Learned invariants are then enforced through a subsequent instrumentation step. Our evaluation demonstrates that ZigZag is capable of automatically hardening client-side code against both known and previously-unknown vulnerabilities. Finally, we show that ZigZag introduces acceptable overhead in many cases, and is compatible with popular websites drawn from the Alexa Top 20 without developer or user intervention.</p>
<p>【Keywords】:</p>
<h2 id="The World's Address: An App That's Worn    3">The World's Address: An App That's Worn    3</h2>
<h3 id="48. Anatomization and Protection of Mobile Apps' Location Privacy Threats.">48. Anatomization and Protection of Mobile Apps' Location Privacy Threats.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/fawaz">Paper Link</a>】    【Pages】:753-768</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/f/Fawaz:Kassem">Kassem Fawaz</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Feng:Huan">Huan Feng</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shin:Kang_G=">Kang G. Shin</a></p>
<p>【Abstract】:
Mobile users are becoming increasingly aware of the privacy threats resulting from apps’ access of their location. Few of the solutions proposed thus far to mitigate these threats have been deployed as they require either app or platform modifications. Mobile operating systems (OSes) also provide users with location access controls. In this paper, we analyze the efficacy of these controls in combating the location-privacy threats. For this analysis, we conducted the first location measurement campaign of its kind, analyzing more than 1000 free apps from Google Play and collecting detailed usage of location by more than 400 location-aware apps and 70 Advertisement and Analytics (A&A;) libraries from more than 100 participants over a period ranging from 1 week to 1 year. Surprisingly, 70% of the apps and the A&A; libraries pose considerable profiling threats even when they sporadically access the user’s location. Existing OS controls are found ineffective and inefficient in mitigating these threats, thus calling for a finer-grained location access control. To meet this need, we propose LP-Doctor, a light-weight user-level tool that allows Android users to effectively utilize the OS’s location access controls while maintaining the required app’s functionality as our user study (with 227 participants) shows.</p>
<p>【Keywords】:</p>
<h3 id="49. LinkDroid: Reducing Unregulated Aggregation of App Usage Behaviors.">49. LinkDroid: Reducing Unregulated Aggregation of App Usage Behaviors.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/feng">Paper Link</a>】    【Pages】:769-783</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/f/Feng:Huan">Huan Feng</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Fawaz:Kassem">Kassem Fawaz</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shin:Kang_G=">Kang G. Shin</a></p>
<p>【Abstract】:
Usage behaviors of different smartphone apps capture different views of an individual’s life, and are largely independent of each other. However, in the current mobile app ecosystem, a curious party can covertly link and aggregate usage behaviors of the same user across different apps. We refer to this as unregulated aggregation of app usage behaviors. In this paper, we present a fresh perspective of unregulated aggregation, focusing on monitoring, characterizing and reducing the underlying linkability across apps. The cornerstone of our study is the Dynamic Linkability Graph (DLG) which tracks applevel linkability during runtime. We observed how DLG evolves on real-world users and identified real-world evidence of apps abusing IPCs and OS-level identifying information to establish linkability. Based on these observations, we propose a linkability-aware extension to current mobile operating systems, called LinkDroid,which provides runtime monitoring and mediation of linkability across different apps. LinkDroid is a client-side solution and compatible with the existing smartphone ecosystem. It helps end-users “sense” this emerging threat and provides them intuitive opt-out options.</p>
<p>【Keywords】:</p>
<h3 id="50. PowerSpy: Location Tracking Using Mobile Device Power Analysis.">50. PowerSpy: Location Tracking Using Mobile Device Power Analysis.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/michalevsky">Paper Link</a>】    【Pages】:785-800</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Michalevsky:Yan">Yan Michalevsky</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Schulman:Aaron">Aaron Schulman</a> ; <a href="http://dblp.uni-trier.de/pers/hd/v/Veerapandian:Gunaa_Arumugam">Gunaa Arumugam Veerapandian</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Boneh:Dan">Dan Boneh</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/Nakibly:Gabi">Gabi Nakibly</a></p>
<p>【Abstract】:
Modern mobile platforms like Android enable applications to read aggregate power usage on the phone. This information is considered harmless and reading it requires no user permission or notification. We show that by simply reading the phone’s aggregate power consumption over a period of a few minutes an application can learn information about the user’s location. Aggregate phone power consumption data is extremely noisy due to the multitude of components and applications that simultaneously consume power. Nevertheless, by using machine learning algorithms we are able to successfully infer the phone’s location. We discuss several ways in which this privacy leak can be remedied.</p>
<p>【Keywords】:</p>
<h2 id="ADDioS!    3">ADDioS!    3</h2>
<h3 id="51. In the Compression Hornet's Nest: A Security Study of Data Compression in Network Services.">51. In the Compression Hornet's Nest: A Security Study of Data Compression in Network Services.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/pellegrino">Paper Link</a>】    【Pages】:801-816</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/p/Pellegrino:Giancarlo">Giancarlo Pellegrino</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Balzarotti:Davide">Davide Balzarotti</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Winter:Stefan">Stefan Winter</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Suri:Neeraj">Neeraj Suri</a></p>
<p>【Abstract】:
In this paper, we investigate the current use of data compression in network services that are at the core of modern web-based applications. While compression reduces network traffic, if not properly implemented it may make an application vulnerable to DoS attacks. Despite the popularity of similar attacks in the past, such as zip bombs or XML bombs, current protocol specifications and design patterns indicate that developers are still mostly unaware of the proper way to handle compressed streams in protocols and web applications. In this paper, we show that denial of services due to improper handling of data compression is a persistent and widespread threat. In our experiments, we review three popular communication protocols and test 19 implementations against highly-compressed protocol messages. Based on the results of our analysis, we list 12 common pitfalls that we observed at the implementation, specification, and configuration levels. Additionally, we discuss a number of previously unknown resource exhaustion vulnerabilities that can be exploited to mount DoS attacks against popular network service implementations.</p>
<p>【Keywords】:</p>
<h3 id="52. Bohatei: Flexible and Elastic DDoS Defense.">52. Bohatei: Flexible and Elastic DDoS Defense.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/fayaz">Paper Link</a>】    【Pages】:817-832</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/f/Fayaz:Seyed_Kaveh">Seyed Kaveh Fayaz</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tobioka:Yoshiaki">Yoshiaki Tobioka</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Sekar:Vyas">Vyas Sekar</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bailey:Michael">Michael Bailey</a></p>
<p>【Abstract】:
DDoS defense today relies on expensive and proprietary hardware appliances deployed at fixed locations. This introduces key limitations with respect to flexibility (e.g., complex routing to get traffic to these “chokepoints”) and elasticity in handling changing attack patterns. We observe an opportunity to address these limitations using new networking paradigms such as softwaredefined networking (SDN) and network functions virtualization (NFV). Based on this observation, we design and implement Bohatei, a flexible and elastic DDoS defense system. In designing Bohatei, we address key challenges with respect to scalability, responsiveness, and adversary-resilience. We have implemented defenses for several DDoS attacks using Bohatei. Our evaluations show that Bohatei is scalable (handling 500 Gbps attacks), responsive (mitigating attacks within one minute), and resilient to dynamic adversaries.</p>
<p>【Keywords】:</p>
<h3 id="53. Boxed Out: Blocking Cellular Interconnect Bypass Fraud at the Network Edge.">53. Boxed Out: Blocking Cellular Interconnect Bypass Fraud at the Network Edge.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/reaves-boxed">Paper Link</a>】    【Pages】:833-848</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/r/Reaves:Bradley">Bradley Reaves</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shernan:Ethan">Ethan Shernan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bates:Adam_M=">Adam M. Bates</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Carter:Henry">Henry Carter</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Traynor:Patrick">Patrick Traynor</a></p>
<p>【Abstract】:
The high price of incoming international calls is a common method of subsidizing telephony infrastructure in the developing world. Accordingly, international telephone system interconnects are regulated to ensure call quality and accurate billing. High call tariffs create a strong incentive to evade such interconnects and deliver costly international calls illicitly. Specifically, adversaries use VoIP-GSM gateways informally known as “simboxes” to receive incoming calls over wired data connections and deliver them into a cellular voice network through a local call that appears to originate from a customer’s phone. This practice is not only extremely profitable for simboxers, but also dramatically degrades network experience for legitimate customers, violates telecommunications laws in many countries, and results in significant revenue loss. In this paper, we present a passive detection technique for combating simboxes at a cellular base station. Our system relies on the raw voice data received by the tower during a call to distinguish errors in GSM transmission from the distinct audio artifacts caused by delivering the call over a VoIP link. Our experiments demonstrate that this approach is highly effective, and can detect 87% of real simbox calls in only 30 seconds of audio with no false positives. Moreover, we demonstrate that evading our detection across multiple calls is only possible with a small probability. In so doing, we demonstrate that fraud that degrades network quality and costs telecommunications billions of dollars annually can easily be detected and counteracted in real time.</p>
<p>【Keywords】:</p>
<h2 id="Attacks: I Won't Let You Down    3">Attacks: I Won't Let You Down    3</h2>
<h3 id="54. GSMem: Data Exfiltration from Air-Gapped Computers over GSM Frequencies.">54. GSMem: Data Exfiltration from Air-Gapped Computers over GSM Frequencies.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/guri">Paper Link</a>】    【Pages】:849-864</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/g/Guri:Mordechai">Mordechai Guri</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kachlon:Assaf">Assaf Kachlon</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Hasson:Ofer">Ofer Hasson</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kedma:Gabi">Gabi Kedma</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Mirsky:Yisroel">Yisroel Mirsky</a> ; <a href="http://dblp.uni-trier.de/pers/hd/e/Elovici:Yuval">Yuval Elovici</a></p>
<p>【Abstract】:
Air-gapped networks are isolated, separated both logically and physically from public networks. Although the feasibility of invading such systems has been demonstrated in recent years, exfiltration of data from air-gapped networks is still a challenging task. In this paper we present GSMem, a malware that can exfiltrate data through an air-gap over cellular frequencies. Rogue software on an infected target computer modulates and transmits electromagnetic signals at cellular frequencies by invoking specific memory-related instructions and utilizing the multichannel memory architecture to amplify the transmission. Furthermore, we show that the transmitted signals can be received and demodulated by a rootkit placed in the baseband firmware of a nearby cellular phone. We present crucial design issues such as signal generation and reception, data modulation, and transmission detection. We implement a prototype of GSMem consisting of a transmitter and a receiver and evaluate its performance and limitations. Our current results demonstrate its efficacy and feasibility, achieving an effective transmission distance of 1-5.5 meters with a standard mobile phone. When using a dedicated, yet affordable hardware receiver, the effective distance reached over 30 meters. For more information, watch the video GSMem Breaking The Air-Gap on YouTube.</p>
<p>【Keywords】:</p>
<h3 id="55. Thermal Covert Channels on Multi-core Platforms.">55. Thermal Covert Channels on Multi-core Platforms.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/masti">Paper Link</a>】    【Pages】:865-880</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Masti:Ramya_Jayaram">Ramya Jayaram Masti</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Rai:Devendra">Devendra Rai</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Ranganathan:Aanjhan">Aanjhan Ranganathan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/M=uuml=ller:Christian">Christian Müller</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Thiele:Lothar">Lothar Thiele</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Capkun:Srdjan">Srdjan Capkun</a></p>
<p>【Abstract】:
Side channels remain a challenge to information flow control and security in modern computing platforms. Resource partitioning techniques that minimise the number of shared resources among processes are often used to address this challenge. In this work, we focus on multicore platforms and we demonstrate that even seemingly strong isolation techniques based on dedicated cores can be circumvented through the use of thermal channels. Specifically, we show that the processor core temperature can be used both as a side channel as well as a covert communication channel even when the system implements strong spatial and temporal partitioning. Our experiments on an Intel Xeon server platform demonstrate covert thermal channels that achieve up to 12.5 bps and weak thermal side channels that can detect processes executed on neighbouring cores. This work therefore shows a limitation in the isolation that can be achieved on existing multi-core systems.</p>
<p>【Keywords】:</p>
<h3 id="56. Rocking Drones with Intentional Sound Noise on Gyroscopic Sensors.">56. Rocking Drones with Intentional Sound Noise on Gyroscopic Sensors.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/son">Paper Link</a>】    【Pages】:881-896</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Son:Yunmok">Yunmok Son</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shin:Hocheol">Hocheol Shin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kim:Dongkwan">Dongkwan Kim</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Park:Young=Seok">Young-Seok Park</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/Noh:Juhwan">Juhwan Noh</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Choi:Kibum">Kibum Choi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Choi:Jungwoo">Jungwoo Choi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kim:Yongdae">Yongdae Kim</a></p>
<p>【Abstract】:
Sensing and actuation systems contain sensors to observe the environment and actuators to influence it. However, these sensors can be tricked by maliciously fabricated physical properties. In this paper, we investigated whether an adversary could incapacitate drones equipped with Micro-Electro-Mechanical Systems (MEMS) gyroscopes using intentional sound noise. While MEMS gyroscopes are known to have resonant frequencies that degrade their accuracy, it is not known whether this property can be exploited maliciously to disrupt the operation of drones. We first tested 15 kinds of MEMS gyroscopes against sound noise and discovered the resonant frequencies of seven MEMS gyroscopes by scanning the frequencies under 30 kHz using a consumer-grade speaker. The standard deviation of the resonant output from those gyroscopes was dozens of times larger than that of the normal output. After analyzing a target drone’s flight control system, we performed real-world experiments and a software simulation to verify the effect of the crafted gyroscope output. Our real-world experiments showed that in all 20 trials, one of two target drones equipped with vulnerable gyroscopes lost control and crashed shortly after we started our attack. A few interesting applications and countermeasures are discussed at the conclusion of this paper.</p>
<p>【Keywords】:</p>
<h2 id="How Do You Secure a Cloud and Pin It Down?    3">How Do You Secure a Cloud and Pin It Down?    3</h2>
<h3 id="57. Cache Template Attacks: Automating Attacks on Inclusive Last-Level Caches.">57. Cache Template Attacks: Automating Attacks on Inclusive Last-Level Caches.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/gruss">Paper Link</a>】    【Pages】:897-912</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/g/Gruss:Daniel">Daniel Gruss</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Spreitzer:Raphael">Raphael Spreitzer</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Mangard:Stefan">Stefan Mangard</a></p>
<p>【Abstract】:
Recent work on cache attacks has shown that CPU caches represent a powerful source of information leakage. However, existing attacks require manual identification of vulnerabilities, i.e., data accesses or instruction execution depending on secret information. In this paper, we present Cache Template Attacks. This generic attack technique allows us to profile and exploit cache-based information leakage of any program automatically, without prior knowledge of specific software versions or even specific system information. Cache Template Attacks can be executed online on a remote system without any prior offline computations or measurements. Cache Template Attacks consist of two phases. In the profiling phase, we determine dependencies between the processing of secret information, e.g., specific key inputs or private keys of cryptographic primitives, and specific cache accesses. In the exploitation phase, we derive the secret values based on observed cache accesses. We illustrate the power of the presented approach in several attacks, but also in a useful application for developers. Among the presented attacks is the application of Cache Template Attacks to infer keystrokes and—even more severe—the identification of specific keys on Linux and Windows user interfaces. More specifically, for lowercase only passwords, we can reduce the entropy per character from log2(26) = 4:7 to 1:4 bits on Linux systems. Furthermore, we perform an automated attack on the T-table- based AES implementation of OpenSSL that is as efficient as state-of-the-art manual cache attacks.</p>
<p>【Keywords】:</p>
<h3 id="58. A Placement Vulnerability Study in Multi-Tenant Public Clouds.">58. A Placement Vulnerability Study in Multi-Tenant Public Clouds.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/varadarajan">Paper Link</a>】    【Pages】:913-928</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/v/Varadarajan:Venkatanathan">Venkatanathan Varadarajan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Yinqian">Yinqian Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Ristenpart:Thomas">Thomas Ristenpart</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Swift:Michael_M=">Michael M. Swift</a></p>
<p>【Abstract】:
Public infrastructure-as-a-service clouds, such as Amazon EC2, Google Compute Engine (GCE) and Microsoft Azure allow clients to run virtual machines (VMs) on shared physical infrastructure. This practice of multi-tenancy brings economies of scale, but also introduces the risk of sharing a physical server with an arbitrary and potentially malicious VM. Past works have demonstrated how to place a VM alongside a target victim (co-location) in early-generation clouds and how to extract secret information via side-channels. Although there have been numerous works on side-channel attacks, there have been no studies on placement vulnerabilities in public clouds since the adoption of stronger isolation technologies such as Virtual Private Clouds (VPCs). We investigate this problem of placement vulnerabilities and quantitatively evaluate three popular public clouds for their susceptibility to co-location attacks. We find that adoption of new technologies (e.g., VPC) makes many prior attacks, such as cloud cartography, ineffective. We find new ways to reliably test for co-location across Amazon EC2, Google GCE, and Microsoft Azure. We also found ways to detect co-location with victim web servers in multi-tiered located behind a load balancer. We use our new co-residence tests and multiple customer accounts to launch VM instances under different strategies that seek to maximize the likelihood of co-residency. We find that it is much easier (10x higher success rate) and cheaper (up to $114 less) to achieve co-location in these three clouds when compared to a secure reference placement policy. Keywords: co-location detection, multi-tenancy, cloud security</p>
<p>【Keywords】:</p>
<h3 id="59. A Measurement Study on Co-residence Threat inside the Cloud.">59. A Measurement Study on Co-residence Threat inside the Cloud.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/xu">Paper Link</a>】    【Pages】:929-944</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/x/Xu:Zhang">Zhang Xu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Haining">Haining Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wu:Zhenyu">Zhenyu Wu</a></p>
<p>【Abstract】:
As the most basic cloud service model, Infrastructure as a Service (IaaS) has been widely used for serving the evergrowing computing demand due to the prevalence of the cloud. Using pools of hypervisors within the cloud, IaaS can support a large number of Virtual Machines (VMs) and scale services in a highly dynamic manner. However, it is well-known that the VMs in IaaS are vulnerable to co-residence threat, which can be easily exploited to launch different malicious attacks. In this measurement study, we investigate how IaaS evolves in VM placement, network management, and Virtual Private Cloud (VPC), as well as the impact upon co-residence. Specifically, through intensive measurement probing, we first profile the dynamic environment of cloud instances inside the cloud. Then using real experiments, we quantify the impacts of VM placement and network management upon co-residence. Moreover, we explore VPC, which is a defensive network-based service of Amazon EC2 for security enhancement, from the routing perspective. On one hand, our measurement shows that VPC is widely used and can indeed suppress co-residence threat. On the other hand, we demonstrate a new approach to achieving co-residence in VPC, indicating that co-residence threat still exists in the cloud.</p>
<p>【Keywords】:</p>
<h2 id="Knock Knock. Who's There? Icy. Icy Who? I See You Too    4">Knock Knock. Who's There? Icy. Icy Who? I See You Too    4</h2>
<h3 id="60. Towards Discovering and Understanding Task Hijacking in Android.">60. Towards Discovering and Understanding Task Hijacking in Android.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/ren-chuangang">Paper Link</a>】    【Pages】:945-959</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/r/Ren:Chuangang">Chuangang Ren</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Yulong">Yulong Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/x/Xue:Hui">Hui Xue</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wei:Tao">Tao Wei</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Liu_0005:Peng">Peng Liu</a></p>
<p>【Abstract】:
Android multitasking provides rich features to enhance user experience and offers great flexibility for app developers to promote app personalization. However, the security implication of Android multitasking remains under-investigated. With a systematic study of the complex tasks dynamics, we find design flaws of Android multitasking which make all recent versions of Android vulnerable to task hijacking attacks. We demonstrate proof-of-concept examples utilizing the task hijacking attack surface to implement UI spoofing, denialof- service and user monitoring attacks. Attackers may steal login credentials, implement ransomware and spy on user’s activities. We have collected and analyzed over 6.8 million apps from various Android markets. Our analysis shows that the task hijacking risk is prevalent. Since many apps depend on the current multitasking design, defeating task hijacking is not easy. We have notified the Android team about these issues and we discuss possible mitigation techniques in this paper.</p>
<p>【Keywords】:</p>
<h3 id="61. Cashtags: Protecting the Input and Display of Sensitive Data.">61. Cashtags: Protecting the Input and Display of Sensitive Data.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/mitchell">Paper Link</a>】    【Pages】:961-976</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Mitchell:Michael">Michael Mitchell</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang:An=I_Andy">An-I Andy Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Reiher:Peter_L=">Peter L. Reiher</a></p>
<p>【Abstract】:
Mobile computing is the new norm. As people feel increasingly comfortable computing in public places such as coffee shops and transportation hubs, the threat of exposing sensitive information increases. While solutions exist to guard the communication channels used by mobile devices, the visual channel remains largely open. Shoulder surfing is becoming a viable threat in a world where users are often surrounded by high-power cameras, and sensitive information can be extracted from images using only modest computing power. In response, we present Cashtags: a system to defend against attacks on mobile devices based on visual observations. The system allows users to safely access pieces of sensitive information in public by intercepting and replacing sensitive data elements with non-sensitive data elements before they are displayed on the screen. In addition, the system provides a means of computing with sensitive data in a non-observable way, while maintaining full functionality and legacy compatibility across applications.</p>
<p>【Keywords】:</p>
<h3 id="62. SUPOR: Precise and Scalable Sensitive User Input Detection for Android Apps.">62. SUPOR: Precise and Scalable Sensitive User Input Detection for Android Apps.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/huang">Paper Link</a>】    【Pages】:977-992</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/h/Huang:Jianjun">Jianjun Huang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Li:Zhichun">Zhichun Li</a> ; <a href="http://dblp.uni-trier.de/pers/hd/x/Xiao:Xusheng">Xusheng Xiao</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wu:Zhenyu">Zhenyu Wu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lu:Kangjie">Kangjie Lu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Xiangyu">Xiangyu Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Jiang:Guofei">Guofei Jiang</a></p>
<p>【Abstract】:
While smartphones and mobile apps have been an essential part of our lives, privacy is a serious concern. Previous mobile privacy related research efforts have largely focused on predefined known sources managed by smartphones. Sensitive user inputs through UI (User Interface), another information source that may contain a lot of sensitive information, have been mostly neglected. In this paper, we examine the possibility of scalably detecting sensitive user inputs from mobile apps. In particular, we design and implement SUPOR, a novel static analysis tool that automatically examines the UIs to identify sensitive user inputs containing critical user data, such as user credentials, finance, and medical data. SUPOR enables existing privacy analysis approaches to be applied on sensitive user inputs as well. To demonstrate the usefulness of SUPOR, we build a system that detects privacy disclosures of sensitive user inputs by combining SUPOR with off-the-shelf static taint analysis We apply the system to 16,000 popular Android apps, and conduct a measurement study on the privacy disclosures. SUPOR achieves an average precision of 97.3% and an average recall of 97.3% for sensitive user input identification. SUPOR finds 355 apps with privacy disclosures and the false positive rate is 8.7%. We discover interesting cases related to national ID, username/password, credit card and health information.</p>
<p>【Keywords】:</p>
<h3 id="63. UIPicker: User-Input Privacy Identification in Mobile Applications.">63. UIPicker: User-Input Privacy Identification in Mobile Applications.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/nan">Paper Link</a>】    【Pages】:993-1008</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/n/Nan:Yuhong">Yuhong Nan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yang:Min">Min Yang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yang:Zhemin">Zhemin Yang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhou:Shunfan">Shunfan Zhou</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Gu:Guofei">Guofei Gu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Xiaofeng">Xiaofeng Wang</a></p>
<p>【Abstract】:
Identifying sensitive user inputs is a prerequisite for privacy protection. When it comes to today’s program analysis systems, however, only those data that go through well-defined system APIs can be automatically labelled. In our research, we show that this conventional approach is far from adequate, as most sensitive inputs are actually entered by the user at an app’s runtime: in our research, we inspect 17, 425 top apps from Google Play, and find that 35.46% of them involve sensitive user inputs. Manually marking them involves a lot of effort, impeding a large-scale, automated analysis of apps for potential information leaks. To address this important issue, we present UIPicker, an adaptable framework for automatic identification of sensitive user inputs. UIPicker is designed to detect the semantic information within the application layout resources and program code, and further analyze it for the locations where security-critical information may show up. This approach can support a variety of existing security analysis on mobile apps. We further develop a runtime protection mechanism on top of the technique, which helps the user make informed decisions when her sensitive data is about to leave the device in an unexpected way. We evaluate our approach over 200 randomly selected popular apps on Google- Play. UIPicker is able to accurately label sensitive user inputs most of the time, with 93.6%precision and 90.1% recall.</p>
<p>【Keywords】:</p>
<h2 id="How Do You Solve a Problem Like M-al-ware?    4">How Do You Solve a Problem Like M-al-ware?    4</h2>
<h3 id="64. Cloudy with a Chance of Breach: Forecasting Cyber Security Incidents.">64. Cloudy with a Chance of Breach: Forecasting Cyber Security Incidents.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/liu">Paper Link</a>】    【Pages】:1009-1024</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Liu:Yang">Yang Liu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Sarabi:Armin">Armin Sarabi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Jing">Jing Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/Naghizadeh:Parinaz">Parinaz Naghizadeh</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Karir:Manish">Manish Karir</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bailey:Michael">Michael Bailey</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Liu:Mingyan">Mingyan Liu</a></p>
<p>【Abstract】:
In this study we characterize the extent to which cyber security incidents, such as those referenced by Verizon in its annual Data Breach Investigations Reports (DBIR), can be predicted based on externally observable properties of an organization’s network. We seek to proactively forecast an organization’s breaches and to do so without cooperation of the organization itself. To accomplish this goal, we collect 258 externally measurable features about an organization’s network from two main categories: mismanagement symptoms, such as misconfigured DNS or BGP within a network, and malicious activity time series, which include spam, phishing, and scanning activity sourced from these organizations. Using these features we train and test a Random Forest (RF) classifier against more than 1,000 incident reports taken from the VERIS community database, Hackmageddon, and theWeb Hacking Incidents Database that cover events from mid-2013 to the end of 2014. The resulting classifier is able to achieve a 90% True Positive (TP) rate, a 10% False Positive (FP) rate, and an overall 90% accuracy.</p>
<p>【Keywords】:</p>
<h3 id="65. WebWitness: Investigating, Categorizing, and Mitigating Malware Download Paths.">65. WebWitness: Investigating, Categorizing, and Mitigating Malware Download Paths.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/nelms">Paper Link</a>】    【Pages】:1025-1040</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/n/Nelms:Terry">Terry Nelms</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Perdisci:Roberto">Roberto Perdisci</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Antonakakis:Manos">Manos Antonakakis</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Ahamad:Mustaque">Mustaque Ahamad</a></p>
<p>【Abstract】:
Most modern malware download attacks occur via the browser, typically due to social engineering and driveby downloads. In this paper, we study the “origin” of malware download attacks experienced by real network users, with the objective of improving malware download defenses. Specifically, we study the web paths followed by users who eventually fall victim to different types of malware downloads. To this end, we propose a novel incident investigation system, named WebWitness. Our system targets two main goals: 1) automatically trace back and label the sequence of events (e.g., visited web pages) preceding malware downloads, to highlight how users reach attack pages on the web; and 2) leverage these automatically labeled in-the-wild malware download paths to better understand current attack trends, and to develop more effective defenses. We deployed WebWitness on a large academic network for a period of ten months, where we collected and categorized thousands of live malicious download paths. An analysis of this labeled data allowed us to design a new defense against drive-by downloads that rely on injecting malicious content into (hacked) legitimate web pages. For example, we show that by leveraging the incident investigation information output byWebWitness we can decrease the infection rate for this type of drive-by downloads by almost six times, on average, compared to existing URL blacklisting approaches.</p>
<p>【Keywords】:</p>
<h3 id="66. Vulnerability Disclosure in the Age of Social Media: Exploiting Twitter for Predicting Real-World Exploits.">66. Vulnerability Disclosure in the Age of Social Media: Exploiting Twitter for Predicting Real-World Exploits.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/sabottke">Paper Link</a>】    【Pages】:1041-1056</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Sabottke:Carl">Carl Sabottke</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Suciu:Octavian">Octavian Suciu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Dumitras:Tudor">Tudor Dumitras</a></p>
<p>【Abstract】:
In recent years, the number of software vulnerabilities discovered has grown significantly. This creates a need for prioritizing the response to new disclosures by assessing which vulnerabilities are likely to be exploited and by quickly ruling out the vulnerabilities that are not actually exploited in the real world. We conduct a quantitative and qualitative exploration of the vulnerability-related information disseminated on Twitter. We then describe the design of a Twitter-based exploit detector, and we introduce a threat model specific to our problem. In addition to response prioritization, our detection techniques have applications in risk modeling for cyber-insurance and they highlight the value of information provided by the victims of attacks.</p>
<p>【Keywords】:</p>
<h3 id="67. Needles in a Haystack: Mining Information from Public Dynamic Analysis Sandboxes for Malware Intelligence.">67. Needles in a Haystack: Mining Information from Public Dynamic Analysis Sandboxes for Malware Intelligence.</h3>
<p>【<a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/graziano">Paper Link</a>】    【Pages】:1057-1072</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/g/Graziano:Mariano">Mariano Graziano</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Canali:Davide">Davide Canali</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bilge:Leyla">Leyla Bilge</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lanzi:Andrea">Andrea Lanzi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Balzarotti:Davide">Davide Balzarotti</a></p>
<p>【Abstract】:
Malware sandboxes are automated dynamic analysis systems that execute programs in a controlled environment. Within the large volumes of samples submitted every day to these services, some submissions appear to be different from others, and show interesting characteristics. For example, we observed that malware samples involved in famous targeted attacks – like the Regin APT framework or the recently disclosed malwares from the Equation Group – were submitted to our sandbox months or even years before they were detected in the wild. In other cases, the malware developers themselves interact with public sandboxes to test their creations or to develop a new evasion technique. We refer to similar cases as malware developments. In this paper, we propose a novel methodology to automatically identify malware development cases from the samples submitted to a malware analysis sandbox. The results of our experiments show that, by combining dynamic and static analysis with features based on the file submission, it is possible to achieve a good accuracy in automatically identifying cases of malware development. Our goal is to raise awareness on this problem and on the importance of looking at these samples from an intelligence and threat prevention point of view.</p>
<p>【Keywords】:</p>
 

<div class="home">
<i title='主页' onclick="location.href='../index.html'"><i class="fa fa-home fa-lg"></i></i>
</div>

<div class="toc">
<i id="showLeftPush" title='目录'><i class="fa fa-list fa-lg"></i></i>
</div>

<!-- Classie - class helper functions by @desandro https://github.com/desandro/classie -->
<script>
	var menuLeft = document.getElementById( 'menu-s1' ),
		showLeftPush = document.getElementById( 'showLeftPush' ),
		body = document.body;

	showLeftPush.onclick = function() {
		classie.toggle( this, 'active' );
		classie.toggle( body, 'cbp-spmenu-push-toright' );
		classie.toggle( menuLeft, 'cbp-spmenu-open' );
		disableOther( 'showLeftPush' );
	};
</script>

<div class="go-top" >
<i title='顶部' onclick="window.scrollTo('0', '0')"><i class="fa fa-angle-double-up fa-2x"></i></i>
</div>

<div class="theme" >
<i title='主题' onclick="change_css()"><i class="fa fa-adjust fa-lg"></i></i>
</div>

<div id="footer">

  <p> <i class="fa fa-envelope-o fa-1x"></i>:&nbsp huntercmd@163.com &nbsp Published under<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh"> (CC) BY-NC-SA 3.0</a></p>

  <p>&copy; 2013 HunterCmd &nbsp <a href="https://github.com/huntercmd/ccf"><i class="fa fa-github fa-1x"></i>
  </p>
</div>

</body>
