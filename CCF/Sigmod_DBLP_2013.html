 
<head>
<meta name="HunterCmd" charset="utf-8">

<link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link id="light" rel="stylesheet" type="text/css" href="https://raw.githubusercontent.com/huntercmd/blog/master/config/css/light.css">
<link id="dark" rel="stylesheet" type="text/css" href="https://raw.githubusercontent.com/huntercmd/blog/master/config/css/dark.css" disabled/>
<script src="https://raw.githubusercontent.com/huntercmd/blog/master/config/css/skin.js"></script>
<script src="https://raw.githubusercontent.com/huntercmd/blog/master/config/css/classie.js"></script>

<!-- This is for Mathjax -->

<script type="text/x-mathjax-config">
	MathJax.Hub.Config({
		tex2jax: {
			inlineMath: [ ['$','$'], ["$","$"] ],
			displayMath: [ ['$$','$$'], ["$$","$$"] ],
			processEscapes: true
			},
		TeX: {equationNumbers: {autoNumber: ["AMS"], useLabelIds: true}},
		"HTML-CSS": {linebreaks: {automatic: true}},
		SVG: {linebreaks: {automatic: true}}
	});
</script>

<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<title>HunterCmd</title>
</head>

<body class="cbp-spmenu-push">

<nav class="cbp-spmenu cbp-spmenu-vertical cbp-spmenu-left" id="menu-s1" style="width: 320px;overflow: auto;
">

<h1>Table of contents</h1>
<ul>
<li><a href="#ACM SIGMOD Conference 2013:New York, NY, USA">ACM SIGMOD Conference 2013:New York, NY, USA</a><ul>
<li><a href="#Paper Num: 150 || Session Num: 40">Paper Num: 150 || Session Num: 40</a></li>
<li><a href="#Research session 1: data analytics    3">Research session 1: data analytics    3</a><ul>
<li><a href="#1. Cumulon: optimizing statistical data analysis in the cloud.">1. Cumulon: optimizing statistical data analysis in the cloud.</a></li>
<li><a href="#2. Shark: SQL and rich analytics at scale.">2. Shark: SQL and rich analytics at scale.</a></li>
<li><a href="#3. Parallel analytics as a service.">3. Parallel analytics as a service.</a></li>
</ul>
</li>
<li><a href="#Research session 2: XML    3">Research session 2: XML    3</a><ul>
<li><a href="#4. MESSIAH: missing element-conscious SLCA nodes search in XML data.">4. MESSIAH: missing element-conscious SLCA nodes search in XML data.</a></li>
<li><a href="#5. Indexing for subtree similarity-search using edit distance.">5. Indexing for subtree similarity-search using edit distance.</a></li>
<li><a href="#6. Discovering XSD keys from XML data.">6. Discovering XSD keys from XML data.</a></li>
</ul>
</li>
<li><a href="#Research session 3: transactions    3">Research session 3: transactions    3</a><ul>
<li><a href="#7. A scalable lock manager for multicores.">7. A scalable lock manager for multicores.</a></li>
<li><a href="#8. Controlled lock violation.">8. Controlled lock violation.</a></li>
<li><a href="#9. X-FTL: transactional FTL for SQLite databases.">9. X-FTL: transactional FTL for SQLite databases.</a></li>
</ul>
</li>
<li><a href="#Research session 4: data storage    3">Research session 4: data storage    3</a><ul>
<li><a href="#10. Optimal splitters for temporal and multi-version databases.">10. Optimal splitters for temporal and multi-version databases.</a></li>
<li><a href="#11. Building an efficient RDF store over a relational database.">11. Building an efficient RDF store over a relational database.</a></li>
<li><a href="#12. Automatic synthesis of out-of-core algorithms.">12. Automatic synthesis of out-of-core algorithms.</a></li>
</ul>
</li>
<li><a href="#Research session 5: schema matching and spatial databases I    3">Research session 5: schema matching and spatial databases I    3</a><ul>
<li><a href="#13. InfoGather+: semantic matching and annotation of numeric and time-varying attributes in web tables.">13. InfoGather+: semantic matching and annotation of numeric and time-varying attributes in web tables.</a></li>
<li><a href="#14. Value invention in data exchange.">14. Value invention in data exchange.</a></li>
<li><a href="#15. Indexing methods for moving object databases: games and other applications.">15. Indexing methods for moving object databases: games and other applications.</a></li>
</ul>
</li>
<li><a href="#Research session 6: graph connectivity    3">Research session 6: graph connectivity    3</a><ul>
<li><a href="#16. I/O efficient: computing SCCs in massive graphs.">16. I/O efficient: computing SCCs in massive graphs.</a></li>
<li><a href="#17. TF-Label: a topological-folding labeling scheme for reachability querying in a large graph.">17. TF-Label: a topological-folding labeling scheme for reachability querying in a large graph.</a></li>
<li><a href="#18. Efficiently computing k-edge connected components via graph decomposition.">18. Efficiently computing k-edge connected components via graph decomposition.</a></li>
</ul>
</li>
<li><a href="#Research session 7: crowdsourcing    3">Research session 7: crowdsourcing    3</a><ul>
<li><a href="#19. An online cost sensitive decision-making method in crowdsourcing systems.">19. An online cost sensitive decision-making method in crowdsourcing systems.</a></li>
<li><a href="#20. Leveraging transitive relations for crowdsourced joins.">20. Leveraging transitive relations for crowdsourced joins.</a></li>
<li><a href="#21. Crowd mining.">21. Crowd mining.</a></li>
</ul>
</li>
<li><a href="#Research session 8: social media    3">Research session 8: social media    3</a><ul>
<li><a href="#22. Efficient sentiment correlation for large-scale demographics.">22. Efficient sentiment correlation for large-scale demographics.</a></li>
<li><a href="#23. EBM: an entropy-based model to infer social strength from spatiotemporal data.">23. EBM: an entropy-based model to infer social strength from spatiotemporal data.</a></li>
<li><a href="#24. Online search of overlapping communities.">24. Online search of overlapping communities.</a></li>
</ul>
</li>
<li><a href="#Research session 9: systems, performance I    3">Research session 9: systems, performance I    3</a><ul>
<li><a href="#25. BitWeaving: fast scans for main memory data processing.">25. BitWeaving: fast scans for main memory data processing.</a></li>
<li><a href="#26. Performance and resource modeling in highly-concurrent OLTP workloads.">26. Performance and resource modeling in highly-concurrent OLTP workloads.</a></li>
<li><a href="#27. ODYS: an approach to building a massively-parallel search engine using a DB-IR tightly-integrated parallel DBMS for higher-level functionality.">27. ODYS: an approach to building a massively-parallel search engine using a DB-IR tightly-integrated parallel DBMS for higher-level functionality.</a></li>
</ul>
</li>
<li><a href="#Research session 10: graph management    3">Research session 10: graph management    3</a><ul>
<li><a href="#28. Massive graph triangulation.">28. Massive graph triangulation.</a></li>
<li><a href="#29. Turboiso: towards ultrafast and robust subgraph isomorphism search in large graph databases.">29. Turboiso: towards ultrafast and robust subgraph isomorphism search in large graph databases.</a></li>
<li><a href="#30. Fast exact shortest-path distance queries on large networks by pruned landmark labeling.">30. Fast exact shortest-path distance queries on large networks by pruned landmark labeling.</a></li>
</ul>
</li>
<li><a href="#Research session 11: text databases    3">Research session 11: text databases    3</a><ul>
<li><a href="#31. Improving regular-expression matching on strings using negative factors.">31. Improving regular-expression matching on strings using negative factors.</a></li>
<li><a href="#32. String similarity measures and joins with synonyms.">32. String similarity measures and joins with synonyms.</a></li>
<li><a href="#33. Efficient top-k algorithms for approximate substring matching.">33. Efficient top-k algorithms for approximate substring matching.</a></li>
</ul>
</li>
<li><a href="#Research session 12: systems, performance II    3">Research session 12: systems, performance II    3</a><ul>
<li><a href="#34. Towards high-throughput gibbs sampling at scale: a study across storage managers.">34. Towards high-throughput gibbs sampling at scale: a study across storage managers.</a></li>
<li><a href="#35. Latch-free data structures for DBMS: design, implementation, and evaluation.">35. Latch-free data structures for DBMS: design, implementation, and evaluation.</a></li>
<li><a href="#36. DBMS metrology: measuring query time.">36. DBMS metrology: measuring query time.</a></li>
</ul>
</li>
<li><a href="#Research session 13: information extraction    3">Research session 13: information extraction    3</a><ul>
<li><a href="#37. Quality and efficiency for kernel density estimates in large data.">37. Quality and efficiency for kernel density estimates in large data.</a></li>
<li><a href="#38. Efficient ad-hoc search for personalized PageRank.">38. Efficient ad-hoc search for personalized PageRank.</a></li>
<li><a href="#39. Provenance-based dictionary refinement in information extraction.">39. Provenance-based dictionary refinement in information extraction.</a></li>
</ul>
</li>
<li><a href="#Research session 14: query processing and optimization    3">Research session 14: query processing and optimization    3</a><ul>
<li><a href="#40. CS2: a new database synopsis for query estimation.">40. CS2: a new database synopsis for query estimation.</a></li>
<li><a href="#41. Branch-and-bound algorithm for reverse top-k queries.">41. Branch-and-bound algorithm for reverse top-k queries.</a></li>
<li><a href="#42. On the correct and complete enumeration of the core search space.">42. On the correct and complete enumeration of the core search space.</a></li>
</ul>
</li>
<li><a href="#Research session 15: cloud computing    3">Research session 15: cloud computing    3</a><ul>
<li><a href="#43. Trinity: a distributed graph engine on a memory cloud.">43. Trinity: a distributed graph engine on a memory cloud.</a></li>
<li><a href="#44. Characterizing tenant behavior for placement and crisis mitigation in multitenant DBMSs.">44. Characterizing tenant behavior for placement and crisis mitigation in multitenant DBMSs.</a></li>
<li><a href="#45. Minimal MapReduce algorithms.">45. Minimal MapReduce algorithms.</a></li>
</ul>
</li>
<li><a href="#Research session 16: data cleaning    3">Research session 16: data cleaning    3</a><ul>
<li><a href="#46. NADEEF: a commodity data cleaning system.">46. NADEEF: a commodity data cleaning system.</a></li>
<li><a href="#47. Don't be SCAREd: use SCalable Automatic REpairing with maximal likelihood and bounded changes.">47. Don't be SCAREd: use SCalable Automatic REpairing with maximal likelihood and bounded changes.</a></li>
<li><a href="#48. Determining the relative accuracy of attributes.">48. Determining the relative accuracy of attributes.</a></li>
</ul>
</li>
<li><a href="#Research session 17: complex event processing    3">Research session 17: complex event processing    3</a><ul>
<li><a href="#49. Photon: fault-tolerant and scalable joining of continuous data streams.">49. Photon: fault-tolerant and scalable joining of continuous data streams.</a></li>
<li><a href="#50. Utility-maximizing event stream suppression.">50. Utility-maximizing event stream suppression.</a></li>
<li><a href="#51. ε-Matching: event processing over noisy sequences in real time.">51. ε-Matching: event processing over noisy sequences in real time.</a></li>
</ul>
</li>
<li><a href="#Research session 18: systems, performance III    3">Research session 18: systems, performance III    3</a><ul>
<li><a href="#52. Toward practical query pricing with QueryMarket.">52. Toward practical query pricing with QueryMarket.</a></li>
<li><a href="#53. Generalized scale independence through incremental precomputation.">53. Generalized scale independence through incremental precomputation.</a></li>
<li><a href="#54. Simulation of database-valued markov chains using SimSQL.">54. Simulation of database-valued markov chains using SimSQL.</a></li>
</ul>
</li>
<li><a href="#Research session 19: privacy    3">Research session 19: privacy    3</a><ul>
<li><a href="#55. Recursive mechanism: towards node differential privacy and unrestricted joins.">55. Recursive mechanism: towards node differential privacy and unrestricted joins.</a></li>
<li><a href="#56. PrivGene: differentially private model fitting using genetic algorithms.">56. PrivGene: differentially private model fitting using genetic algorithms.</a></li>
<li><a href="#57. Information preservation in statistical privacy and bayesian estimation of unattributed histograms.">57. Information preservation in statistical privacy and bayesian estimation of unattributed histograms.</a></li>
</ul>
</li>
<li><a href="#Research session 20: spatial databases II    3">Research session 20: spatial databases II    3</a><ul>
<li><a href="#58. Collective spatial keyword queries: a distance owner-driven approach.">58. Collective spatial keyword queries: a distance owner-driven approach.</a></li>
<li><a href="#59. TOUCH: in-memory spatial join by hierarchical data-oriented partitioning.">59. TOUCH: in-memory spatial join by hierarchical data-oriented partitioning.</a></li>
<li><a href="#60. Finding time period-based most frequent path in big trajectory data.">60. Finding time period-based most frequent path in big trajectory data.</a></li>
</ul>
</li>
<li><a href="#Research session 21: data streams    3">Research session 21: data streams    3</a><ul>
<li><a href="#61. Integrating scale out and fault tolerance in stream processing using operator state management.">61. Integrating scale out and fault tolerance in stream processing using operator state management.</a></li>
<li><a href="#62. Quantiles over data streams: an experimental study.">62. Quantiles over data streams: an experimental study.</a></li>
<li><a href="#63. An efficient query indexing mechanism for filtering geo-textual data.">63. An efficient query indexing mechanism for filtering geo-textual data.</a></li>
</ul>
</li>
<li><a href="#Research session 22: distributed systems    3">Research session 22: distributed systems    3</a><ul>
<li><a href="#64. Bolt-on causal consistency.">64. Bolt-on causal consistency.</a></li>
<li><a href="#65. RTP: robust tenant placement for elastic in-memory database clusters.">65. RTP: robust tenant placement for elastic in-memory database clusters.</a></li>
<li><a href="#66. Inter-media hashing for large-scale retrieval from heterogeneous data sources.">66. Inter-media hashing for large-scale retrieval from heterogeneous data sources.</a></li>
</ul>
</li>
<li><a href="#Research session 23: data mining    3">Research session 23: data mining    3</a><ul>
<li><a href="#67. Mind the gap: large-scale frequent sequence mining.">67. Mind the gap: large-scale frequent sequence mining.</a></li>
<li><a href="#68. Reverse engineering complex join queries.">68. Reverse engineering complex join queries.</a></li>
<li><a href="#69. A direct mining approach to efficient constrained graph pattern discovery.">69. A direct mining approach to efficient constrained graph pattern discovery.</a></li>
</ul>
</li>
<li><a href="#Research session 24: road networks and trajectories    3">Research session 24: road networks and trajectories    3</a><ul>
<li><a href="#70. Calibrating trajectory data for similarity-based analysis.">70. Calibrating trajectory data for similarity-based analysis.</a></li>
<li><a href="#71. On optimal worst-case matching.">71. On optimal worst-case matching.</a></li>
<li><a href="#72. Shortest path and distance queries on road networks: towards bridging theory and practice.">72. Shortest path and distance queries on road networks: towards bridging theory and practice.</a></li>
</ul>
</li>
<li><a href="#Research session 25: security    2">Research session 25: security    2</a><ul>
<li><a href="#73. Fine-grained disclosure control for app ecosystems.">73. Fine-grained disclosure control for app ecosystems.</a></li>
<li><a href="#74. Lightweight authentication of linear algebraic queries on data streams.">74. Lightweight authentication of linear algebraic queries on data streams.</a></li>
</ul>
</li>
<li><a href="#Research session 26: indexing    2">Research session 26: indexing    2</a><ul>
<li><a href="#75. Column imprints: a secondary index structure.">75. Column imprints: a secondary index structure.</a></li>
<li><a href="#76. DeltaNI: an efficient labeling scheme for versioned hierarchical data.">76. DeltaNI: an efficient labeling scheme for versioned hierarchical data.</a></li>
</ul>
</li>
<li><a href="#Keynote addresses    2">Keynote addresses    2</a><ul>
<li><a href="#77. Big data in capital markets.">77. Big data in capital markets.</a></li>
<li><a href="#78. Managing database technology at enterprise scale.">78. Managing database technology at enterprise scale.</a></li>
</ul>
</li>
<li><a href="#Panel    1">Panel    1</a><ul>
<li><a href="#79. We are drowning in a sea of least publishable units (LPUs">79. We are drowning in a sea of least publishable units (LPUs).</a>.)</li>
</ul>
</li>
<li><a href="#Tutorials    6">Tutorials    6</a><ul>
<li><a href="#80. Rethinking eventual consistency.">80. Rethinking eventual consistency.</a></li>
<li><a href="#81. Workload management for big data analytics.">81. Workload management for big data analytics.</a></li>
<li><a href="#82. Knowledge harvesting in the big-data era.">82. Knowledge harvesting in the big-data era.</a></li>
<li><a href="#83. Machine learning for big data.">83. Machine learning for big data.</a></li>
<li><a href="#84. Data management perspectives on business process management: tutorial overview.">84. Data management perspectives on business process management: tutorial overview.</a></li>
<li><a href="#85. Data stream warehousing.">85. Data stream warehousing.</a></li>
</ul>
</li>
<li><a href="#Demo session 1: data intensive applications    10">Demo session 1: data intensive applications    10</a><ul>
<li><a href="#86. Data-driven neuroscience: enabling breakthroughs via innovative data management.">86. Data-driven neuroscience: enabling breakthroughs via innovative data management.</a></li>
<li><a href="#87. TsingNUS: a location-based service system towards live city.">87. TsingNUS: a location-based service system towards live city.</a></li>
<li><a href="#88. WOW: what the world of (data">88. WOW: what the world of (data) warehousing can learn from the World of Warcraft.</a> warehousing can learn from the World of Warcraft.)</li>
<li><a href="#89. Rule-based application development using Webdamlog.">89. Rule-based application development using Webdamlog.</a></li>
<li><a href="#90. Speeding up database applications with Pyxis.">90. Speeding up database applications with Pyxis.</a></li>
<li><a href="#91. Peckalytics: analyzing experts and interests on Twitter.">91. Peckalytics: analyzing experts and interests on Twitter.</a></li>
<li><a href="#92. Packing experiments for sharing and publication.">92. Packing experiments for sharing and publication.</a></li>
<li><a href="#93. CHIC: a combination-based recommendation system.">93. CHIC: a combination-based recommendation system.</a></li>
<li><a href="#94. Noah: a dynamic ridesharing system.">94. Noah: a dynamic ridesharing system.</a></li>
<li><a href="#95. A query answering system for data with evolution relationships.">95. A query answering system for data with evolution relationships.</a></li>
</ul>
</li>
<li><a href="#Demo session 2: data analysis and mining; privacy; security    11">Demo session 2: data analysis and mining; privacy; security    11</a><ul>
<li><a href="#96. GeoDeepDive: statistical inference using familiar data-processing languages.">96. GeoDeepDive: statistical inference using familiar data-processing languages.</a></li>
<li><a href="#97. Fact checking and analyzing the web.">97. Fact checking and analyzing the web.</a></li>
<li><a href="#98. Data mining algorithms as a service in the cloud exploiting relational database systems.">98. Data mining algorithms as a service in the cloud exploiting relational database systems.</a></li>
<li><a href="#99. SONDY: an open source platform for social dynamics mining and analysis.">99. SONDY: an open source platform for social dynamics mining and analysis.</a></li>
<li><a href="#100. Interactive data mining with 3D-parallel-coordinate-trees.">100. Interactive data mining with 3D-parallel-coordinate-trees.</a></li>
<li><a href="#101. Stat!: an interactive analytics environment for big data.">101. Stat!: an interactive analytics environment for big data.</a></li>
<li><a href="#102. PARAS: interactive parameter space exploration for association rule mining.">102. PARAS: interactive parameter space exploration for association rule mining.</a></li>
<li><a href="#103. STEM: a spatio-temporal miner for bursty activity.">103. STEM: a spatio-temporal miner for bursty activity.</a></li>
<li><a href="#104. The farm: where pig scripts are bred and raised.">104. The farm: where pig scripts are bred and raised.</a></li>
<li><a href="#105. LinkIT: privacy preserving record linkage and integration via transformations.">105. LinkIT: privacy preserving record linkage and integration via transformations.</a></li>
<li><a href="#106. Secure database-as-a-service with Cipherbase.">106. Secure database-as-a-service with Cipherbase.</a></li>
</ul>
</li>
<li><a href="#Demo session 3: database optimization; performance    11">Demo session 3: database optimization; performance    11</a><ul>
<li><a href="#107. DBalancer: distributed load balancing for NoSQL data-stores.">107. DBalancer: distributed load balancing for NoSQL data-stores.</a></li>
<li><a href="#108. COCCUS: self-configured cost-based query services in the cloud.">108. COCCUS: self-configured cost-based query services in the cloud.</a></li>
<li><a href="#109. Workload optimization using SharedDB.">109. Workload optimization using SharedDB.</a></li>
<li><a href="#110. SciQL: array data processing inside an RDBMS.">110. SciQL: array data processing inside an RDBMS.</a></li>
<li><a href="#111. Iterative parallel data processing with stratosphere: an inside look.">111. Iterative parallel data processing with stratosphere: an inside look.</a></li>
<li><a href="#112. CARTILAGE: adding flexibility to the Hadoop skeleton.">112. CARTILAGE: adding flexibility to the Hadoop skeleton.</a></li>
<li><a href="#113. Continuous outlier detection in data streams: an extensible framework and state-of-the-art algorithms.">113. Continuous outlier detection in data streams: an extensible framework and state-of-the-art algorithms.</a></li>
<li><a href="#114. FAST: differentially private real-time aggregate monitor with filtering and adaptive sampling.">114. FAST: differentially private real-time aggregate monitor with filtering and adaptive sampling.</a></li>
<li><a href="#115. Execution and optimization of continuous queries with cyclops.">115. Execution and optimization of continuous queries with cyclops.</a></li>
<li><a href="#116. Less watts, more performance: an intelligent storage engine for data appliances.">116. Less watts, more performance: an intelligent storage engine for data appliances.</a></li>
<li><a href="#117. A demonstration of SQLVM: performance isolation in multi-tenant relational database-as-a-service.">117. A demonstration of SQLVM: performance isolation in multi-tenant relational database-as-a-service.</a></li>
</ul>
</li>
<li><a href="#Demo session 4: graphs and networks; potpourris    11">Demo session 4: graphs and networks; potpourris    11</a><ul>
<li><a href="#118. SQUIN: a traversal based query execution system for the web of linked data.">118. SQUIN: a traversal based query execution system for the web of linked data.</a></li>
<li><a href="#119. GRDB: a system for declarative and interactive analysis of noisy information networks.">119. GRDB: a system for declarative and interactive analysis of noisy information networks.</a></li>
<li><a href="#120. HiNGE: enabling temporal network analytics at scale.">120. HiNGE: enabling temporal network analytics at scale.</a></li>
<li><a href="#121. Research-insight: providing insight on research by publication network analysis.">121. Research-insight: providing insight on research by publication network analysis.</a></li>
<li><a href="#122. QUBLE: blending visual subgraph query formulation with query processing on large networks.">122. QUBLE: blending visual subgraph query formulation with query processing on large networks.</a></li>
<li><a href="#123. StreamWorks: a system for dynamic graph search.">123. StreamWorks: a system for dynamic graph search.</a></li>
<li><a href="#124. Query processing on prefix trees live.">124. Query processing on prefix trees live.</a></li>
<li><a href="#125. xPAD: a platform for analytic data flows.">125. xPAD: a platform for analytic data flows.</a></li>
<li><a href="#126. PBS at work: advancing data management with consistency metrics.">126. PBS at work: advancing data management with consistency metrics.</a></li>
<li><a href="#127. The power of data use management in action.">127. The power of data use management in action.</a></li>
<li><a href="#128. CTrace: semantic comparison of multi-granularity process traces.">128. CTrace: semantic comparison of multi-granularity process traces.</a></li>
</ul>
</li>
<li><a href="#Industry session 1: big data I    3">Industry session 1: big data I    3</a><ul>
<li><a href="#129. The big data ecosystem at LinkedIn.">129. The big data ecosystem at LinkedIn.</a></li>
<li><a href="#130. On brewing fresh espresso: LinkedIn's distributed data serving platform.">130. On brewing fresh espresso: LinkedIn's distributed data serving platform.</a></li>
<li><a href="#131. Fast data in the era of big data: Twitter's real-time related query suggestion architecture.">131. Fast data in the era of big data: Twitter's real-time related query suggestion architecture.</a></li>
</ul>
</li>
<li><a href="#Industry session 2: enterprise data management    3">Industry session 2: enterprise data management    3</a><ul>
<li><a href="#132. Enhancements to SQL server column stores.">132. Enhancements to SQL server column stores.</a></li>
<li><a href="#133. Query containment in entity SQL.">133. Query containment in entity SQL.</a></li>
<li><a href="#134. Timeline index: a unified data structure for processing queries on temporal data in SAP HANA.">134. Timeline index: a unified data structure for processing queries on temporal data in SAP HANA.</a></li>
</ul>
</li>
<li><a href="#Industry session 3: big data II and web    3">Industry session 3: big data II and web    3</a><ul>
<li><a href="#135. LinkBench: a database benchmark based on the Facebook social graph.">135. LinkBench: a database benchmark based on the Facebook social graph.</a></li>
<li><a href="#136. BigBench: towards an industry standard benchmark for big data analytics.">136. BigBench: towards an industry standard benchmark for big data analytics.</a></li>
<li><a href="#137. Building, maintaining, and using knowledge bases: a report from the trenches.">137. Building, maintaining, and using knowledge bases: a report from the trenches.</a></li>
</ul>
</li>
<li><a href="#Industry session 4: systems and new hardware trends    3">Industry session 4: systems and new hardware trends    3</a><ul>
<li><a href="#138. Query processing on smart SSDs: opportunities and challenges.">138. Query processing on smart SSDs: opportunities and challenges.</a></li>
<li><a href="#139. Micro adaptivity in Vectorwise.">139. Micro adaptivity in Vectorwise.</a></li>
<li><a href="#140. Hekaton: SQL server's memory-optimized OLTP engine.">140. Hekaton: SQL server's memory-optimized OLTP engine.</a></li>
</ul>
</li>
<li><a href="#Industry session 5: big data III and more    3">Industry session 5: big data III and more    3</a><ul>
<li><a href="#141. Split query processing in polybase.">141. Split query processing in polybase.</a></li>
<li><a href="#142. Petabyte scale databases and storage systems at Facebook.">142. Petabyte scale databases and storage systems at Facebook.</a></li>
<li><a href="#143. Incremental mapping compilation in an object-to-relational mapping system.">143. Incremental mapping compilation in an object-to-relational mapping system.</a></li>
</ul>
</li>
<li><a href="#Undergraduate research    6">Undergraduate research    6</a><ul>
<li><a href="#144. FriendRouter: real-time path finder in social networks.">144. FriendRouter: real-time path finder in social networks.</a></li>
<li><a href="#145. Adaptive log compression for massive log data.">145. Adaptive log compression for massive log data.</a></li>
<li><a href="#146. BUZZARD: a NUMA-aware in-memory indexing system.">146. BUZZARD: a NUMA-aware in-memory indexing system.</a></li>
<li><a href="#147. Resa: realtime elastic streaming analytics in the cloud.">147. Resa: realtime elastic streaming analytics in the cloud.</a></li>
<li><a href="#148. Natural language question answering over RDF data.">148. Natural language question answering over RDF data.</a></li>
<li><a href="#149. Mobile interaction and query optimizationin a protein-ligand data analysis system.">149. Mobile interaction and query optimizationin a protein-ligand data analysis system.</a></li>
</ul>
</li>
<li><a href="#New researcher symposium    1">New researcher symposium    1</a><ul>
<li><a href="#150. SIGMOD 2013 new researcher symposium.">150. SIGMOD 2013 new researcher symposium.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav><h1 id="ACM SIGMOD Conference 2013:New York, NY, USA">ACM SIGMOD Conference 2013:New York, NY, USA</h1>
<p><a href="http://dl.acm.org/citation.cfm?id=2463676">Proceedings of the ACM SIGMOD International Conference on Management of Data, SIGMOD 2013, New York, NY, USA, June 22-27, 2013.</a> ACM
【<a href="http://dblp.uni-trier.de/db/conf/sigmod/sigmod2013.html">DBLP Link</a>】</p>
<h2 id="Paper Num: 150 || Session Num: 40">Paper Num: 150 || Session Num: 40</h2>
<h2 id="Research session 1: data analytics    3">Research session 1: data analytics    3</h2>
<h3 id="1. Cumulon: optimizing statistical data analysis in the cloud.">1. Cumulon: optimizing statistical data analysis in the cloud.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465273">Paper Link</a>】    【Pages】:1-12</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/h/Huang:Botong">Botong Huang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Babu:Shivnath">Shivnath Babu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yang_0001:Jun">Jun Yang</a></p>
<p>【Abstract】:
We present Cumulon, a system designed to help users rapidly develop and intelligently deploy matrix-based big-data analysis programs in the cloud. Cumulon features a flexible execution model and new operators especially suited for such workloads. We show how to implement Cumulon on top of Hadoop/HDFS while avoiding limitations of MapReduce, and demonstrate Cumulon's performance advantages over existing Hadoop-based systems for statistical data analysis. To support intelligent deployment in the cloud according to time/budget constraints, Cumulon goes beyond database-style optimization to make choices automatically on not only physical operators and their parameters, but also hardware provisioning and configuration settings. We apply a suite of benchmarking, simulation, modeling, and search techniques to support effective cost-based optimization over this rich space of deployment plans.</p>
<p>【Keywords】:
cloud; data parallelism; linear algebra; statistical computing</p>
<h3 id="2. Shark: SQL and rich analytics at scale.">2. Shark: SQL and rich analytics at scale.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465288">Paper Link</a>】    【Pages】:13-24</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/x/Xin:Reynold_S=">Reynold S. Xin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Rosen:Josh">Josh Rosen</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zaharia:Matei">Matei Zaharia</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Franklin:Michael_J=">Michael J. Franklin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shenker:Scott">Scott Shenker</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Stoica:Ion">Ion Stoica</a></p>
<p>【Abstract】:
Shark is a new data analysis system that marries query processing with complex analytics on large clusters. It leverages a novel distributed memory abstraction to provide a unified engine that can run SQL queries and sophisticated analytics functions (e.g. iterative machine learning) at scale, and efficiently recovers from failures mid-query. This allows Shark to run SQL queries up to 100X faster than Apache Hive, and machine learning programs more than 100X faster than Hadoop. Unlike previous systems, Shark shows that it is possible to achieve these speedups while retaining a MapReduce-like execution engine, and the fine-grained fault tolerance properties that such engine provides. It extends such an engine in several ways, including column-oriented in-memory storage and dynamic mid-query replanning, to effectively execute SQL. The result is a system that matches the speedups reported for MPP analytic databases over MapReduce, while offering fault tolerance properties and complex analytics capabilities that they lack.</p>
<p>【Keywords】:
data warehouse; databases; hadoop; machine learning; shark; spark</p>
<h3 id="3. Parallel analytics as a service.">3. Parallel analytics as a service.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463714">Paper Link</a>】    【Pages】:25-36</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/w/Wong:Petrie">Petrie Wong</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/He:Zhian">Zhian He</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lo:Eric">Eric Lo</a></p>
<p>【Abstract】:
Recently, massively parallel processing relational database systems (MPPDBs) have gained much momentum in the big data analytic market. With the advent of hosted cloud computing, we envision that the offering of MPPDB-as-a-Service (MPPDBaaS) will become attractive for companies having analytical tasks on only hundreds gigabytes to some ten terabytes of data because they can enjoy high-end parallel analytics at a cheap cost. This paper presents Thrifty, a prototype implementation of MPPDB-as-a-service. The major research issue is how to achieve a lower total cost of ownership by consolidating thousands of MPPDB tenants on to a shared hardware infrastructure, with a performance SLA that guarantees the tenants can obtain the query results as if they are executing their queries on dedicated machines. Thrifty achieves the goal by using a tenant-driven design that includes (1) a cluster design that carefully arranges the nodes in the cluster into groups and creates an MPPDB for each group of nodes, (2) a tenant placement that assigns each tenant to several MPPDBs (for high availability service through replication), and (3) a query routing algorithm that routes a tenant's query to the proper MPPDB at run-time. Experiments show that in a MPPDBaaS with 5000 tenants, where each tenant requests 2 to 32 nodes MPPDB to query against 200GB to 3.2TB of data, Thrifty can serve all the tenants with a 99.9% performance SLA guarantee and a high availability replication factor of 3, using only 18.7% of the nodes requested by the tenants.</p>
<p>【Keywords】:
cloud databases; consolidation; database-as-a-service; multi-tenant databases; parallel databases</p>
<h2 id="Research session 2: XML    3">Research session 2: XML    3</h2>
<h3 id="4. MESSIAH: missing element-conscious SLCA nodes search in XML data.">4. MESSIAH: missing element-conscious SLCA nodes search in XML data.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463699">Paper Link</a>】    【Pages】:37-48</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/t/Truong:Ba_Quan">Ba Quan Truong</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bhowmick:Sourav_S=">Sourav S. Bhowmick</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Dyreson:Curtis_E=">Curtis E. Dyreson</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Sun:Aixin">Aixin Sun</a></p>
<p>【Abstract】:
Keyword search for smallest lowest common ancestors (SLCAs) in XML data has been widely accepted as a meaningful way to identify matching nodes where their subtrees contain an input set of keywords. Although SLCA and its variants (e.g.,MLCA) perform admirably in identifying matching nodes, surprisingly, they perform poorly for searches on irregular schemas that have missing elements, that is, (sub)elements that are optional, or appear in some instances of an element type but not all (e.g., a "population" subelement in a "city" element might be optional, appearing when the population is known and absent when the population is unknown). In this paper, we generalize the SLCA search paradigm to support queries involving missing elements. Specifically, we propose a novel property called optionality resilience that specifies the desired behaviors of an XML keyword search (XKS) approach for queries involving missing elements. We present two variants of a novel algorithm called MESSIAH (Missing Element-conSciouS hIgh-quality SLCA searcH), which are optionality resilient to irregular documents. MESSIAH logically transforms an XML document to a minimal full document where all missing elements are represented as empty elements, i.e., the irregular schema is made "regular", and then employs efficient strategies to identify partial and complete full SLCA nodes (SLCA nodes in the full document) from it. Specifically, it generates the same SLCA nodes as any state-of-the-art approach when the query does not involve missing elements but avoids irrelevant results when missing elements are involved. Our experimental study demonstrates the ability of MESSIAH to produce superior quality search results.</p>
<p>【Keywords】:
full slca; missing elements; optionality resilience; xml keyword search</p>
<h3 id="5. Indexing for subtree similarity-search using edit distance.">5. Indexing for subtree similarity-search using edit distance.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463716">Paper Link</a>】    【Pages】:49-60</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/c/Cohen:Sara">Sara Cohen</a></p>
<p>【Abstract】:
Given a tree Q and a large set of trees T = {T1,...,Tn}, the subtree similarity-search problem is that of finding the subtrees of trees among T that are most similar to Q, using the tree edit distance metric. Determining similarity using tree edit distance has been proven useful in a variety of application areas. While subtree similarity-search has been studied in the past, solutions required traversal of all of T, which poses a severe bottleneck in processing time, as T grows larger. This paper proposes the first index structure for subtree similarity-search, provided that the unit cost function is used. Extensive experimentation and comparison to previous work shows the huge improvement gained when using the proposed index structure and processing algorithm.</p>
<p>【Keywords】:
edit distance; indexing</p>
<h3 id="6. Discovering XSD keys from XML data.">6. Discovering XSD keys from XML data.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463705">Paper Link</a>】    【Pages】:61-72</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Arenas:Marcelo">Marcelo Arenas</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Daenen:Jonny">Jonny Daenen</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/Neven:Frank">Frank Neven</a> ; <a href="http://dblp.uni-trier.de/pers/hd/u/Ugarte:Mart=iacute=n">Martín Ugarte</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bussche:Jan_Van_den">Jan Van den Bussche</a> ; <a href="http://dblp.uni-trier.de/pers/hd/v/Vansummeren:Stijn">Stijn Vansummeren</a></p>
<p>【Abstract】:
A great deal of research into the learning of schemas from XML data has been conducted in recent years to enable the automatic discovery of XML Schemas from XML documents when no schema, or only a low-quality one is available. Unfortunately, and in strong contrast to, for instance, the relational model, the automatic discovery of even the simplest of XML constraints, namely XML keys, has been left largely unexplored in this context. A major obstacle here is the unavailability of a theory on reasoning about XML keys in the presence of XML schemas, which is needed to validate the quality of candidate keys. The present paper embarks on a fundamental study of such a theory and classifies the complexity of several crucial properties concerning XML keys in the presence of an XSD, like, for instance, testing for consistency, boundedness, satisfiability, universality, and equivalence. Of independent interest, novel results are obtained related to cardinality estimation of XPath result sets. A mining algorithm is then developed within the framework of levelwise search. The algorithm leverages known discovery algorithms for functional dependencies in the relational model, but incorporates the above mentioned properties to assess and refine the quality of derived keys. An experimental study on an extensive body of real world XML data evaluating the effectiveness of the proposed algorithm is provided.</p>
<p>【Keywords】:
key; mining; xml</p>
<h2 id="Research session 3: transactions    3">Research session 3: transactions    3</h2>
<h3 id="7. A scalable lock manager for multicores.">7. A scalable lock manager for multicores.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465271">Paper Link</a>】    【Pages】:73-84</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/j/Jung:Hyungsoo">Hyungsoo Jung</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Han:Hyuck">Hyuck Han</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Fekete:Alan_David">Alan David Fekete</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Heiser:Gernot">Gernot Heiser</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yeom:Heon_Young">Heon Young Yeom</a></p>
<p>【Abstract】:
Modern implementations of DBMS software are intended to take advantage of high core counts that are becoming common in high-end servers. However, we have observed that several database platforms, including MySQL, Shore-MT, and a commercial system, exhibit throughput collapse as load increases, even for a workload with little or no logical contention for locks. Our analysis of MySQL identifies latch contention within the lock manager as the bottleneck responsible for this collapse. We design a lock manager with reduced latching, implement it in MySQL, and show that it avoids the collapse and generally improves performance. Our efficient implementation of a lock manager is enabled by a staged allocation and de-allocation of locks. Locks are pre-allocated in bulk, so that the lock manager only has to perform simple list-manipulation operations during the acquire and release phases of a transaction. De-allocation of the lock data-structures is also performed in bulk, which enables the use of fast implementations of lock acquisition and release, as well as concurrent deadlock checking.</p>
<p>【Keywords】:
concurrent programming; multicores; scalable lock manager</p>
<h3 id="8. Controlled lock violation.">8. Controlled lock violation.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465325">Paper Link</a>】    【Pages】:85-96</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/g/Graefe:Goetz">Goetz Graefe</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lillibridge:Mark">Mark Lillibridge</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kuno:Harumi_A=">Harumi A. Kuno</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tucek:Joseph">Joseph Tucek</a> ; <a href="http://dblp.uni-trier.de/pers/hd/v/Veitch:Alistair_C=">Alistair C. Veitch</a></p>
<p>【Abstract】:
In databases with a large buffer pool, a transaction may run in less time than it takes to log the transaction's commit record on stable storage. Such cases motivate a technique called early lock release: immediately after appending its commit record to the log buffer in memory, a transaction may release its locks. Thus, it cuts overall lock duration to a fraction and reduces lock contention accordingly. Early lock release also has its problems. The initial mention of early lock release was incomplete, the first detailed description and implementation was incorrect with respect to read-only transactions, and the most recent design initially had errors and still does not cover unusual lock modes such as "increment" locks. Thus, we set out to achieve the same goals as early lock release but with a different, simpler, and more robust approach. The resulting technique, controlled lock violation, requires no new theory, applies to any lock mode, promises less implementation effort and slightly less run-time effort, and also optimizes distributed transactions, e.g., in systems that rely on multiple replicas for high availability and high reliability. In essence, controlled lock violation retains locks until the transaction is durable but permits other transactions to violate its locks while flushing its commit log record to stable storage.</p>
<p>【Keywords】:
concurrency; dbms; locking; transaction processing</p>
<h3 id="9. X-FTL: transactional FTL for SQLite databases.">9. X-FTL: transactional FTL for SQLite databases.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465326">Paper Link</a>】    【Pages】:97-108</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/k/Kang:Woon=Hak">Woon-Hak Kang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lee:Sang=Won">Sang-Won Lee</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Moon:Bongki">Bongki Moon</a> ; <a href="http://dblp.uni-trier.de/pers/hd/o/Oh:Gi=Hwan">Gi-Hwan Oh</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Min:Changwoo">Changwoo Min</a></p>
<p>【Abstract】:
In the era of smartphones and mobile computing, many popular applications such as Facebook, twitter, Gmail, and even Angry birds game manage their data using SQLite. This is mainly due to the development productivity and solid transactional support. For transactional atomicity, however, SQLite relies on less sophisticated but costlier page-oriented journaling mechanisms. Hence, this is often cited as the main cause of tardy responses in mobile applications. Flash memory does not allow data to be updated in place, and the copy-on-write strategy is adopted by most flash storage devices. In this paper, we propose X-FTL, a transactional flash translation layer(FTL) for SQLite databases. By offloading the burden of guaranteeing the transactional atomicity from a host system to flash storage and by taking advantage of the copy-on-write strategy used in modern FTLs, X-FTL drastically improves the transactional throughput almost for free without resorting to costly journaling schemes. We have implemented X-FTL on an SSD development board called OpenSSD, and modified SQLite and ext4 file system minimally to make them compatible with the extended abstractions provided by X-FTL. We demonstrate the effectiveness of X-FTL using real and synthetic SQLite workloads for smartphone applications, TPC-C benchmark for OLTP databases, and FIO benchmark for file systems.</p>
<p>【Keywords】:
copy-on-write; flash storage devices; flash translation layer; sqlite; transactional atomicity</p>
<h2 id="Research session 4: data storage    3">Research session 4: data storage    3</h2>
<h3 id="10. Optimal splitters for temporal and multi-version databases.">10. Optimal splitters for temporal and multi-version databases.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465310">Paper Link</a>】    【Pages】:109-120</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Le:Wangchao">Wangchao Le</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Li:Feifei">Feifei Li</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tao:Yufei">Yufei Tao</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Christensen:Robert">Robert Christensen</a></p>
<p>【Abstract】:
Temporal and multi-version databases are ideal candidates for a distributed store, which offers large storage space, and parallel and distributed processing power from a cluster of (commodity) machines. A key challenge is to achieve a good load balancing algorithm for storage and processing of these data, which is done by partitioning the database. We introduce the concept of optimal splitters for temporal and multi-version databases, which induce a partition of the input data set, and guarantee that the size of the maximum bucket be minimized among all possible configurations, given a budget for the desired number of buckets. We design efficient methods for memory- and disk resident data respectively, and show that they significantly outperform competing baseline methods both theoretically and empirically on large real data sets.</p>
<p>【Keywords】:
multi-version databases; optimal splitters; temporal data</p>
<h3 id="11. Building an efficient RDF store over a relational database.">11. Building an efficient RDF store over a relational database.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463718">Paper Link</a>】    【Pages】:121-132</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Bornea:Mihaela_A=">Mihaela A. Bornea</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Dolby:Julian">Julian Dolby</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kementsietsidis:Anastasios">Anastasios Kementsietsidis</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Srinivas:Kavitha">Kavitha Srinivas</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Dantressangle:Patrick">Patrick Dantressangle</a> ; <a href="http://dblp.uni-trier.de/pers/hd/u/Udrea:Octavian">Octavian Udrea</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bhattacharjee:Bishwaranjan">Bishwaranjan Bhattacharjee</a></p>
<p>【Abstract】:
Efficient storage and querying of RDF data is of increasing importance, due to the increased popularity and widespread acceptance of RDF on the web and in the enterprise. In this paper, we describe a novel storage and query mechanism for RDF which works on top of existing relational representations. Reliance on relational representations of RDF means that one can take advantage of 35+ years of research on efficient storage and querying, industrial-strength transaction support, locking, security, etc. However, there are significant challenges in storing RDF in relational, which include data sparsity and schema variability. We describe novel mechanisms to shred RDF into relational, and novel query translation techniques to maximize the advantages of this shredded representation. We show that these mechanisms result in consistently good performance across multiple RDF benchmarks, even when compared with current state-of-the-art stores. This work provides the basis for RDF support in DB2 v.10.1.</p>
<p>【Keywords】:
efficient storage; query optimization; rdf; sparql</p>
<h3 id="12. Automatic synthesis of out-of-core algorithms.">12. Automatic synthesis of out-of-core algorithms.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465334">Paper Link</a>】    【Pages】:133-144</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/k/Klonatos:Yannis">Yannis Klonatos</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/N=ouml=tzli:Andres">Andres Nötzli</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Spielmann:Andrej">Andrej Spielmann</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Koch_0001:Christoph">Christoph Koch</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kuncak:Viktor">Viktor Kuncak</a></p>
<p>【Abstract】:
We present a system for the automatic synthesis of efficient algorithms specialized for a particular memory hierarchy and a set of storage devices. The developer provides two independent inputs: 1) an algorithm that ignores memory hierarchy and external storage aspects; and 2) a description of the target memory hierarchy, including its topology and parameters. Our system is able to automatically synthesize memory-hierarchy and storage-device-aware algorithms out of those specifications, for tasks such as joins and sorting. The framework is extensible and allows developers to quickly synthesize custom out-of-core algorithms as new storage technologies become available.</p>
<p>【Keywords】:
memory hierarchies; out-of-core algorithms; synthesis</p>
<h2 id="Research session 5: schema matching and spatial databases I    3">Research session 5: schema matching and spatial databases I    3</h2>
<h3 id="13. InfoGather+: semantic matching and annotation of numeric and time-varying attributes in web tables.">13. InfoGather+: semantic matching and annotation of numeric and time-varying attributes in web tables.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465276">Paper Link</a>】    【Pages】:145-156</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Meihui">Meihui Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Chakrabarti:Kaushik">Kaushik Chakrabarti</a></p>
<p>【Abstract】:
Users often need to gather information about "entities" of interest. Recent efforts try to automate this task by leveraging the vast corpus of HTML tables; this is referred to as "entity augmentation". The accuracy of entity augmentation critically depends on semantic relationships between web tables as well as semantic labels of those tables. Current techniques work well for string-valued and static attributes but perform poorly for numeric and time-varying attributes. In this paper, we first build a semantic graph that (i) labels columns with unit, scale and timestamp information and (ii) computes semantic matches between columns even when the same numeric attribute is expressed in different units or scales. Second, we develop a novel entity augmentation API suited for numeric and time-varying attributes that leverages the semantic graph. Building the graph is challenging as such label information is often missing from the column headers. Our key insight is to leverage the wealth of tables on the web and infer label information from semantically matching columns of other web tables; this complements "local" extraction from column headers. However, this creates an interdependence between labels and semantic matches; we address this challenge by representing the task as a probabilistic graphical model that jointly discovers labels and semantic matches over all columns. Our experiments on real-life datasets show that (i) our semantic graph contains higher quality labels and semantic matches and (ii) entity augmentation based on the above graph has significantly higher precision and recall compared with the state-of-the-art.</p>
<p>【Keywords】:
semantic matching; web table</p>
<h3 id="14. Value invention in data exchange.">14. Value invention in data exchange.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465311">Paper Link</a>】    【Pages】:157-168</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Arocena:Patricia_C=">Patricia C. Arocena</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Glavic:Boris">Boris Glavic</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Miller:Ren=eacute=e_J=">Renée J. Miller</a></p>
<p>【Abstract】:
The creation of values to represent incomplete information, often referred to as value invention, is central in data exchange. Within schema mappings, Skolem functions have long been used for value invention as they permit a precise representation of missing information. Recent work on a powerful mapping language called second-order tuple generating dependencies (SO tgds), has drawn attention to the fact that the use of arbitrary Skolem functions can have negative computational and programmatic properties in data exchange. In this paper, we present two techniques for understanding when the Skolem functions needed to represent the correct semantics of incomplete information are computationally well-behaved. Specifically, we consider when the Skolem functions in second-order (SO) mappings have a first-order (FO) semantics and are therefore programmatically and computationally more desirable for use in practice. Our first technique, linearization, significantly extends the Nash, Bernstein and Melnik unskolemization algorithm, by understanding when the sets of arguments of the Skolem functions in a mapping are related by set inclusion. We show that such a linear relationship leads to mappings that have FO semantics and are expressible in popular mapping languages including source-to-target tgds and nested tgds. Our second technique uses source semantics, specifically functional dependencies (including keys), to transform SO mappings into equivalent FO mappings. We show that our algorithms are applicable to a strictly larger class of mappings than previous approaches, but more importantly we present an extensive experimental evaluation that quantifies this difference (about 78% improvement) over an extensive schema mapping benchmark and illustrates the applicability of our results on real mappings.</p>
<p>【Keywords】:
data exchange; linearization; schema mappings; skolemization; unskolemization; value invention</p>
<h3 id="15. Indexing methods for moving object databases: games and other applications.">15. Indexing methods for moving object databases: games and other applications.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465332">Paper Link</a>】    【Pages】:169-180</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Samet:Hanan">Hanan Samet</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Sankaranarayanan:Jagan">Jagan Sankaranarayanan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Auerbach:Michael">Michael Auerbach</a></p>
<p>【Abstract】:
Moving object databases arise in numerous applications such as traffic monitoring, crowd tracking, and games. They all require keeping track of objects that move and thus the database of objects must be constantly updated. The cover fieldtree (more commonly known as the loose quadtree and the loose octree, depending on the dimension of the underlying space) is designed to overcome the drawback of spatial data structures that associate objects with their minimum enclosing quadtree (octree) cells which is that the size of these cells depends more on the position of the objects and less on their size. In fact, the size of these cells may be as large as the entire space from which the objects are drawn. The loose quadtree (octree) overcomes this drawback by expanding the size of the space that is spanned by each quadtree (octree) cell c of width w by a cell expansion factor p (p&gt;0) so that the expanded cell is of width (1+p)*w and an object is associated with its minimum enclosing expanded quadtree (octree) cell. It is shown that for an object o with minimum bounding hypercube box b of radius r (i.e., half the length of a side of the hypercube), the maximum possible width w of the minimum enclosing expanded quadtree cell c is just a function of r and p, and is independent of the position of o. Normalizing w via division by 2r enables calculating the range of possible expanded quadtree cell sizes as a function of p. For p &gt;= 0.5 the range consists of just two values and usually just one value for p &gt;= 1. This makes updating very simple and fast as for p &gt;= 0.5, there are at most two possible new cells associated with the moved object and thus the update can be done in O(1) time. Experiments with random data showed that the update time to support motion in such an environment is minimized when p is infinitesimally less than 1, with as much as a one order of magnitude increase in the number of updates that can be handled vis-a-vis the p=0 case in a given unit of time. Similar results for updates were obtained for an N-body simulation where improved query performance and scalability were also observed. Finally, in order amplify the paper, a video tiled "Crates and Barrels" was produced which is an N-body simulation of 14,000 objects. The video is available from the following URL: <a href="http://www.youtube.com/watch?v=Sokq3FRGc0s">http://www.youtube.com/watch?v=Sokq3FRGc0s</a>. An applet to illustrate the behavior of the loose quadtree was developed and is available from <a href="http://donar.umiacs.umd">http://donar.umiacs.umd</a>. edu/quadtree/rectangles/loosequad.html.</p>
<p>【Keywords】:
cover fieldtree; game databases; game programming; loose octree; loose quadtree; moving objects; spatial data structures; spatial databases; spatial indexing</p>
<h2 id="Research session 6: graph connectivity    3">Research session 6: graph connectivity    3</h2>
<h3 id="16. I/O efficient: computing SCCs in massive graphs.">16. I/O efficient: computing SCCs in massive graphs.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463703">Paper Link</a>】    【Pages】:181-192</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Zhiwei">Zhiwei Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yu:Jeffrey_Xu">Jeffrey Xu Yu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/q/Qin:Lu">Lu Qin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Chang:Lijun">Lijun Chang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lin:Xuemin">Xuemin Lin</a></p>
<p>【Abstract】:
A strongly connected component (SCC) is a maximal subgraph of a directed graph G in which every pair of nodes are reachable from each other in the SCC. With such a property, a general directed graph can be represented by a directed acyclic graph DAG by contracting an SCC of G to a node in DAG. In many real applications that need graph pattern matching, topological sorting, or reachability query processing, the best way to deal with a general directed graph is to deal with its DAG representation. Therefore, finding all SCCs in a directed graph G is a critical operation. The existing in-memory algorithms based on depth first search (DFS) can find all SCCs in linear time w.r.t. the size of a graph. However, when a graph cannot resident entirely in the main memory, the existing external or semi-external algorithms to find all SCCs have limitation to achieve high I/O efficiency. In this paper, we study new I/O efficient semi-external algorithms to find all SCCs for a massive directed graph G that cannot reside in main memory entirely. To overcome the deficiency of the existing DFS based semi-external algorithm that heavily relies on a total order, we explore a weak order based on which we investigate new algorithms. We propose a new two phase algorithm, namely, tree construction and tree search. In the tree construction phase, a spanning tree of G can be constructed in bounded sequential scans of G. In the tree search phase, it needs to sequentially scan the graph once to find all SCCs. In addition, we propose a new single phase algorithm, which combines the tree construction and tree search phases into a single phase, with three new optimization techniques. They are early acceptance, early rejection, and batch processing. By the single phase algorithm with the new optimization techniques, we can significantly reduce the number of I/Os and CPU cost. We conduct extensive experimental studies using 4 real datasets including a massive real dataset, and several synthetic datasets to confirm the I/O efficiency of our approaches.</p>
<p>【Keywords】:
graph algorithm; i/o efficient; scc computing</p>
<h3 id="17. TF-Label: a topological-folding labeling scheme for reachability querying in a large graph.">17. TF-Label: a topological-folding labeling scheme for reachability querying in a large graph.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465286">Paper Link</a>】    【Pages】:193-204</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/c/Cheng:James">James Cheng</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Huang:Silu">Silu Huang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wu:Huanhuan">Huanhuan Wu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Fu:Ada_Wai=Chee">Ada Wai-Chee Fu</a></p>
<p>【Abstract】:
Reachability querying is a basic graph operation with numerous important applications in databases, network analysis, computational biology, software engineering, etc. Although many indexes have been proposed to answer reachability queries, most of them are only efficient for handling relatively small graphs. We propose TF-label, an efficient and scalable labeling scheme for processing reachability queries. TF-label is constructed based on a novel topological folding (TF) that recursively folds an input graph into half so as to reduce the label size, thus improving query efficiency. We show that TF-label is efficient to construct and propose efficient algorithms and optimization schemes. Our experiments verify that TF-label is significantly more scalable and efficient than the state-of-the-art methods in both index construction and query processing.</p>
<p>【Keywords】:
graph indexing; graph querying; graph reachability</p>
<h3 id="18. Efficiently computing k-edge connected components via graph decomposition.">18. Efficiently computing k-edge connected components via graph decomposition.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465323">Paper Link</a>】    【Pages】:205-216</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/c/Chang:Lijun">Lijun Chang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yu:Jeffrey_Xu">Jeffrey Xu Yu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/q/Qin:Lu">Lu Qin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lin:Xuemin">Xuemin Lin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Liu:Chengfei">Chengfei Liu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Liang:Weifa">Weifa Liang</a></p>
<p>【Abstract】:
Efficiently computing k-edge connected components in a large graph, G = (V, E), where V is the vertex set and E is the edge set, is a long standing research problem. It is not only fundamental in graph analysis but also crucial in graph search optimization algorithms. Consider existing techniques for computing k-edge connected components are quite time consuming and are unlikely to be scalable for large scale graphs, in this paper we firstly propose a novel graph decomposition paradigm to iteratively decompose a graph G for computing its k-edge connected components such that the number of drilling-down iterations h is bounded by the "depth" of the k-edge connected components nested together to form G, where h usually is a small integer in practice. Secondly, we devise a novel, efficient threshold-based graph decomposition algorithm, with time complexity O(l × |E|), to decompose a graph G at each iteration, where l usually is a small integer with l « |V|. As a result, our algorithm for computing k-edge connected components significantly improves the time complexity of an existing state-of-the-art technique from O(|V|2|E| + |V|3 log |V|) to O(h × l × |E|). Finally, we conduct extensive performance studies on large real and synthetic graphs. The performance studies demonstrate that our techniques significantly outperform the state-of-the-art solution by several orders of magnitude.</p>
<p>【Keywords】:
graph decomposition; k-edge connected components; minimum cut</p>
<h2 id="Research session 7: crowdsourcing    3">Research session 7: crowdsourcing    3</h2>
<h3 id="19. An online cost sensitive decision-making method in crowdsourcing systems.">19. An online cost sensitive decision-making method in crowdsourcing systems.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465307">Paper Link</a>】    【Pages】:217-228</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/g/Gao:Jinyang">Jinyang Gao</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Liu:Xuan">Xuan Liu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/o/Ooi:Beng_Chin">Beng Chin Ooi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Haixun">Haixun Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Chen:Gang">Gang Chen</a></p>
<p>【Abstract】:
Crowdsourcing has created a variety of opportunities for many challenging problems by leveraging human intelligence. For example, applications such as image tagging, natural language processing, and semantic-based information retrieval can exploit crowd-based human computation to supplement existing computational algorithms. Naturally, human workers in crowdsourcing solve problems based on their knowledge, experience, and perception. It is therefore not clear which problems can be better solved by crowdsourcing than solving solely using traditional machine-based methods. Therefore, a cost sensitive quantitative analysis method is needed. In this paper, we design and implement a cost sensitive method for crowdsourcing. We online estimate the profit of the crowdsourcing job so that those questions with no future profit from crowdsourcing can be terminated. Two models are proposed to estimate the profit of crowdsourcing job, namely the linear value model and the generalized non-linear model. Using these models, the expected profit of obtaining new answers for a specific question is computed based on the answers already received. A question is terminated in real time if the marginal expected profit of obtaining more answers is not positive. We extends the method to publish a batch of questions in a HIT. We evaluate the effectiveness of our proposed method using two real world jobs on AMT. The experimental results show that our proposed method outperforms all the state-of-art methods.</p>
<p>【Keywords】:
crowdsourcing; decision-making</p>
<h3 id="20. Leveraging transitive relations for crowdsourced joins.">20. Leveraging transitive relations for crowdsourced joins.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465280">Paper Link</a>】    【Pages】:229-240</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Jiannan">Jiannan Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Li:Guoliang">Guoliang Li</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kraska:Tim">Tim Kraska</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Franklin:Michael_J=">Michael J. Franklin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Feng:Jianhua">Jianhua Feng</a></p>
<p>【Abstract】:
The development of crowdsourced query processing systems has recently attracted a significant attention in the database community. A variety of crowdsourced queries have been investigated. In this paper, we focus on the crowdsourced join query which aims to utilize humans to find all pairs of matching objects from two collections. As a human-only solution is expensive, we adopt a hybrid human-machine approach which first uses machines to generate a candidate set of matching pairs, and then asks humans to label the pairs in the candidate set as either matching or non-matching. Given the candidate pairs, existing approaches will publish all pairs for verification to a crowdsourcing platform. However, they neglect the fact that the pairs satisfy transitive relations. As an example, if o1 matches with o2, and o2 matches with o3, then we can deduce that o1 matches with o3 without needing to crowdsource (o1, o3). To this end, we study how to leverage transitive relations for crowdsourced joins. We propose a hybrid transitive-relations and crowdsourcing labeling framework which aims to crowdsource the minimum number of pairs to label all the candidate pairs. We prove the optimal labeling order and devise a parallel labeling algorithm to efficiently crowdsource the pairs following the order. We evaluate our approaches in both simulated environment and a real crowdsourcing platform. Experimental results show that our approaches with transitive relations can save much more money and time than existing methods, with a little loss in the result quality.</p>
<p>【Keywords】:
crowdsourcing; entity resolution; join operator; transitive relations</p>
<h3 id="21. Crowd mining.">21. Crowd mining.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465318">Paper Link</a>】    【Pages】:241-252</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Amsterdamer:Yael">Yael Amsterdamer</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Grossman:Yael">Yael Grossman</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Milo:Tova">Tova Milo</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Senellart:Pierre">Pierre Senellart</a></p>
<p>【Abstract】:
Harnessing a crowd of Web users for data collection has recently become a wide-spread phenomenon. A key challenge is that the human knowledge forms an open world and it is thus difficult to know what kind of information we should be looking for. Classic databases have addressed this problem by data mining techniques that identify interesting data patterns. These techniques, however, are not suitable for the crowd. This is mainly due to properties of the human memory, such as the tendency to remember simple trends and summaries rather than exact details. Following these observations, we develop here for the first time the foundations of crowd mining. We first define the formal settings. Based on these, we design a framework of generic components, used for choosing the best questions to ask the crowd and mining significant patterns from the answers. We suggest general implementations for these components, and test the resulting algorithm's performance on benchmarks that we designed for this purpose. Our algorithm consistently outperforms alternative baseline algorithms.</p>
<p>【Keywords】:
association rule learning; crowd mining; crowdsourcing</p>
<h2 id="Research session 8: social media    3">Research session 8: social media    3</h2>
<h3 id="22. Efficient sentiment correlation for large-scale demographics.">22. Efficient sentiment correlation for large-scale demographics.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465317">Paper Link</a>】    【Pages】:253-264</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/t/Tsytsarau:Mikalai">Mikalai Tsytsarau</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Amer=Yahia:Sihem">Sihem Amer-Yahia</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Palpanas:Themis">Themis Palpanas</a></p>
<p>【Abstract】:
Analyzing sentiments of demographic groups is becoming important for the Social Web, where millions of users provide opinions on a wide variety of content. While several approaches exist for mining sentiments from product reviews or micro-blogs, little attention has been devoted to aggregating and comparing extracted sentiments for different demographic groups over time, such as 'Students in Italy' or 'Teenagers in Europe'. This problem demands efficient and scalable methods for sentiment aggregation and correlation, which account for the evolution of sentiment values, sentiment bias, and other factors associated with the special characteristics of web data. We propose a scalable approach for sentiment indexing and aggregation that works on multiple time granularities and uses incrementally updateable data structures for online operation. Furthermore, we describe efficient methods for computing meaningful sentiment correlations, which exploit pruning based on demographics and use top-k correlations compression techniques. We present an extensive experimental evaluation with both synthetic and real datasets, demonstrating the effectiveness of our pruning techniques and the efficiency of our solution.</p>
<p>【Keywords】:
indexing; sentiment aggregation; sentiment correlation</p>
<h3 id="23. EBM: an entropy-based model to infer social strength from spatiotemporal data.">23. EBM: an entropy-based model to infer social strength from spatiotemporal data.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465301">Paper Link</a>】    【Pages】:265-276</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/p/Pham:Huy">Huy Pham</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shahabi:Cyrus">Cyrus Shahabi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Liu:Yan">Yan Liu</a></p>
<p>【Abstract】:
The ubiquity of mobile devices and the popularity of location-based-services have generated, for the first time, rich datasets of people's location information at a very high fidelity. These location datasets can be used to study people's behavior - for example, social studies have shown that people, who are seen together frequently at the same place and at the same time, are most probably socially related. In this paper, we are interested in inferring these social connections by analyzing people's location information, which is useful in a variety of application domains from sales and marketing to intelligence analysis. In particular, we propose an entropy-based model (EBM) that not only infers social connections but also estimates the strength of social connections by analyzing people's co-occurrences in space and time. We examine two independent ways: diversity and weighted frequency, through which co-occurrences contribute to social strength. In addition, we take the characteristics of each location into consideration in order to compensate for cases where only limited location information is available. We conducted extensive sets of experiments with real-world datasets including both people's location data and their social connections, where we used the latter as the ground-truth to verify the results of applying our approach to the former. We show that our approach outperforms the competitors.</p>
<p>【Keywords】:
data mining; geospatial; social computing; social network; social strength; spatial; spatiotemporal</p>
<h3 id="24. Online search of overlapping communities.">24. Online search of overlapping communities.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463722">Paper Link</a>】    【Pages】:277-288</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/c/Cui:Wanyun">Wanyun Cui</a> ; <a href="http://dblp.uni-trier.de/pers/hd/x/Xiao:Yanghua">Yanghua Xiao</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Haixun">Haixun Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lu:Yiqi">Yiqi Lu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang_0009:Wei">Wei Wang</a></p>
<p>【Abstract】:
A great deal of research has been conducted on modeling and discovering communities in complex networks. In most real life networks, an object often participates in multiple overlapping communities. In view of this, recent research has focused on mining overlapping communities in complex networks. The algorithms essentially materialize a snapshot of the overlapping communities in the network. This approach has three drawbacks, however. First, the mining algorithm uses the same global criterion to decide whether a subgraph qualifies as a community. In other words, the criterion is fixed and predetermined. But in reality, communities for different vertices may have very different characteristics. Second, it is costly, time consuming, and often unnecessary to find communities for an entire network. Third, the approach does not support dynamically evolving networks. In this paper, we focus on online search of overlapping communities, that is, given a query vertex, we find meaningful overlapping communities the vertex belongs to in an online manner. In doing so, each search can use community criterion tailored for the vertex in the search. To support this approach, we introduce a novel model for overlapping communities, and we provide theoretical guidelines for tuning the model. We present several algorithms for online overlapping community search and we conduct comprehensive experiments to demonstrate the effectiveness of the model and the algorithms. We also suggest many potential applications of our model and algorithms.</p>
<p>【Keywords】:
community search; graph mining; social networks</p>
<h2 id="Research session 9: systems, performance I    3">Research session 9: systems, performance I    3</h2>
<h3 id="25. BitWeaving: fast scans for main memory data processing.">25. BitWeaving: fast scans for main memory data processing.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465322">Paper Link</a>】    【Pages】:289-300</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Li:Yinan">Yinan Li</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Patel:Jignesh_M=">Jignesh M. Patel</a></p>
<p>【Abstract】:
This paper focuses on running scans in a main memory data processing system at "bare metal" speed. Essentially, this means that the system must aim to process data at or near the speed of the processor (the fastest component in most system configurations). Scans are common in main memory data processing environments, and with the state-of-the-art techniques it still takes many cycles per input tuple to apply simple predicates on a single column of a table. In this paper, we propose a technique called BitWeaving that exploits the parallelism available at the bit level in modern processors. BitWeaving operates on multiple bits of data in a single cycle, processing bits from different columns in each cycle. Thus, bits from a batch of tuples are processed in each cycle, allowing BitWeaving to drop the cycles per column to below one in some case. BitWeaving comes in two flavors: BitWeaving/V which looks like a columnar organization but at the bit level, and BitWeaving/H which packs bits horizontally. In this paper we also develop the arithmetic framework that is needed to evaluate predicates using these BitWeaving organizations. Our experimental results show that both these methods produce significant performance benefits over the existing state-of-the-art methods, and in some cases produce over an order of magnitude in performance improvement.</p>
<p>【Keywords】:
analytics; bit-parallel; indexing; intra-cycle parallelism; storage organization</p>
<h3 id="26. Performance and resource modeling in highly-concurrent OLTP workloads.">26. Performance and resource modeling in highly-concurrent OLTP workloads.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2467800">Paper Link</a>】    【Pages】:301-312</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Mozafari:Barzan">Barzan Mozafari</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Curino:Carlo">Carlo Curino</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Jindal:Alekh">Alekh Jindal</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Madden:Samuel">Samuel Madden</a></p>
<p>【Abstract】:
Database administrators of Online Transaction Processing (OLTP) systems constantly face difficult questions. For example, "What is the maximum throughput I can sustain with my current hardware?", "How much disk I/O will my system perform if the requests per second double?", or "What will happen if the ratio of transactions in my system changes?". Resource prediction and performance analysis are both vital and difficult in this setting. Here the challenge is due to high degrees of concurrency, competition for resources, and complex interactions between transactions, all of which non-linearly impact performance. Although difficult, such analysis is a key component in enabling database administrators to understand which queries are eating up the resources, and how their system would scale under load. In this paper, we introduce our framework, called DBSeer, that addresses this problem by employing statistical models that provide resource and performance analysis and prediction for highly concurrent OLTP workloads. Our models are built on a small amount of training data from standard log information collected during normal system operation. These models are capable of accurately measuring several performance metrics, including resource consumption on a per-transaction-type basis, resource bottlenecks, and throughput at different load levels. We have validated these models on MySQL/Linux with numerous experiments on standard benchmarks (TPC-C) and real workloads (Wikipedia), observing high accuracy (within a few percent error) when predicting all of the above metrics.</p>
<p>【Keywords】:
database-as-a-service; multi-tenancy; oltp; performance prediction transactions muti-tenancy; performance predictions</p>
<h3 id="27. ODYS: an approach to building a massively-parallel search engine using a DB-IR tightly-integrated parallel DBMS for higher-level functionality.">27. ODYS: an approach to building a massively-parallel search engine using a DB-IR tightly-integrated parallel DBMS for higher-level functionality.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465316">Paper Link</a>】    【Pages】:313-324</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/w/Whang:Kyu=Young">Kyu-Young Whang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yun:Tae=Seob">Tae-Seob Yun</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yeo:Yeon=Mi">Yeon-Mi Yeo</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Song:Il=Yeol">Il-Yeol Song</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kwon:Hyuk=Yoon">Hyuk-Yoon Kwon</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kim:In=Joong">In-Joong Kim</a></p>
<p>【Abstract】:
Recently, parallel search engines have been implemented based on scalable distributed file systems such as Google File System. However, we claim that building a massively-parallel search engine using a parallel DBMS can be an attractive alternative since it supports a higher-level (i.e., SQL-level) interface than that of a distributed file system for easy and less error-prone application development while providing scalability. Regarding higher-level functionality, we can draw a parallel with the traditional O/S file system vs. DBMS. In this paper, we propose a new approach of building a massively-parallel search engine using a DB-IR tightly-integrated parallel DBMS. To estimate the performance, we propose a hybrid (i.e., analytic and experimental) performance model for the parallel search engine. We argue that the model can accurately estimate the performance of a massively-parallel (e.g., 300-node) search engine using the experimental results obtained from a small-scale (e.g., 5-node) one. We show that the estimation error between the model and the actual experiment is less than 2.13% by observing that the bulk of the query processing time is spent at the slave (vs. at the master and network) and by estimating the time spent at the slave based on actual measurement. Using our model, we demonstrate a commercial-level scalability and performance of our architecture. Our proposed system ODYS is capable of handling 1 billion queries per day (81 queries/sec) for 30 billion Web pages by using only 43,472 nodes with an average query response time of 194 ms. By using twice as many (86,944) nodes, ODYS can provide an average query response time of 148 ms. These results show that building a massively-parallel search engine using a parallel DBMS is a viable approach with advantages of supporting the high-level (i.e., DBMS-level), SQL-like programming interface.</p>
<p>【Keywords】:
db-ir tight integration; massively-parallel search engine; parallel dbms</p>
<h2 id="Research session 10: graph management    3">Research session 10: graph management    3</h2>
<h3 id="28. Massive graph triangulation.">28. Massive graph triangulation.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463704">Paper Link</a>】    【Pages】:325-336</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/h/Hu:Xiaocheng">Xiaocheng Hu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tao:Yufei">Yufei Tao</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Chung:Chin=Wan">Chin-Wan Chung</a></p>
<p>【Abstract】:
This paper studies I/O-efficient algorithms for settling the classic triangle listing problem, whose solution is a basic operator in dealing with many other graph problems. Specifically, given an undirected graph G, the objective of triangle listing is to find all the cliques involving 3 vertices in G. The problem has been well studied in internal memory, but remains an urgent difficult challenge when G does not fit in memory, rendering any algorithm to entail frequent I/O accesses. Although previous research has attempted to tackle the challenge, the state-of-the-art solutions rely on a set of crippling assumptions to guarantee good performance. Motivated by this, we develop a new algorithm that is provably I/O and CPU efficient at the same time, without making any assumption on the input G at all. The algorithm uses ideas drastically different from all the previous approaches, and outperformed the existing competitors by a factor over an order of magnitude in our extensive experimentation.</p>
<p>【Keywords】:
graph; i/o-efficient algorithm; triangle</p>
<h3 id="29. Turboiso: towards ultrafast and robust subgraph isomorphism search in large graph databases.">29. Turboiso: towards ultrafast and robust subgraph isomorphism search in large graph databases.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465300">Paper Link</a>】    【Pages】:337-348</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/h/Han:Wook=Shin">Wook-Shin Han</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lee:Jinsoo">Jinsoo Lee</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lee:Jeong=Hoon">Jeong-Hoon Lee</a></p>
<p>【Abstract】:
Given a query graph q and a data graph g, the subgraph isomorphism search finds all occurrences of q in g and is considered one of the most fundamental query types for many real applications. While this problem belongs to NP-hard, many algorithms have been proposed to solve it in a reasonable time for real datasets. However, a recent study has shown, through an extensive benchmark with various real datasets, that all existing algorithms have serious problems in their matching order selection. Furthermore, all algorithms blindly permutate all possible mappings for query vertices, often leading to useless computations. In this paper, we present an efficient and robust subgraph search solution, called TurboISO, which is turbo-charged with two novel concepts, candidate region exploration and the combine and permute strategy (in short, Comb/Perm). The candidate region exploration identifies on-the-fly candidate subgraphs (i.e, candidate regions), which contain embeddings, and computes a robust matching order for each candidate region explored. The Comb/Perm strategy exploits the novel concept of the neighborhood equivalence class (NEC). Each query vertex in the same NEC has identically matching data vertices. During subgraph isomorphism search, Comb/Perm generates only combinations for each NEC instead of permutating all possible enumerations. Thus, if a chosen combination is determined to not contribute to a complete solution, all possible permutations for that combination will be safely pruned. Extensive experiments with many real datasets show that TurboISO consistently and significantly outperforms all competitors by up to several orders of magnitude.</p>
<p>【Keywords】:
candidate region exploration; combine and permute strategy; neighborhood equivalence class; subgraph isomorphism</p>
<h3 id="30. Fast exact shortest-path distance queries on large networks by pruned landmark labeling.">30. Fast exact shortest-path distance queries on large networks by pruned landmark labeling.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465315">Paper Link</a>】    【Pages】:349-360</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Akiba:Takuya">Takuya Akiba</a> ; <a href="http://dblp.uni-trier.de/pers/hd/i/Iwata:Yoichi">Yoichi Iwata</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yoshida:Yuichi">Yuichi Yoshida</a></p>
<p>【Abstract】:
We propose a new exact method for shortest-path distance queries on large-scale networks. Our method precomputes distance labels for vertices by performing a breadth-first search from every vertex. Seemingly too obvious and too inefficient at first glance, the key ingredient introduced here is pruning during breadth-first searches. While we can still answer the correct distance for any pair of vertices from the labels, it surprisingly reduces the search space and sizes of labels. Moreover, we show that we can perform 32 or 64 breadth-first searches simultaneously exploiting bitwise operations. We experimentally demonstrate that the combination of these two techniques is efficient and robust on various kinds of large-scale real-world networks. In particular, our method can handle social networks and web graphs with hundreds of millions of edges, which are two orders of magnitude larger than the limits of previous exact methods, with comparable query time to those of previous methods.</p>
<p>【Keywords】:
graphs; query processing; shortest paths</p>
<h2 id="Research session 11: text databases    3">Research session 11: text databases    3</h2>
<h3 id="31. Improving regular-expression matching on strings using negative factors.">31. Improving regular-expression matching on strings using negative factors.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465289">Paper Link</a>】    【Pages】:361-372</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/y/Yang:Xiaochun">Xiaochun Yang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Bin">Bin Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/q/Qiu:Tao">Tao Qiu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Yaoshu">Yaoshu Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Li_0001:Chen">Chen Li</a></p>
<p>【Abstract】:
The problem of finding matches of a regular expression (RE) on a string exists in many applications such as text editing, biosequence search, and shell commands. Existing techniques first identify candidates using substrings in the RE, then verify each of them using an automaton. These techniques become inefficient when there are many candidate occurrences that need to be verified. In this paper we propose a novel technique that prunes false negatives by utilizing negative factors, which are substrings that cannot appear in an answer. A main advantage of the technique is that it can be integrated with many existing algorithms to improve their efficiency significantly. We give a full specification of this technique. We develop an efficient algorithm that utilizes negative factors to prune candidates, then improve it by using bit operations to process negative factors in parallel. We show that negative factors, when used together with necessary factors (substrings that must appear in each answer), can achieve much better pruning power. We analyze the large number of negative factors, and develop an algorithm for finding a small number of high-quality negative factors. We conducted a thorough experimental study of this technique on real data sets, including DNA sequences, proteins, and text documents, and show the significant performance improvement when applying the technique in existing algorithms. For instance, it improved the search speed of the popular Gnu Grep tool by 11 to 74 times for text documents.</p>
<p>【Keywords】:
long sequence; performance; regular expression</p>
<h3 id="32. String similarity measures and joins with synonyms.">32. String similarity measures and joins with synonyms.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465313">Paper Link</a>】    【Pages】:373-384</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Lu:Jiaheng">Jiaheng Lu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lin:Chunbin">Chunbin Lin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang_0011:Wei">Wei Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Li_0001:Chen">Chen Li</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Haiyong">Haiyong Wang</a></p>
<p>【Abstract】:
A string similarity measure quantifies the similarity between two text strings for approximate string matching or comparison. For example, the strings "Sam" and "Samuel" can be considered similar. Most existing work that computes the similarity of two strings only considers syntactic similarities, e.g., number of common words or q-grams. While these are indeed indicators of similarity, there are many important cases where syntactically different strings can represent the same real-world object. For example, "Bill" is a short form of "William". Given a collection of predefined synonyms, the purpose of the paper is to explore such existing knowledge to evaluate string similarity measures more effectively and efficiently, thereby boosting the quality of string matching. In particular, we first present an expansion-based framework to measure string similarities efficiently while considering synonyms. Because using synonyms in similarity measures is, while expressive, computationally expensive (NP-hard), we propose an efficient algorithm, called selective-expansion, which guarantees the optimality in many real scenarios. We then study a novel indexing structure called SI-tree, which combines both signature and length filtering strategies, for efficient string similarity joins with synonyms. We develop an estimator to approximate the size of candidates to enable an online selection of signature filters to further improve the efficiency. This estimator provides strong low-error, high-confidence guarantees while requiring only logarithmic space and time costs, thus making our method attractive both in theory and in practice. Finally, the results from an empirical study of the algorithms verify the effectiveness and efficiency of our approach.</p>
<p>【Keywords】:
filter estimation; similarity join; similarity search</p>
<h3 id="33. Efficient top-k algorithms for approximate substring matching.">33. Efficient top-k algorithms for approximate substring matching.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465324">Paper Link</a>】    【Pages】:385-396</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/k/Kim:Younghoon">Younghoon Kim</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shim:Kyuseok">Kyuseok Shim</a></p>
<p>【Abstract】:
There is a wide range of applications that require to query a large database of texts to search for similar strings or substrings. Traditional approximate substring matching requests a user to specify a similarity threshold. Without top-k approximate substring matching, users have to try repeatedly different maximum distance threshold values when the proper threshold is unknown in advance. In our paper, we first propose the efficient algorithms for finding the top-k approximate substring matches with a given query string in a set of data strings. To reduce the number of expensive distance computations, the proposed algorithms utilize our novel filtering techniques which take advantages of q-grams and inverted q-gram indexes available. We conduct extensive experiments with real-life data sets. Our experimental results confirm the effectiveness and scalability of our proposed algorithms.</p>
<p>【Keywords】:
edit distance; inverted q-gram index; top-k approximate substring matching</p>
<h2 id="Research session 12: systems, performance II    3">Research session 12: systems, performance II    3</h2>
<h3 id="34. Towards high-throughput gibbs sampling at scale: a study across storage managers.">34. Towards high-throughput gibbs sampling at scale: a study across storage managers.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463702">Paper Link</a>】    【Pages】:397-408</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Ce">Ce Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/R=eacute=:Christopher">Christopher Ré</a></p>
<p>【Abstract】:
Factor graphs and Gibbs sampling are a popular combination for Bayesian statistical methods that are used to solve diverse problems including insurance risk models, pricing models, and information extraction. Given a fixed sampling method and a fixed amount of time, an implementation of a sampler that achieves a higher throughput of samples will achieve a higher quality than a lower-throughput sampler. We study how (and whether) traditional data processing choices about materialization, page layout, and buffer-replacement policy need to be changed to achieve high-throughput Gibbs sampling for factor graphs that are larger than main memory. We find that both new theoretical and new algorithmic techniques are required to understand the tradeoff space for each choice. On both real and synthetic data, we demonstrate that traditional baseline approaches may achieve two orders of magnitude lower throughput than an optimal approach. For a handful of popular tasks across several storage backends, including HBase and traditional unix files, we show that our simple prototype achieves competitive (and sometimes better) throughput compared to specialized state-of-the-art approaches on factor graphs that are larger than main memory.</p>
<p>【Keywords】:
gibbs sampling; scalability; storage manager</p>
<h3 id="35. Latch-free data structures for DBMS: design, implementation, and evaluation.">35. Latch-free data structures for DBMS: design, implementation, and evaluation.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463720">Paper Link</a>】    【Pages】:409-420</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/h/Horikawa:Takashi">Takashi Horikawa</a></p>
<p>【Abstract】:
The fact that multi-core CPUs have become so common and that the number of CPU cores in one chip has continued to rise means that a server machine can easily contain an extremely high number of CPU cores. The CPU scalability of IT systems is thus attracting a considerable amount of research attention. Some systems, such as ACID-compliant DBMSs, are said to be difficult to scale, probably due to the mutual exclusion required to ensure data consistency. Possible countermeasures include latch-free (LF) data structures, an elemental technology to improve the CPU scalability by eliminating the need for mutual exclusion. This paper investigates these LF data structures with a particular focus on their applicability and effectiveness. Some existing LF data structures (such as LF hash tables) have been adapted to PostgreSQL, one of the most popular open-source DBMSs. The performance improvement was evaluated with a benchmark program simulating real-world transactions. Measurement results obtained from state-of-the-art 80-core machines demonstrated that the LF data structures were effective for performance improvement in a many-core situation in which DBT-1 throughput increased by about 2.5 times. Although the poor performance of the original DBMS was due to a severe latch-related bottleneck and can be improved by parameter tuning, it is of practical importance that LF data structures provided performance improvement without deep understanding of the target system behavior that is necessary for the parameter tuning.</p>
<p>【Keywords】:
benchmark program; bottleneck; critical section; database management system; formal verification; many-core system; performance tuning; scalability; symmetric multiprocessing</p>
<h3 id="36. DBMS metrology: measuring query time.">36. DBMS metrology: measuring query time.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465331">Paper Link</a>】    【Pages】:421-432</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/c/Currim:Sabah">Sabah Currim</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Snodgrass:Richard_T=">Richard T. Snodgrass</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Suh:Young=Kyoon">Young-Kyoon Suh</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Rui">Rui Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Johnson:Matthew_Wong">Matthew Wong Johnson</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yi:Cheng">Cheng Yi</a></p>
<p>【Abstract】:
It is surprisingly hard to obtain accurate and precise measurements of the time spent executing a query. We review relevant process and overall measures obtainable from the Linux kernel and introduce a structural causal model relating these measures. A thorough correlational analysis provides strong support for this model. Using this model, we developed a timing protocol, which (1) performs sanity checks to ensure validity of the data, (2) drops some query executions via clearly motivated predicates, (3) drops some entire queries at a cardinality, again via clearly motivated predicates, (4) for those that remain, for each computes a single measured time by a carefully justified formula over the underlying measures of the remaining query executions, and (5) performs post-analysis sanity checks. The resulting query time measurement procedure, termed the Tucson Protocol, applies to proprietary and open-source DBMSes.</p>
<p>【Keywords】:
accuracy; repeatability; tucson protocol</p>
<h2 id="Research session 13: information extraction    3">Research session 13: information extraction    3</h2>
<h3 id="37. Quality and efficiency for kernel density estimates in large data.">37. Quality and efficiency for kernel density estimates in large data.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465319">Paper Link</a>】    【Pages】:433-444</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/z/Zheng:Yan">Yan Zheng</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Jestes:Jeffrey">Jeffrey Jestes</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Phillips:Jeff_M=">Jeff M. Phillips</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Li:Feifei">Feifei Li</a></p>
<p>【Abstract】:
Kernel density estimates are important for a broad variety of applications. Their construction has been well-studied, but existing techniques are expensive on massive datasets and/or only provide heuristic approximations without theoretical guarantees. We propose randomized and deterministic algorithms with quality guarantees which are orders of magnitude more efficient than previous algorithms. Our algorithms do not require knowledge of the kernel or its bandwidth parameter and are easily parallelizable. We demonstrate how to implement our ideas in a centralized setting and in MapReduce, although our algorithms are applicable to any large-scale data processing framework. Extensive experiments on large real datasets demonstrate the quality, efficiency, and scalability of our techniques.</p>
<p>【Keywords】:
distributed and parallel kde; kernel density estimate (kde)</p>
<h3 id="38. Efficient ad-hoc search for personalized PageRank.">38. Efficient ad-hoc search for personalized PageRank.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463717">Paper Link</a>】    【Pages】:445-456</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/f/Fujiwara:Yasuhiro">Yasuhiro Fujiwara</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/Nakatsuji:Makoto">Makoto Nakatsuji</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shiokawa:Hiroaki">Hiroaki Shiokawa</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Mishima:Takeshi">Takeshi Mishima</a> ; <a href="http://dblp.uni-trier.de/pers/hd/o/Onizuka:Makoto">Makoto Onizuka</a></p>
<p>【Abstract】:
Personalized PageRank (PPR) has been successfully applied to various applications. In real applications, it is important to set PPR parameters in an ad-hoc manner when finding similar nodes because of dynamically changing nature of graphs. Through interactive actions, interactive similarity search supports users to enhance the efficacy of applications. Unfortunately, if the graph is large, interactive similarity search is infeasible due to its high computation cost. Previous PPR approaches cannot effectively handle interactive similarity search since they need precomputation or approximate computation of similarities. The goal of this paper is to efficiently find the top-k nodes with exact node ranking so as to effectively support interactive similarity search based on PPR. Our solution is Castanet. The key Castanet operations are (1) estimate upper/lower bounding similarities iteratively, and (2) prune unnecessary nodes dynamically to obtain top-k nodes in each iteration. Experiments show that our approach is much faster than existing approaches.</p>
<p>【Keywords】:
graph database; personalized pagerank; top-k search</p>
<h3 id="39. Provenance-based dictionary refinement in information extraction.">39. Provenance-based dictionary refinement in information extraction.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465284">Paper Link</a>】    【Pages】:457-468</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/r/Roy:Sudeepa">Sudeepa Roy</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Chiticariu:Laura">Laura Chiticariu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Feldman:Vitaly">Vitaly Feldman</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Reiss:Frederick">Frederick Reiss</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhu:Huaiyu">Huaiyu Zhu</a></p>
<p>【Abstract】:
Dictionaries of terms and phrases (e.g. common person or organization names) are integral to information extraction systems that extract structured information from unstructured text. Using noisy or unrefined dictionaries may lead to many incorrect results even when highly precise and sophisticated extraction rules are used. In general, the results of the system are dependent on dictionary entries in arbitrary complex ways, and removal of a set of entries can remove both correct and incorrect results. Further, any such refinement critically requires laborious manual labeling of the results. In this paper, we study the dictionary refinement problem and address the above challenges. Using provenance of the outputs in terms of the dictionary entries, we formalize an optimization problem of maximizing the quality of the system with respect to the refined dictionaries, study complexity of this problem, and give efficient algorithms. We also propose solutions to address incomplete labeling of the results where we estimate the missing labels assuming a statistical model. We conclude with a detailed experimental evaluation using several real-world extractors and competition datasets to validate our solutions. Beyond information extraction, our provenance-based techniques and solutions may find applications in view-maintenance in general relational settings.</p>
<p>【Keywords】:
information extraction; optimization; provenance; refinement</p>
<h2 id="Research session 14: query processing and optimization    3">Research session 14: query processing and optimization    3</h2>
<h3 id="40. CS2: a new database synopsis for query estimation.">40. CS2: a new database synopsis for query estimation.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463701">Paper Link</a>】    【Pages】:469-480</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/y/Yu:Feng">Feng Yu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Hou:Wen=Chi">Wen-Chi Hou</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Luo:Cheng">Cheng Luo</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Che:Dunren">Dunren Che</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhu:Mengxia">Mengxia Zhu</a></p>
<p>【Abstract】:
Fast and accurate estimations for complex queries are profoundly beneficial for large databases with heavy workloads. In this research, we propose a statistical summary for a database, called CS2 (Correlated Sample Synopsis), to provide rapid and accurate result size estimations for all queries with joins and arbitrary selections. Unlike the state-of-the-art techniques, CS2 does not completely rely on simple random samples, but mainly consists of correlated sample tuples that retain join relationships with less storage. We introduce a statistical technique, called reverse sample, and design a powerful estimator, called reverse estimator, to fully utilize correlated sample tuples for query estimation. We prove both theoretically and empirically that the reverse estimator is unbiased and accurate using CS2. Extensive experiments on multiple datasets show that CS2 is fast to construct and derives more accurate estimations than existing methods with the same space budget.</p>
<p>【Keywords】:
database synopsis; query optimization; selectivity estimation</p>
<h3 id="41. Branch-and-bound algorithm for reverse top-k queries.">41. Branch-and-bound algorithm for reverse top-k queries.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465278">Paper Link</a>】    【Pages】:481-492</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/v/Vlachou:Akrivi">Akrivi Vlachou</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Doulkeridis:Christos">Christos Doulkeridis</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/N=oslash=rv=aring=g:Kjetil">Kjetil Nørvåg</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kotidis:Yannis">Yannis Kotidis</a></p>
<p>【Abstract】:
Top-k queries return to the user only the k best objects based on the individual user preferences and comprise an essential tool for rank-aware query processing. Assuming a stored data set of user preferences, reverse top-k queries have been introduced for retrieving the users that deem a given database object as one of their top-k results. Reverse top-k queries have already attracted significant interest in research, due to numerous real-life applications such as market analysis and product placement. Currently, the most efficient algorithm for computing the reverse top-k set is RTA. RTA has two main drawbacks when processing a reverse top-k query: (i) it needs to access all stored user preferences, and (ii) it cannot avoid executing a top-k query for each user preference that belongs to the result set. To address these limitations, in this paper, we identify useful properties for processing reverse top-k queries without accessing each user's individual preferences nor executing the top-k query. We propose an intuitive branch-and-bound algorithm for processing reverse top-k queries efficiently and discuss novel optimizations to boost its performance. Our experimental evaluation demonstrates the efficiency of the proposed algorithm that outperforms RTA by a large margin.</p>
<p>【Keywords】:
branch-and-bound algorithm; reverse top-k query</p>
<h3 id="42. On the correct and complete enumeration of the core search space.">42. On the correct and complete enumeration of the core search space.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465314">Paper Link</a>】    【Pages】:493-504</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Moerkotte:Guido">Guido Moerkotte</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Fender:Pit">Pit Fender</a> ; <a href="http://dblp.uni-trier.de/pers/hd/e/Eich:Marius">Marius Eich</a></p>
<p>【Abstract】:
Reordering more than traditional joins (e.g. outerjoins, antijoins) requires some care, since not all reorderings are valid. To prevent invalid plans, two approaches have been described in the literature. We show that both approaches still produce invalid plans. We present three conflict detectors. All of them are (1) correct, i.e., prevent invalid plans, (2) easier to understand and implement than the previous (buggy) approaches, (3) more flexible in the sense that the restriction that all predicates must reject nulls is no longer required, and (4) extensible in the sense that it is easy to add new operators. Further, the last of our three approaches is complete, i.e., it allows for the generation of all valid plans within the core search space.</p>
<p>【Keywords】:
join ordering; non-inner joins; query optimization</p>
<h2 id="Research session 15: cloud computing    3">Research session 15: cloud computing    3</h2>
<h3 id="43. Trinity: a distributed graph engine on a memory cloud.">43. Trinity: a distributed graph engine on a memory cloud.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2467799">Paper Link</a>】    【Pages】:505-516</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Shao:Bin">Bin Shao</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Haixun">Haixun Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Li:Yatao">Yatao Li</a></p>
<p>【Abstract】:
Computations performed by graph algorithms are data driven, and require a high degree of random data access. Despite the great progresses made in disk technology, it still cannot provide the level of efficient random access required by graph computation. On the other hand, memory-based approaches usually do not scale due to the capacity limit of single machines. In this paper, we introduce Trinity, a general purpose graph engine over a distributed memory cloud. Through optimized memory management and network communication, Trinity supports fast graph exploration as well as efficient parallel computing. In particular, Trinity leverages graph access patterns in both online and offline computation to optimize memory and communication for best performance. These enable Trinity to support efficient online query processing and offline analytics on large graphs with just a few commodity machines. Furthermore, Trinity provides a high level specification language called TSL for users to declare data schema and communication protocols, which brings great ease-of-use for general purpose graph management and computing. Our experiments show Trinity's performance in both low latency graph queries as well as high throughput graph analytics on web-scale, billion-node graphs.</p>
<p>【Keywords】:
distributed system; graph database; memory cloud</p>
<h3 id="44. Characterizing tenant behavior for placement and crisis mitigation in multitenant DBMSs.">44. Characterizing tenant behavior for placement and crisis mitigation in multitenant DBMSs.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465308">Paper Link</a>】    【Pages】:517-528</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/e/Elmore:Aaron_J=">Aaron J. Elmore</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Das:Sudipto">Sudipto Das</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Pucher:Alexander">Alexander Pucher</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Agrawal:Divyakant">Divyakant Agrawal</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Abbadi:Amr_El">Amr El Abbadi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yan:Xifeng">Xifeng Yan</a></p>
<p>【Abstract】:
A multitenant database management system (DBMS) in the cloud must continuously monitor the trade-off between efficient resource sharing among multiple application databases (tenants) and their performance. Considering the scale of \attn{hundreds to} thousands of tenants in such multitenant DBMSs, manual approaches for continuous monitoring are not tenable. A self-managing controller of a multitenant DBMS faces several challenges. For instance, how to characterize a tenant given its variety of workloads, how to reduce the impact of tenant colocation, and how to detect and mitigate a performance crisis where one or more tenants' desired service level objective (SLO) is not achieved. We present Delphi, a self-managing system controller for a multitenant DBMS, and Pythia, a technique to learn behavior through observation and supervision using DBMS-agnostic database level performance measures. Pythia accurately learns tenant behavior even when multiple tenants share a database process, learns good and bad tenant consolidation plans (or packings), and maintains a pertenant history to detect behavior changes. Delphi detects performance crises, and leverages Pythia to suggests remedial actions using a hill-climbing search algorithm to identify a new tenant placement strategy to mitigate violating SLOs. Our evaluation using a variety of tenant types and workloads shows that Pythia can learn a tenant's behavior with more than 92% accuracy and learn the quality of packings with more than 86% accuracy. During a performance crisis, Delphi is able to reduce 99th percentile latencies by 80%, and can consolidate 45% more tenants than a greedy baseline, which balances tenant load without modeling tenant behavior.</p>
<p>【Keywords】:
database consolidation; elastic data management; multitenancy; shared nothing architectures; tenant characterization</p>
<h3 id="45. Minimal MapReduce algorithms.">45. Minimal MapReduce algorithms.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463719">Paper Link</a>】    【Pages】:529-540</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/t/Tao:Yufei">Yufei Tao</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lin:Wenqing">Wenqing Lin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/x/Xiao:Xiaokui">Xiaokui Xiao</a></p>
<p>【Abstract】:
MapReduce has become a dominant parallel computing paradigm for big data, i.e., colossal datasets at the scale of tera-bytes or higher. Ideally, a MapReduce system should achieve a high degree of load balancing among the participating machines, and minimize the space usage, CPU and I/O time, and network transfer at each machine. Although these principles have guided the development of MapReduce algorithms, limited emphasis has been placed on enforcing serious constraints on the aforementioned metrics simultaneously. This paper presents the notion of minimal algorithm, that is, an algorithm that guarantees the best parallelization in multiple aspects at the same time, up to a small constant factor. We show the existence of elegant minimal algorithms for a set of fundamental database problems, and demonstrate their excellent performance with extensive experiments.</p>
<p>【Keywords】:
big data; mapreduce; minimal algorithm</p>
<h2 id="Research session 16: data cleaning    3">Research session 16: data cleaning    3</h2>
<h3 id="46. NADEEF: a commodity data cleaning system.">46. NADEEF: a commodity data cleaning system.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465327">Paper Link</a>】    【Pages】:541-552</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/d/Dallachiesa:Michele">Michele Dallachiesa</a> ; <a href="http://dblp.uni-trier.de/pers/hd/e/Ebaid:Amr">Amr Ebaid</a> ; <a href="http://dblp.uni-trier.de/pers/hd/e/Eldawy:Ahmed">Ahmed Eldawy</a> ; <a href="http://dblp.uni-trier.de/pers/hd/e/Elmagarmid:Ahmed_K=">Ahmed K. Elmagarmid</a> ; <a href="http://dblp.uni-trier.de/pers/hd/i/Ilyas:Ihab_F=">Ihab F. Ilyas</a> ; <a href="http://dblp.uni-trier.de/pers/hd/o/Ouzzani:Mourad">Mourad Ouzzani</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tang_0001:Nan">Nan Tang</a></p>
<p>【Abstract】:
Despite the increasing importance of data quality and the rich theoretical and practical contributions in all aspects of data cleaning, there is no single end-to-end off-the-shelf solution to (semi-)automate the detection and the repairing of violations w.r.t. a set of heterogeneous and ad-hoc quality constraints. In short, there is no commodity platform similar to general purpose DBMSs that can be easily customized and deployed to solve application-specific data quality problems. In this paper, we present NADEEF, an extensible, generalized and easy-to-deploy data cleaning platform. NADEEF distinguishes between a programming interface and a core to achieve generality and extensibility. The programming interface allows the users to specify multiple types of data quality rules, which uniformly define what is wrong with the data and (possibly) how to repair it through writing code that implements predefined classes. We show that the programming interface can be used to express many types of data quality rules beyond the well known CFDs (FDs), MDs and ETL rules. Treating user implemented interfaces as black-boxes, the core provides algorithms to detect errors and to clean data. The core is designed in a way to allow cleaning algorithms to cope with multiple rules holistically, i.e. detecting and repairing data errors without differentiating between various types of rules. We showcase two implementations for core repairing algorithms. These two implementations demonstrate the extensibility of our core, which can also be replaced by other user-provided algorithms. Using real-life data, we experimentally verify the generality, extensibility, and effectiveness of our system.</p>
<p>【Keywords】:
conditional functional dependency; data cleaning; etl; matching dependency</p>
<h3 id="47. Don't be SCAREd: use SCalable Automatic REpairing with maximal likelihood and bounded changes.">47. Don't be SCAREd: use SCalable Automatic REpairing with maximal likelihood and bounded changes.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463706">Paper Link</a>】    【Pages】:553-564</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/y/Yakout:Mohamed">Mohamed Yakout</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Berti=Equille:Laure">Laure Berti-Equille</a> ; <a href="http://dblp.uni-trier.de/pers/hd/e/Elmagarmid:Ahmed_K=">Ahmed K. Elmagarmid</a></p>
<p>【Abstract】:
Various computational procedures or constraint-based methods for data repairing have been proposed over the last decades to identify errors and, when possible, correct them. However, these approaches have several limitations including the scalability and quality of the values to be used in replacement of the errors. In this paper, we propose a new data repairing approach that is based on maximizing the likelihood of replacement data given the data distribution, which can be modeled using statistical machine learning techniques. This is a novel approach combining machine learning and likelihood methods for cleaning dirty databases by value modification. We develop a quality measure of the repairing updates based on the likelihood benefit and the amount of changes applied to the database. We propose SCARE (SCalable Automatic REpairing), a systematic scalable framework that follows our approach. SCARE relies on a robust mechanism for horizontal data partitioning and a combination of machine learning techniques to predict the set of possible updates. Due to data partitioning, several updates can be predicted for a single record based on local views on each data partition. Therefore, we propose a mechanism to combine the local predictions and obtain accurate final predictions. Finally, we experimentally demonstrate the effectiveness, efficiency, and scalability of our approach on real-world datasets in comparison to recent data cleaning approaches.</p>
<p>【Keywords】:
data cleaning; inconsistent data</p>
<h3 id="48. Determining the relative accuracy of attributes.">48. Determining the relative accuracy of attributes.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465309">Paper Link</a>】    【Pages】:565-576</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/c/Cao:Yang">Yang Cao</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Fan:Wenfei">Wenfei Fan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yu:Wenyuan">Wenyuan Yu</a></p>
<p>【Abstract】:
The relative accuracy problem is to determine, given tuples t1 and t2 that refer to the same entity e, whether t1[A] is more accurate than t2A, i.e., t1A is closer to the true value of the A attribute of e than t2A. This has been a longstanding issue for data quality, and is challenging when the true values of e are unknown. This paper proposes a model for determining relative accuracy. (1) We introduce a class of accuracy rules and an inference system with a chase procedure, to deduce relative accuracy. (2) We identify and study several fundamental problems for relative accuracy. Given a set Ie of tuples pertaining to the same entity e and a set of accuracy rules, these problems are to decide whether the chase process terminates, is Church-Rosser, and leads to a unique target tuple te composed of the most accurate values from Ie for all the attributes of e. (3) We propose a framework for inferring accurate values with user interaction. (4) We provide algorithms underlying the framework, to find the unique target tuple te whenever possible; when there is no enough information to decide a complete te, we compute top-k candidate targets based on a preference model. (5) Using real-life and synthetic data, we experimentally verify the effectiveness and efficiency of our method.</p>
<p>【Keywords】:
data accuracy; data cleaning</p>
<h2 id="Research session 17: complex event processing    3">Research session 17: complex event processing    3</h2>
<h3 id="49. Photon: fault-tolerant and scalable joining of continuous data streams.">49. Photon: fault-tolerant and scalable joining of continuous data streams.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465272">Paper Link</a>】    【Pages】:577-588</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Ananthanarayanan:Rajagopal">Rajagopal Ananthanarayanan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Basker:Venkatesh">Venkatesh Basker</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Das:Sumit">Sumit Das</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Gupta:Ashish">Ashish Gupta</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Jiang:Haifeng">Haifeng Jiang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/q/Qiu:Tianhao">Tianhao Qiu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Reznichenko:Alexey">Alexey Reznichenko</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Ryabkov:Deomid">Deomid Ryabkov</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Singh:Manpreet">Manpreet Singh</a> ; <a href="http://dblp.uni-trier.de/pers/hd/v/Venkataraman:Shivakumar">Shivakumar Venkataraman</a></p>
<p>【Abstract】:
Web-based enterprises process events generated by millions of users interacting with their websites. Rich statistical data distilled from combining such interactions in near real-time generates enormous business value. In this paper, we describe the architecture of Photon, a geographically distributed system for joining multiple continuously flowing streams of data in real-time with high scalability and low latency, where the streams may be unordered or delayed. The system fully tolerates infrastructure degradation and datacenter-level outages without any manual intervention. Photon guarantees that there will be no duplicates in the joined output (at-most-once semantics) at any point in time, that most joinable events will be present in the output in real-time (near-exact semantics), and exactly-once semantics eventually. Photon is deployed within Google Advertising System to join data streams such as web search queries and user clicks on advertisements. It produces joined logs that are used to derive key business metrics, including billing for advertisers. Our production deployment processes millions of events per minute at peak with an average end-to-end latency of less than 10 seconds. We also present challenges and solutions in maintaining large persistent state across geographically distant locations, and highlight the design principles that emerged from our experience.</p>
<p>【Keywords】:
continuous streams; fault-tolerance; paxos; stream joining</p>
<h3 id="50. Utility-maximizing event stream suppression.">50. Utility-maximizing event stream suppression.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465305">Paper Link</a>】    【Pages】:589-600</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Di">Di Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/He:Yeye">Yeye He</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Rundensteiner:Elke_A=">Elke A. Rundensteiner</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/Naughton:Jeffrey_F=">Jeffrey F. Naughton</a></p>
<p>【Abstract】:
Complex Event Processing (CEP) has emerged as a technology for monitoring event streams in search of user specified event patterns. When a CEP system is deployed in sensitive environments the user may wish to mitigate leaks of private information while ensuring that useful nonsensitive patterns are still reported. In this paper we consider how to suppress events in a stream to reduce the disclosure of sensitive patterns while maximizing the detection of nonsensitive patterns. We first formally define the problem of utility-maximizing event suppression with privacy preferences, and analyze its computational hardness. We then design a suite of real-time solutions to solve this problem. Our first solution optimally solves the problem at the event-type level. The second solution, at the event-instance level, further optimizes the event-type level solution by exploiting runtime event distributions using advanced pattern match cardinality estimation techniques. Our user study and experimental evaluation over both real-world and synthetic event streams show that our algorithms are effective in maximizing utility yet still efficient enough to offer near real-time system responsiveness.</p>
<p>【Keywords】:
cep; privacy; utility</p>
<h3 id="51. ε-Matching: event processing over noisy sequences in real time.">51. ε-Matching: event processing over noisy sequences in real time.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463715">Paper Link</a>】    【Pages】:601-612</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Li:Zheng">Zheng Li</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Ge:Tingjian">Tingjian Ge</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Chen:Cindy_X=">Cindy X. Chen</a></p>
<p>【Abstract】:
Regular expression matching over sequences in real time is a crucial task in complex event processing on data streams. Given that such data sequences are often noisy and errors have temporal and spatial correlations, performing regular expression matching effectively and efficiently is a challenging task. Instead of the traditional approach of learning a distribution of the stream first and then processing queries, we propose a new approach that efficiently does the matching based on an error model. In particular, our algorithms are based on the realistic Markov chain error model, and report all matching paths to trace relevant basic events that trigger the matching. This is much more informative than a single matching path. We also devise algorithms to efficiently return only top-k matching paths, and to handle negations in an extended regular expression. Finally, we conduct a comprehensive experimental study to evaluate our algorithms using real datasets.</p>
<p>【Keywords】:
complex event processing; noisy stream; pattern matching</p>
<h2 id="Research session 18: systems, performance III    3">Research session 18: systems, performance III    3</h2>
<h3 id="52. Toward practical query pricing with QueryMarket.">52. Toward practical query pricing with QueryMarket.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465335">Paper Link</a>】    【Pages】:613-624</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/k/Koutris:Paraschos">Paraschos Koutris</a> ; <a href="http://dblp.uni-trier.de/pers/hd/u/Upadhyaya:Prasang">Prasang Upadhyaya</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Balazinska:Magdalena">Magdalena Balazinska</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Howe:Bill">Bill Howe</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Suciu:Dan">Dan Suciu</a></p>
<p>【Abstract】:
We develop a new pricing system, QueryMarket, for flexible query pricing in a data market based on an earlier theoretical framework (Koutris et al., PODS 2012). To build such a system, we show how to use an Integer Linear Programming formulation of the pricing problem for a large class of queries, even when pricing is computationally hard. Further, we leverage query history to avoid double charging when queries purchased over time have overlapping information, or when the database is updated. We then present a technique that fairly shares revenue when multiple sellers are involved. Finally, we implement our approach in a prototype and evaluate its performance on several query workloads.</p>
<p>【Keywords】:
data pricing; integer linear programming</p>
<h3 id="53. Generalized scale independence through incremental precomputation.">53. Generalized scale independence through incremental precomputation.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465333">Paper Link</a>】    【Pages】:625-636</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Armbrust:Michael">Michael Armbrust</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Liang:Eric">Eric Liang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kraska:Tim">Tim Kraska</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Fox:Armando">Armando Fox</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Franklin:Michael_J=">Michael J. Franklin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Patterson:David_A=">David A. Patterson</a></p>
<p>【Abstract】:
Developers of rapidly growing applications must be able to anticipate potential scalability problems before they cause performance issues in production environments. A new type of data independence, called scale independence, seeks to address this challenge by guaranteeing a bounded amount of work is required to execute all queries in an application, independent of the size of the underlying data. While optimization strategies have been developed to provide these guarantees for the class of queries that are scale-independent when executed using simple indexes, there are important queries for which such techniques are insufficient. Executing these more complex queries scale-independently requires precomputation using incrementally-maintained materialized views. However, since this precomputation effectively shifts some of the query processing burden from execution time to insertion time, a scale-independent system must be careful to ensure that storage and maintenance costs do not threaten scalability. In this paper, we describe a scale-independent view selection and maintenance system, which uses novel static analysis techniques that ensure that created views do not themselves become scaling bottlenecks. Finally, we present an empirical analysis that includes all the queries from the TPC-W benchmark and validates our implementation's ability to maintain nearly constant high-quantile query and update latency even as an application scales to hundreds of machines.</p>
<p>【Keywords】:
materialized view selection; scalability; scale independence</p>
<h3 id="54. Simulation of database-valued markov chains using SimSQL.">54. Simulation of database-valued markov chains using SimSQL.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465283">Paper Link</a>】    【Pages】:637-648</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/c/Cai:Zhuhua">Zhuhua Cai</a> ; <a href="http://dblp.uni-trier.de/pers/hd/v/Vagena:Zografoula">Zografoula Vagena</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Perez:Luis_Leopoldo">Luis Leopoldo Perez</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Arumugam:Subramanian">Subramanian Arumugam</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Haas:Peter_J=">Peter J. Haas</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Jermaine:Christopher_M=">Christopher M. Jermaine</a></p>
<p>【Abstract】:
This paper describes the SimSQL system, which allows for SQLbased specification, simulation, and querying of database-valued Markov chains, i.e., chains whose value at any time step comprises the contents of an entire database. SimSQL extends the earlier Monte Carlo database system (MCDB), which permitted Monte Carlo simulation of static database-valued random variables. Like MCDB, SimSQL uses user-specified "VG functions" to generate the simulated data values that are the building blocks of a simulated database. The enhanced functionality of SimSQL is enabled by the ability to parametrize VG functions using stochastic tables, so that one stochastic database can be used to parametrize the generation of another stochastic database, which can parametrize another, and so on. Other key extensions include the ability to explicitly define recursive versions of a stochastic table and the ability to execute the simulation in a MapReduce environment. We focus on applying SimSQL to Bayesian machine learning.</p>
<p>【Keywords】:
databases; machine learning; markov chains</p>
<h2 id="Research session 19: privacy    3">Research session 19: privacy    3</h2>
<h3 id="55. Recursive mechanism: towards node differential privacy and unrestricted joins.">55. Recursive mechanism: towards node differential privacy and unrestricted joins.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465304">Paper Link</a>】    【Pages】:653-664</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/c/Chen:Shixi">Shixi Chen</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhou:Shuigeng">Shuigeng Zhou</a></p>
<p>【Abstract】:
Existing differential privacy (DP) studies mainly consider aggregation on data sets where each entry corresponds to a particular participant to be protected. In many situations, a user may pose a relational algebra query on a database with sensitive data, and desire differentially private aggregation on the result of the query. However, no existing work is able to release such aggregation when the query contains unrestricted join operations. This severely limits the applications of existing DP techniques because many data analysis tasks require unrestricted joins. One example is subgraph counting on a graph. Furthermore, existing methods for differentially private subgraph counting support only edge DP and are subject to very simple subgraphs. Until recent, whether any nontrivial graph statistics can be released with reasonable accuracy for arbitrary kind of input graphs under node DP was still an open problem. In this paper, we propose a novel differentially private mechanism that supports unrestricted joins, to release an approximation of a linear statistic of the result of some positive relational algebra calculation over a sensitive database. The error bound of the approximate answer is roughly proportional to the empirical sensitivity of the query --- a new notion that measures the maximum possible change to the query answer when a participant withdraws its data from the sensitive database. For subgraph counting, our mechanism provides a solution to achieve node DP, for any kind of subgraphs.</p>
<p>【Keywords】:
differential privacy; node differential privacy;; query processing</p>
<h3 id="56. PrivGene: differentially private model fitting using genetic algorithms.">56. PrivGene: differentially private model fitting using genetic algorithms.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465330">Paper Link</a>】    【Pages】:665-676</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Jun">Jun Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/x/Xiao:Xiaokui">Xiaokui Xiao</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yang:Yin">Yin Yang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Zhenjie">Zhenjie Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Winslett:Marianne">Marianne Winslett</a></p>
<p>【Abstract】:
epsilon-differential privacy is rapidly emerging as the state-of-the-art scheme for protecting individuals' privacy in published analysis results over sensitive data. The main idea is to perform random perturbations on the analysis results, such that any individual's presence in the data has negligible impact on the randomized results. This paper focuses on analysis tasks that involve model fitting, i.e., finding the parameters of a statistical model that best fit the dataset. For such tasks, the quality of the differentially private results depends upon both the effectiveness of the model fitting algorithm, and the amount of perturbations required to satisfy the privacy guarantees. Most previous studies start from a state-of-the-art, non-private model fitting algorithm, and develop a differentially private version. Unfortunately, many model fitting algorithms require intensive perturbations to satisfy -differential privacy, leading to poor overall result quality. Motivated by this, we propose PrivGene, a general-purpose differentially private model fitting solution based on genetic algorithms (GA). PrivGene needs significantly less perturbations than previous methods, and it achieves higher overall result quality, even for model fitting tasks where GA is not the first choice without privacy considerations. Further, PrivGene performs the random perturbations using a novel technique called the enhanced exponential mechanism, which improves over the exponential mechanism by exploiting the special properties of model fitting tasks. As case studies, we apply PrivGene to three common analysis tasks involving model fitting: logistic regression, SVM classification, and k-means clustering. Extensive experiments using real data confirm the high result quality of PrivGene, and its superiority over existing methods.</p>
<p>【Keywords】:
differential privacy; genetic algorithms; model fitting</p>
<h3 id="57. Information preservation in statistical privacy and bayesian estimation of unattributed histograms.">57. Information preservation in statistical privacy and bayesian estimation of unattributed histograms.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463721">Paper Link</a>】    【Pages】:677-688</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Lin:Bing=Rong">Bing-Rong Lin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kifer:Daniel">Daniel Kifer</a></p>
<p>【Abstract】:
In statistical privacy, utility refers to two concepts: information preservation -- how much statistical information is retained by a sanitizing algorithm, and usability -- how (and with how much difficulty) does one extract this information to build statistical models, answer queries, etc. Some scenarios incentivize a separation between information preservation and usability, so that the data owner first chooses a sanitizing algorithm to maximize a measure of information preservation and, afterward, the data consumers process the sanitized output according to their needs [22, 46]. We analyze a variety of utility measures and show that the average (over possible outputs of the sanitizer) error of Bayesian decision makers forms the unique class of utility measures that satisfy three axioms related to information preservation. The axioms are agnostic to Bayesian concepts such as subjective probabilities and hence strengthen support for Bayesian views in privacy research. In particular, this result connects information preservation to aspects of usability -- if the information preservation of a sanitizing algorithm should be measured as the average error of a Bayesian decision maker, shouldn't Bayesian decision theory be a good choice when it comes to using the sanitized outputs for various purposes? We put this idea to the test in the unattributed histogram problem where our decision- theoretic post-processing algorithm empirically outperforms previously proposed approaches.</p>
<p>【Keywords】:
decision theory; differential privacy; privacy; utility</p>
<h2 id="Research session 20: spatial databases II    3">Research session 20: spatial databases II    3</h2>
<h3 id="58. Collective spatial keyword queries: a distance owner-driven approach.">58. Collective spatial keyword queries: a distance owner-driven approach.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465275">Paper Link</a>】    【Pages】:689-700</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Long:Cheng">Cheng Long</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wong:Raymond_Chi=Wing">Raymond Chi-Wing Wong</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Ke">Ke Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Fu:Ada_Wai=Chee">Ada Wai-Chee Fu</a></p>
<p>【Abstract】:
Recently, spatial keyword queries become a hot topic in the literature. One example of these queries is the collective spatial keyword query (CoSKQ) which is to find a set of objects in the database such that it covers a set of given keywords collectively and has the smallest cost. Unfortunately, existing exact algorithms have severe scalability problems and existing approximate algorithms, though scalable, cannot guarantee near-to-optimal solutions. In this paper, we study the CoSKQ problem and address the above issues. Firstly, we consider the CoSKQ problem using an existing cost measurement called the maximum sum cost. This problem is called MaxSum-CoSKQ and is known to be NP-hard. We observe that the maximum sum cost of a set of objects is dominated by at most three objects which we call the distance owners of the set. Motivated by this, we propose a distance owner-driven approach which involves two algorithms: one is an exact algorithm which runs faster than the best-known existing algorithm by several orders of magnitude and the other is an approximate algorithm which improves the best-known constant approximation factor from 2 to 1.375. Secondly, we propose a new cost measurement called diameter cost and CoSKQ with this measurement is called Dia-CoSKQ. We prove that Dia-CoSKQ is NP-hard. With the same distance owner-driven approach, we design two algorithms for Dia-CoSKQ: one is an exact algorithm which is efficient and scalable and the other is an approximate algorithm which gives a √3-factor approximation. We conducted extensive experiments on real datasets which verified that the proposed exact algorithms are scalable and the proposed approximate algorithms return near-to-optimal solutions.</p>
<p>【Keywords】:
distance owner-driven approach; spatial keyword querying</p>
<h3 id="59. TOUCH: in-memory spatial join by hierarchical data-oriented partitioning.">59. TOUCH: in-memory spatial join by hierarchical data-oriented partitioning.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463700">Paper Link</a>】    【Pages】:701-712</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/n/Nobari:Sadegh">Sadegh Nobari</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tauheed:Farhan">Farhan Tauheed</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Heinis:Thomas">Thomas Heinis</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Karras:Panagiotis">Panagiotis Karras</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bressan:St=eacute=phane">Stéphane Bressan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Ailamaki:Anastasia">Anastasia Ailamaki</a></p>
<p>【Abstract】:
Efficient spatial joins are pivotal for many applications and particularly important for geographical information systems or for the simulation sciences where scientists work with spatial models. Past research has primarily focused on disk-based spatial joins; efficient in-memory approaches, however, are important for two reasons: a) main memory has grown so large that many datasets fit in it and b) the in-memory join is a very time-consuming part of all disk-based spatial joins. In this paper we develop TOUCH, a novel in-memory spatial join algorithm that uses hierarchical data-oriented space partitioning, thereby keeping both its memory footprint and the number of comparisons low. Our results show that TOUCH outperforms known in-memory spatial-join algorithms as well as in-memory implementations of disk-based join approaches. In particular, it has a one order of magnitude advantage over the memory-demanding state of the art in terms of number of comparisons (i.e., pairwise object comparisons), as well as execution time, while it is two orders of magnitude faster when compared to approaches with a similar memory footprint. Furthermore, TOUCH is more scalable than competing approaches as data density grows.</p>
<p>【Keywords】:
indexing; scalable algorithms; spatial joins; touch</p>
<h3 id="60. Finding time period-based most frequent path in big trajectory data.">60. Finding time period-based most frequent path in big trajectory data.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465287">Paper Link</a>】    【Pages】:713-724</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Luo:Wuman">Wuman Luo</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tan:Haoyu">Haoyu Tan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Chen_0002:Lei">Lei Chen</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/Ni:Lionel_M=">Lionel M. Ni</a></p>
<p>【Abstract】:
The rise of GPS-equipped mobile devices has led to the emergence of big trajectory data. In this paper, we study a new path finding query which finds the most frequent path (MFP) during user-specified time periods in large-scale historical trajectory data. We refer to this query as time period-based MFP (TPMFP). Specifically, given a time period T, a source v_s and a destination v_d, TPMFP searches the MFP from v_s to v_d during T. Though there exist several proposals on defining MFP, they only consider a fixed time period. Most importantly, we find that none of them can well reflect people's common sense notion which can be described by three key properties, namely suffix-optimal (i.e., any suffix of an MFP is also an MFP), length-insensitive (i.e., MFP should not favor shorter or longer paths), and bottleneck-free (i.e., MFP should not contain infrequent edges). The TPMFP with the above properties will reveal not only common routing preferences of the past travelers, but also take the time effectiveness into consideration. Therefore, our first task is to give a TPMFP definition that satisfies the above three properties. Then, given the comprehensive TPMFP definition, our next task is to find TPMFP over huge amount of trajectory data efficiently. Particularly, we propose efficient search algorithms together with novel indexes to speed up the processing of TPMFP. To demonstrate both the effectiveness and the efficiency of our approach, we conduct extensive experiments using a real dataset containing over 11 million trajectories.</p>
<p>【Keywords】:
big trajectory data; path finding</p>
<h2 id="Research session 21: data streams    3">Research session 21: data streams    3</h2>
<h3 id="61. Integrating scale out and fault tolerance in stream processing using operator state management.">61. Integrating scale out and fault tolerance in stream processing using operator state management.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465282">Paper Link</a>】    【Pages】:725-736</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/f/Fernandez:Raul_Castro">Raul Castro Fernandez</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Migliavacca:Matteo">Matteo Migliavacca</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kalyvianaki:Evangelia">Evangelia Kalyvianaki</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Pietzuch:Peter">Peter Pietzuch</a></p>
<p>【Abstract】:
As users of "big data" applications expect fresh results, we witness a new breed of stream processing systems (SPS) that are designed to scale to large numbers of cloud-hosted machines. Such systems face new challenges: (i) to benefit from the "pay-as-you-go" model of cloud computing, they must scale out on demand, acquiring additional virtual machines (VMs) and parallelising operators when the workload increases; (ii) failures are common with deployments on hundreds of VMs-systems must be fault-tolerant with fast recovery times, yet low per-machine overheads. An open question is how to achieve these two goals when stream queries include stateful operators, which must be scaled out and recovered without affecting query results. Our key idea is to expose internal operator state explicitly to the SPS through a set of state management primitives. Based on them, we describe an integrated approach for dynamic scale out and recovery of stateful operators. Externalised operator state is checkpointed periodically by the SPS and backed up to upstream VMs. The SPS identifies individual operator bottlenecks and automatically scales them out by allocating new VMs and partitioning the checkpointed state. At any point, failed operators are recovered by restoring checkpointed state on a new VM and replaying unprocessed tuples. We evaluate this approach with the Linear Road Benchmark on the Amazon EC2 cloud platform and show that it can scale automatically to a load factor of L=350 with 50 VMs, while recovering quickly from failures.</p>
<p>【Keywords】:
fault tolerance; scalability; stateful stream processing</p>
<h3 id="62. Quantiles over data streams: an experimental study.">62. Quantiles over data streams: an experimental study.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465312">Paper Link</a>】    【Pages】:737-748</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Lu">Lu Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Luo:Ge">Ge Luo</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yi:Ke">Ke Yi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Cormode:Graham">Graham Cormode</a></p>
<p>【Abstract】:
A fundamental problem in data management and analysis is to generate descriptions of the distribution of data. It is most common to give such descriptions in terms of the cumulative distribution, which is characterized by the quantiles of the data. The design and engineering of efficient methods to find these quantiles has attracted much study, especially in the case where the data is described incrementally, and we must compute the quantiles in an online, streaming fashion. Yet while such algorithms have proved to be tremendously useful in practice, there has been limited formal comparison of the competing methods, and no comprehensive study of their performance. In this paper, we remedy this deficit by providing a taxonomy of different methods, and describe efficient implementations. In doing so, we propose and analyze variations that have not been explicitly studied before, yet which turn out to perform the best. To illustrate this, we provide detailed experimental comparisons demonstrating the tradeoffs between space, time, and accuracy for quantile computation.</p>
<p>【Keywords】:
data stream algorithms; quantiles</p>
<h3 id="63. An efficient query indexing mechanism for filtering geo-textual data.">63. An efficient query indexing mechanism for filtering geo-textual data.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465328">Paper Link</a>】    【Pages】:749-760</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/c/Chen:Lisi">Lisi Chen</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Cong:Gao">Gao Cong</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Cao:Xin">Xin Cao</a></p>
<p>【Abstract】:
Massive amount of data that are geo-tagged and associated with text information are being generated at an unprecedented scale. Users may want to be notified of interesting geo-textual objects during a period of time. For example, a user may want to be informed when tweets containing term "garage sale" are posted within 5 km of the user's home in the next 72 hours. In this paper, for the first time we study the problem of matching a stream of incoming Boolean Range Continuous queries over a stream of incoming geo-textual objects in real time. We develop a new system for addressing the problem. In particular, we propose a hybrid index, called IQ-tree, and novel cost models for managing a stream of incoming Boolean Range Continuous queries. We also propose algorithms for matching the queries with incoming geo-textual objects based on the index. Results of empirical studies with implementations of the proposed techniques demonstrate that the paper's proposals offer scalability and are capable of excellent performance.</p>
<p>【Keywords】:
filtering; geo-textual data; query index; subscribing</p>
<h2 id="Research session 22: distributed systems    3">Research session 22: distributed systems    3</h2>
<h3 id="64. Bolt-on causal consistency.">64. Bolt-on causal consistency.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465279">Paper Link</a>】    【Pages】:761-772</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Bailis:Peter">Peter Bailis</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Ghodsi:Ali">Ali Ghodsi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Hellerstein:Joseph_M=">Joseph M. Hellerstein</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Stoica:Ion">Ion Stoica</a></p>
<p>【Abstract】:
We consider the problem of separating consistency-related safety properties from availability and durability in distributed data stores via the application of a "bolt-on" shim layer that upgrades the safety of an underlying general-purpose data store. This shim provides the same consistency guarantees atop a wide range of widely deployed but often inflexible stores. As causal consistency is one of the strongest consistency models that remain available during system partitions, we develop a shim layer that upgrades eventually consistent stores to provide convergent causal consistency. Accordingly, we leverage widely deployed eventually consistent infrastructure as a common substrate for providing causal guarantees. We describe algorithms and shim implementations that are suitable for a large class of application-level causality relationships and evaluate our techniques using an existing, production-ready data store and with real-world explicit causality relationships.</p>
<p>【Keywords】:
causal consistency; eventual consistency; separation of concerns</p>
<h3 id="65. RTP: robust tenant placement for elastic in-memory database clusters.">65. RTP: robust tenant placement for elastic in-memory database clusters.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465302">Paper Link</a>】    【Pages】:773-784</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Schaffner:Jan">Jan Schaffner</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Januschowski:Tim">Tim Januschowski</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kercher:Megan">Megan Kercher</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kraska:Tim">Tim Kraska</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Plattner:Hasso">Hasso Plattner</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Franklin:Michael_J=">Michael J. Franklin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Jacobs:Dean">Dean Jacobs</a></p>
<p>【Abstract】:
In the cloud services industry, a key issue for cloud operators is to minimize operational costs. In this paper, we consider algorithms that elastically contract and expand a cluster of in-memory databases depending on tenants' behavior over time while maintaining response time guarantees. We evaluate our tenant placement algorithms using traces obtained from one of SAP's production on-demand applications. Our experiments reveal that our approach lowers operating costs for the database cluster of this application by a factor of 2.2 to 10, measured in Amazon EC2 hourly rates, in comparison to the state of the art. In addition, we carefully study the trade-off between cost savings obtained by continuously migrating tenants and the robustness of servers towards load spikes and failures.</p>
<p>【Keywords】:
cloud computing; data placement; fault tolerance; in-memory databases; multi tenancy</p>
<h3 id="66. Inter-media hashing for large-scale retrieval from heterogeneous data sources.">66. Inter-media hashing for large-scale retrieval from heterogeneous data sources.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465274">Paper Link</a>】    【Pages】:785-796</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Song:Jingkuan">Jingkuan Song</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yang:Yang">Yang Yang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yang:Yi">Yi Yang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Huang:Zi">Zi Huang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shen:Heng_Tao">Heng Tao Shen</a></p>
<p>【Abstract】:
In this paper, we present a new multimedia retrieval paradigm to innovate large-scale search of heterogenous multimedia data. It is able to return results of different media types from heterogeneous data sources, e.g., using a query image to retrieve relevant text documents or images from different data sources. This utilizes the widely available data from different sources and caters for the current users' demand of receiving a result list simultaneously containing multiple types of data to obtain a comprehensive understanding of the query's results. To enable large-scale inter-media retrieval, we propose a novel inter-media hashing (IMH) model to explore the correlations among multiple media types from different data sources and tackle the scalability issue. To this end, multimedia data from heterogeneous data sources are transformed into a common Hamming space, in which fast search can be easily implemented by XOR and bit-count operations. Furthermore, we integrate a linear regression model to learn hashing functions so that the hash codes for new data points can be efficiently generated. Experiments conducted on real-world large-scale multimedia datasets demonstrate the superiority of our proposed method compared with state-of-the-art techniques.</p>
<p>【Keywords】:
hashing; heterogeneous data source; indexing; inter-media retrieval</p>
<h2 id="Research session 23: data mining    3">Research session 23: data mining    3</h2>
<h3 id="67. Mind the gap: large-scale frequent sequence mining.">67. Mind the gap: large-scale frequent sequence mining.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465285">Paper Link</a>】    【Pages】:797-808</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Miliaraki:Iris">Iris Miliaraki</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Berberich:Klaus">Klaus Berberich</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Gemulla:Rainer">Rainer Gemulla</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zoupanos:Spyros">Spyros Zoupanos</a></p>
<p>【Abstract】:
Frequent sequence mining is one of the fundamental building blocks in data mining. While the problem has been extensively studied, few of the available techniques are sufficiently scalable to handle datasets with billions of sequences; such large-scale datasets arise, for instance, in text mining and session analysis. In this paper, we propose MG-FSM, a scalable algorithm for frequent sequence mining on MapReduce. MG-FSM can handle so-called "gap constraints", which can be used to limit the output to a controlled set of frequent sequences. At its heart, MG-FSM partitions the input database in a way that allows us to mine each partition independently using any existing frequent sequence mining algorithm. We introduce the notion of w-equivalency, which is a generalization of the notion of a "projected database" used by many frequent pattern mining algorithms. We also present a number of optimization techniques that minimize partition size, and therefore computational and communication costs, while still maintaining correctness. Our experimental study in the context of text mining suggests that MG-FSM is significantly more efficient and scalable than alternative approaches.</p>
<p>【Keywords】:
data mining; frequent sequence mining; maprecuce</p>
<h3 id="68. Reverse engineering complex join queries.">68. Reverse engineering complex join queries.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465320">Paper Link</a>】    【Pages】:809-820</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Meihui">Meihui Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/e/Elmeleegy:Hazem">Hazem Elmeleegy</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Procopiuc:Cecilia_M=">Cecilia M. Procopiuc</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Srivastava:Divesh">Divesh Srivastava</a></p>
<p>【Abstract】:
We study the following problem: Given a database D with schema G and an output table Out, compute a join query Q that generates OUT from D. A simpler variant allows Q to return a superset of Out. This problem has numerous applications, both by itself, and as a building block for other problems. Related prior work imposes conditions on the structure of Q which are not always consistent with the application, but simplify computation. We discuss several natural SQL queries that do not satisfy these conditions and cannot be discovered by prior work. In this paper, we propose an efficient algorithm that discovers queries with arbitrary join graphs. A crucial insight is that any graph can be characterized by the combination of a simple structure, called a star, and a series of merge steps over the star. The merge steps define a lattice over graphs derived from the same star. This allows us to explore the set of candidate solutions in a principled way and quickly prune out a large number of infeasible graphs. We also design several optimizations that significantly reduce the running time. Finally, we conduct an extensive experimental study over a benchmark database and show that our approach is scalable and accurately discovers complex join queries.</p>
<p>【Keywords】:
query join graph; query lattice; sql query discovery</p>
<h3 id="69. A direct mining approach to efficient constrained graph pattern discovery.">69. A direct mining approach to efficient constrained graph pattern discovery.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463723">Paper Link</a>】    【Pages】:821-832</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/z/Zhu:Feida">Feida Zhu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Zequn">Zequn Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/q/Qu:Qiang">Qiang Qu</a></p>
<p>【Abstract】:
Despite the wealth of research on frequent graph pattern mining, how to efficiently mine the complete set of those with constraints still poses a huge challenge to the existing algorithms mainly due to the inherent bottleneck in the mining paradigm. In essence, mining requests with explicitly-specified constraints cannot be handled in a way that is direct and precise. In this paper, we propose a direct mining framework to solve the problem and illustrate our ideas in the context of a particular type of constrained frequent patterns --- the "skinny" patterns, which are graph patterns with a long backbone from which short twigs branch out. These patterns, which we formally define as l-long δ-skinny patterns, are able to reveal insightful spatial and temporal trajectory patterns in mobile data mining, information diffusion, adoption propagation, and many others. Based on the key concept of a canonical diameter, we develop SkinnyMine, an efficient algorithm to mine all the l-long δ-skinny patterns guaranteeing both the completeness of our mining result as well as the unique generation of each target pattern. We also present a general direct mining framework together with two properties of reducibility and continuity for qualified constraints. Our experiments on both synthetic and real data demonstrate the effectiveness and scalability of our approach.</p>
<p>【Keywords】:
constrained pattern mining; direct mining; frequent graph pattern mining; skinny pattern</p>
<h2 id="Research session 24: road networks and trajectories    3">Research session 24: road networks and trajectories    3</h2>
<h3 id="70. Calibrating trajectory data for similarity-based analysis.">70. Calibrating trajectory data for similarity-based analysis.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465303">Paper Link</a>】    【Pages】:833-844</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Su:Han">Han Su</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zheng:Kai">Kai Zheng</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Haozhou">Haozhou Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Huang:Jiamin">Jiamin Huang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhou:Xiaofang">Xiaofang Zhou</a></p>
<p>【Abstract】:
Due to the prevalence of GPS-enabled devices and wireless communications technologies, spatial trajectories that describe the movement history of moving objects are being generated and accumulated at an unprecedented pace. Trajectory data in a database are intrinsically heterogeneous, as they represent discrete approximations of original continuous paths derived using different sampling strategies and different sampling rates. Such heterogeneity can have a negative impact on the effectiveness of trajectory similarity measures, which are the basis of many crucial trajectory processing tasks. In this paper, we pioneer a systematic approach to trajectory calibration that is a process to transform a heterogeneous trajectory dataset to one with (almost) unified sampling strategies. Specifically, we propose an anchor-based calibration system that aligns trajectories to a set of anchor points, which are fixed locations independent of trajectory data. After examining four different types of anchor points for the purpose of building a stable reference system, we propose a geometry-based calibration approach that considers the spatial relationship between anchor points and trajectories. Then a more advanced model-based calibration method is presented, which exploits the power of machine learning techniques to train inference models from historical trajectory data to improve calibration effectiveness. Finally, we conduct extensive experiments using real trajectory datasets to demonstrate the effectiveness and efficiency of the proposed calibration system.</p>
<p>【Keywords】:
similarity measure; trajectory calibration; trajectory database</p>
<h3 id="71. On optimal worst-case matching.">71. On optimal worst-case matching.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465321">Paper Link</a>】    【Pages】:845-856</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Long:Cheng">Cheng Long</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wong:Raymond_Chi=Wing">Raymond Chi-Wing Wong</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yu:Philip_S=">Philip S. Yu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Jiang:Minhao">Minhao Jiang</a></p>
<p>【Abstract】:
Bichromatic reverse nearest neighbor (BRNN) queries have been studied extensively in the literature of spatial databases. Given a set P of service-providers and a set O of customers, a BRNN query is to find which customers in O are "interested" in a given service-provider in P. Recently, it has been found that this kind of queries lacks the consideration of the capacities of service-providers and the demands of customers. In order to address this issue, some spatial matching problems have been proposed, which, however, cannot be used for some real-life applications like emergency facility allocation where the maximum matching cost (or distance) should be minimized. In this paper, we propose a new problem called Spatial Matching for Minimizing Maximum matching distance (SPM-MM). Then, we design two algorithms for SPM-MM, Threshold-Adapt and Swap-Chain. Threshold-Adapt is simple and easy to understand but not scalable to large datasets due to its relatively high time/space complexity. Swap-Chain, which follows a fundamentally different idea from Threshold-Adapt, runs faster than Threshold-Adapt by orders of magnitude and uses significantly less memory. We conducted extensive empirical studies which verified the efficiency and scalability of Swap-Chain.</p>
<p>【Keywords】:
bottleneck matching; optimal worst-case spatial matching</p>
<h3 id="72. Shortest path and distance queries on road networks: towards bridging theory and practice.">72. Shortest path and distance queries on road networks: towards bridging theory and practice.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465277">Paper Link</a>】    【Pages】:857-868</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/z/Zhu:Andy_Diwen">Andy Diwen Zhu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Ma:Hui">Hui Ma</a> ; <a href="http://dblp.uni-trier.de/pers/hd/x/Xiao:Xiaokui">Xiaokui Xiao</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Luo:Siqiang">Siqiang Luo</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tang:Youze">Youze Tang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhou:Shuigeng">Shuigeng Zhou</a></p>
<p>【Abstract】:
Given two locations s and t in a road network, a distance query returns the minimum network distance from s to t, while a shortest path query computes the actual route that achieves the minimum distance. These two types of queries find important applications in practice, and a plethora of solutions have been proposed in past few decades. The existing solutions, however, are optimized for either practical or asymptotic performance, but not both. In particular, the techniques with enhanced practical efficiency are mostly heuristic-based, and they offer unattractive worst-case guarantees in terms of space and time. On the other hand, the methods that are worst-case efficient often entail prohibitive preprocessing or space overheads, which render them inapplicable for the large road networks (with millions of nodes) commonly used in modern map applications. This paper presents Arterial Hierarchy (AH), an index structure that narrows the gap between theory and practice in answering shortest path and distance queries on road networks. On the theoretical side, we show that, under a realistic assumption, AH answers any distance query in Õ(log α) time, where α = dmax/dmin, and dmax (resp. dmin) is the largest (resp. smallest) L∞ distance between any two nodes in the road network. In addition, any shortest path query can be answered in Õ(k + log α) time, where k is the number of nodes on the shortest path. On the practical side, we experimentally evaluate AH on a large set of real road networks with up to twenty million nodes, and we demonstrate that (i) AH outperforms the state of the art in terms of query time, and (ii) its space and pre-computation overheads are moderate.</p>
<p>【Keywords】:
algorithms; road network; shortest path</p>
<h2 id="Research session 25: security    2">Research session 25: security    2</h2>
<h3 id="73. Fine-grained disclosure control for app ecosystems.">73. Fine-grained disclosure control for app ecosystems.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2467798">Paper Link</a>】    【Pages】:869-880</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Bender:Gabriel">Gabriel Bender</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kot:Lucja">Lucja Kot</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Gehrke:Johannes">Johannes Gehrke</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Koch_0001:Christoph">Christoph Koch</a></p>
<p>【Abstract】:
The modern computing landscape contains an increasing number of app ecosystems, where users store personal data on platforms such as Facebook or smartphones. APIs enable third-party applications (apps) to utilize that data. A key concern associated with app ecosystems is the confidentiality of user data. In this paper, we develop a new model of disclosure in app ecosystems. In contrast with previous solutions, our model is data-derived and semantically meaningful. Information disclosure is modeled in terms of a set of distinguished security views. Each query is labeled with the precise set of security views that is needed to answer it, and these labels drive policy decisions. We explain how our disclosure model can be used in practice and provide algorithms for labeling conjunctive queries for the case of single-atom security views. We show that our approach is useful by demonstrating the scalability of our algorithms and by applying it to the real-world disclosure control system used by Facebook.</p>
<p>【Keywords】:
app ecosystems; database security; view rewriting</p>
<h3 id="74. Lightweight authentication of linear algebraic queries on data streams.">74. Lightweight authentication of linear algebraic queries on data streams.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465281">Paper Link</a>】    【Pages】:881-892</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/p/Papadopoulos:Stavros">Stavros Papadopoulos</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Cormode:Graham">Graham Cormode</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Deligiannakis:Antonios">Antonios Deligiannakis</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Garofalakis:Minos_N=">Minos N. Garofalakis</a></p>
<p>【Abstract】:
We consider a stream outsourcing setting, where a data owner delegates the management of a set of disjoint data streams to an untrusted server. The owner authenticates his streams via signatures. The server processes continuous queries on the union of the streams for clients trusted by the owner. Along with the results, the server sends proofs of result correctness derived from the owner's signatures, which are easily verifiable by the clients. We design novel constructions for a collection of fundamental problems over streams represented as linear algebraic queries. In particular, our basic schemes authenticate dynamic vector sums and dot products, as well as dynamic matrix products. These techniques can be adapted for authenticating a wide range of important operations in streaming environments, including group by queries, joins, in-network aggregation, similarity matching, and event processing. All our schemes are very lightweight, and offer strong cryptographic guarantees derived from formal definitions and proofs. We experimentally confirm the practicality of our schemes.</p>
<p>【Keywords】:
data integrity; data streams; query authentication</p>
<h2 id="Research session 26: indexing    2">Research session 26: indexing    2</h2>
<h3 id="75. Column imprints: a secondary index structure.">75. Column imprints: a secondary index structure.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465306">Paper Link</a>】    【Pages】:893-904</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Sidirourgos:Lefteris">Lefteris Sidirourgos</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kersten:Martin_L=">Martin L. Kersten</a></p>
<p>【Abstract】:
Large scale data warehouses rely heavily on secondary indexes, such as bitmaps and b-trees, to limit access to slow IO devices. However, with the advent of large main memory systems, cache conscious secondary indexes are needed to improve also the transfer bandwidth between memory and cpu. In this paper, we introduce column imprint, a simple but efficient cache conscious secondary index. A column imprint is a collection of many small bit vectors, each indexing the data points of a single cacheline. An imprint is used during query evaluation to limit data access and thus minimize memory traffic. The compression for imprints is cpu friendly and exploits the empirical observation that data often exhibits local clustering or partial ordering as a side-effect of the construction process. Most importantly, column imprint compression remains effective and robust even in the case of unclustered data, while other state-of-the-art solutions fail. We conducted an extensive experimental evaluation to assess the applicability and the performance impact of the column imprints. The storage overhead, when experimenting with real world datasets, is just a few percent over the size of the columns being indexed. The evaluation time for over 40000 range queries of varying selectivity revealed the efficiency of the proposed index compared to zonemaps and bitmaps with WAH compression.</p>
<p>【Keywords】:
columnar databases; secondary index</p>
<h3 id="76. DeltaNI: an efficient labeling scheme for versioned hierarchical data.">76. DeltaNI: an efficient labeling scheme for versioned hierarchical data.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465329">Paper Link</a>】    【Pages】:905-916</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/f/Finis:Jan">Jan Finis</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Brunel:Robert">Robert Brunel</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kemper:Alfons">Alfons Kemper</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/Neumann_0001:Thomas">Thomas Neumann</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/F=auml=rber:Franz">Franz Färber</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/May:Norman">Norman May</a></p>
<p>【Abstract】:
Main-memory database systems are emerging as the new backbone of business applications. Besides flat relational data representations also hierarchical ones are essential for these modern applications; therefore we devise a new indexing and versioning approach for hierarchies that is deeply integrated into the relational kernel. We propose the DeltaNI index as a versioned pendant of the nested intervals (NI) labeling scheme. The index is space- and time-efficient and yields a gapless, fixed-size integer NI labeling for each version while also supporting branching histories. In contrast to a naive NI labeling, it facilitates even complex updates of the tree structure. As many query processing techniques that work on top of the NI labeling have already been proposed, our index can be used as a building block for processing various kinds of queries. We evaluate the performance of the index on large inputs consisting of millions of nodes and thousands of versions. Thereby we show that DeltaNI scales well and can deliver satisfying performance for large business scenarios.</p>
<p>【Keywords】:
database indexing; hierarchical data; hierarchy indexing; labeling schemes; multiversion indexing; nested intervals</p>
<h2 id="Keynote addresses    2">Keynote addresses    2</h2>
<h3 id="77. Big data in capital markets.">77. Big data in capital markets.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2486082">Paper Link</a>】    【Pages】:917-918</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/n/Nazaruk:Alex">Alex Nazaruk</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Rauchman:Michael">Michael Rauchman</a></p>
<p>【Abstract】:
Over the past decade global securities markets have dramatically changed. Evolution of market structure in combination with advances in computer technologies led to emergence of electronic securities trading. Securities transactions that used to be conducted in person and over the phone are now predominantly executed by automated trading systems. This resulted in significant fragmentation of the markets, vast increase in the exchange volumes and even greater increase in the number of orders. In this talk we present and analyze forces behind the wide proliferation of electronic securities trading in US stocks and options markets. We also make a high-level introduction into electronic securities market structure. We discuss trading objectives of different classes of market participants and analyze how their activity affects data volumes. We also present typical securities trading firm data flow and analyze various types of data it uses in its trading operations. We close with the implications this "sea change" has on DBMS requirements in capital markets.</p>
<p>【Keywords】:
big data; capital markets; securities; transactions</p>
<h3 id="78. Managing database technology at enterprise scale.">78. Managing database technology at enterprise scale.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2486083">Paper Link</a>】    【Pages】:919-920</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/y/Yaron:Paul">Paul Yaron</a></p>
<p>【Abstract】:
Paul Yaron is responsible for Non-Mainframe, Relational Database Architecture, Engineering and Strategy for JPMC globally. JP Morgan is a leading financial services firm with assets over $2 trillion, operates 40 major datacenters around the globe, servicing over 60 countries with over 250,000 employees. It partners with 170 regulators and manages 230 Petabytes of data, JPMC depends on over 23,000 database instances to service multiple business units. With a deployment of such scope, JPMC leverages solutions from most major database, security and operating system vendors. This talk will discuss the challenges and strategies of managing the evolving ecosystem of "all data", from information security, to internal virtualization strategies. Engineering reliable globally scalable and compliant data management solutions demands a model for proactively measuring the risk complexity of an ecosystem for expert focus and potential proactive remediation. The research for quantitative measurement of database (or other) ecosystem entropy appears sparse. JPMC is looking to share its ideas in this space with the academic community as the need for such quantitative measures are increasingly important as ecosystems move from islands of single tenant risk into multi-tenant risk clusters.</p>
<p>【Keywords】:
big data; integration; security</p>
<h2 id="Panel    1">Panel    1</h2>
<h3 id="79. We are drowning in a sea of least publishable units (LPUs).">79. We are drowning in a sea of least publishable units (LPUs).</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465345">Paper Link</a>】    【Pages】:921-922</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/d/DeWitt:David_J=">David J. DeWitt</a> ; <a href="http://dblp.uni-trier.de/pers/hd/i/Ilyas:Ihab_F=">Ihab F. Ilyas</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/Naughton:Jeffrey_F=">Jeffrey F. Naughton</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Stonebraker:Michael">Michael Stonebraker</a></p>
<p>【Abstract】:
Our field is drowning in a sea of conference submissions. We assert that the sheer number of papers has begun to seriously hurt the quality of the work that the field is doing and that the field is going to implode unless we take action to remedy the situation. In order to improve the quality of the papers being published we must reduce the number being submitted. This will require a change in the culture of our field where "more" is being equated to "better" by both hiring and promotion committees. In this panel we will explore some ideas for correcting the situation.</p>
<p>【Keywords】:
conference submissions; reviewing practices; tenure expectations</p>
<h2 id="Tutorials    6">Tutorials    6</h2>
<h3 id="80. Rethinking eventual consistency.">80. Rethinking eventual consistency.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465339">Paper Link</a>】    【Pages】:923-928</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Bernstein:Philip_A=">Philip A. Bernstein</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Das:Sudipto">Sudipto Das</a></p>
<p>【Abstract】:
There has been a resurgence of work on replicated, distributed database systems to meet the demands of intermittently-connected clients and of disaster-tolerant databases that span data centers. Many systems weaken the criteria for replica-consistency or isolation, and in some cases add new mechanisms, to improve partition-tolerance, availability, and performance. We present a framework for comparing these criteria and mechanisms, to help architects navigate through this complex design space.</p>
<p>【Keywords】:
eventual consistency; replication</p>
<h3 id="81. Workload management for big data analytics.">81. Workload management for big data analytics.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2467801">Paper Link</a>】    【Pages】:929-932</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Aboulnaga:Ashraf">Ashraf Aboulnaga</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Babu:Shivnath">Shivnath Babu</a></p>
<p>【Abstract】:</p>
<p>【Keywords】:
analytics; mapreduce; parallel database systems; workload management</p>
<h3 id="82. Knowledge harvesting in the big-data era.">82. Knowledge harvesting in the big-data era.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463724">Paper Link</a>】    【Pages】:933-938</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Suchanek:Fabian_M=">Fabian M. Suchanek</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Weikum:Gerhard">Gerhard Weikum</a></p>
<p>【Abstract】:
The proliferation of knowledge-sharing communities such as Wikipedia and the progress in scalable information extraction from Web and text sources have enabled the automatic construction of very large knowledge bases. Endeavors of this kind include projects such as DBpedia, Freebase, KnowItAll, ReadTheWeb, and YAGO. These projects provide automatically constructed knowledge bases of facts about named entities, their semantic classes, and their mutual relationships. They contain millions of entities and hundreds of millions of facts about them. Such world knowledge in turn enables cognitive applications and knowledge-centric services like disambiguating natural-language text, semantic search for entities and relations in Web and enterprise data, and entity-oriented analytics over unstructured contents. Prominent examples of how knowledge bases can be harnessed include the Google Knowledge Graph and the IBM Watson question answering system. This tutorial presents state-of-the-art methods, recent advances, research opportunities, and open challenges along this avenue of knowledge harvesting and its applications. Particular emphasis will be on the twofold role of knowledge bases for big-data analytics: using scalable distributed algorithms for harvesting knowledge from Web and text sources, and leveraging entity-centric knowledge for deeper interpretation of and better intelligence with Big Data.</p>
<p>【Keywords】:
big data; entity recognition; information extraction; knowledge base; ontology; web contents</p>
<h3 id="83. Machine learning for big data.">83. Machine learning for big data.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465338">Paper Link</a>】    【Pages】:939-942</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/c/Condie:Tyson">Tyson Condie</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Mineiro:Paul">Paul Mineiro</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Polyzotis:Neoklis">Neoklis Polyzotis</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Weimer:Markus">Markus Weimer</a></p>
<p>【Abstract】:
Statistical Machine Learning has undergone a phase transition from a pure academic endeavor to being one of the main drivers of modern commerce and science. Even more so, recent results such as those on tera-scale learning [1] and on very large neural networks [2] suggest that scale is an important ingredient in quality modeling. This tutorial introduces current applications, techniques and systems with the aim of cross-fertilizing research between the database and machine learning communities. The tutorial covers current large scale applications of Machine Learning, their computational model and the workflow behind building those. Based on this foundation, we present the current state-of-the-art in systems support in the bulk of the tutorial. We also identify critical gaps in the state-of-the-art. This leads to the closing of the seminar, where we introduce two sets of open research questions: Better systems support for the already established use cases of Machine Learning and support for recent advances in Machine Learning research.</p>
<p>【Keywords】:
big data; databases; machine learning</p>
<h3 id="84. Data management perspectives on business process management: tutorial overview.">84. Data management perspectives on business process management: tutorial overview.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2467802">Paper Link</a>】    【Pages】:943-948</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/h/Hull:Richard">Richard Hull</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Su:Jianwen">Jianwen Su</a> ; <a href="http://dblp.uni-trier.de/pers/hd/v/Vacul=iacute=n:Roman">Roman Vaculín</a></p>
<p>【Abstract】:
Traditional approaches to Business Process Management (BPM) focus primarily on the process aspects, and treat the persistent data accessed and manipulated by the business processes as second class citizens. A recent approach to BPM, based on "business artifacts", is centered on a modeling framework that places data and process on an equal footing. The approach has been shown useful in various application domains, and one variant of business artifacts forms the basis of the emerging OMG Case Management Model and Notation (CMMN) standard. Research results have been developed around conceptual models, enterprise interoperation, business intelligence, and verification. This data-centric approach has the potential to provide the basis for a new generation of BPM technology in support of diverse application, and fueled by the insights into abstraction and data management that have been the hallmark of database research since the 70's.</p>
<p>【Keywords】:
bpm; business artifacts; business process management; data-centric; workflow</p>
<h3 id="85. Data stream warehousing.">85. Data stream warehousing.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465337">Paper Link</a>】    【Pages】:949-952</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/g/Golab:Lukasz">Lukasz Golab</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Johnson:Theodore">Theodore Johnson</a></p>
<p>【Abstract】:</p>
<p>【Keywords】:
data streams; data warehousing; real-time analytics</p>
<h2 id="Demo session 1: data intensive applications    10">Demo session 1: data intensive applications    10</h2>
<h3 id="86. Data-driven neuroscience: enabling breakthroughs via innovative data management.">86. Data-driven neuroscience: enabling breakthroughs via innovative data management.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463677">Paper Link</a>】    【Pages】:953-956</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Stougiannis:Alexandros">Alexandros Stougiannis</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Pavlovic:Mirjana">Mirjana Pavlovic</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tauheed:Farhan">Farhan Tauheed</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Heinis:Thomas">Thomas Heinis</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Ailamaki:Anastasia">Anastasia Ailamaki</a></p>
<p>【Abstract】:
Scientists in all disciplines increasingly rely on simulations to develop a better understanding of the subject they are studying. For example the neuroscientists we collaborate with in the Blue Brain project have started to simulate the brain on a supercomputer. The level of detail of their models is unprecedented as they model details on the subcellular level (e.g., the neurotransmitter). This level of detail, however, also leads to a true data deluge and the neuroscientists have only few tools to efficiently analyze the data. This demonstration showcases three innovative spatial management techniques that have substantial impact on computational neuroscience and other disciplines in that they allow to build, analyze and simulate bigger and more detailed models. More particularly, we demonstrate a tool that integrates three spatial data management techniques that have enabled breakthroughs in neuroscience: FLAT that enables efficient querying of spatial data, SCOUT that allows for fast exploration of spatial data and HiDOP that makes efficient data discovery possible.</p>
<p>【Keywords】:
scientific data management; spatial databases; spatial indexing</p>
<h3 id="87. TsingNUS: a location-based service system towards live city.">87. TsingNUS: a location-based service system towards live city.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463690">Paper Link</a>】    【Pages】:957-960</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Li:Guoliang">Guoliang Li</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Nan">Nan Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhong:Ruicheng">Ruicheng Zhong</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Liu:Sitong">Sitong Liu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Huang:Weihuang">Weihuang Huang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Fan:Ju">Ju Fan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tan:Kian=Lee">Kian-Lee Tan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhou:Lizhu">Lizhu Zhou</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Feng:Jianhua">Jianhua Feng</a></p>
<p>【Abstract】:
We present our system towards live city, called TsingNUS, aiming to provide users with more user-friendly location-aware search experiences. TsingNUS crawls location-based user-generated content from the Web (e.g., Foursquare and Twitter), cleans and integrates them to provide users with rich well-structured data. TsingNUS provides three user-friendly search paradigms: location-aware instant search, location-aware similarity search and direction-aware search. Instant search returns relevant answers instantly as users type in queries letter by letter, which can help users to save typing efforts significantly. Location-aware similarity search enables fuzzy matching between queries and the underlying data, which can tolerate typing errors. The two features boost the search performance and improve the experiences for mobile users who often misspell the keywords due to the limitation of the mobile phone's keyboard. In addition, users have direction-aware search requirements in many applications. For example, a driver on the highway wants to find the nearest gas station or restaurant. She has a search requirement that the answers should be in front of her driving direction. TsingNUS enables direction-aware search to address this problem and allows users to search in specific directions. Moreover, TsingNUS incorporates continuous search to efficiently support continuously moving queries in a client-server system which can reduce the number of queries submitted to the server and communication cost between the client and server. We have implemented and deployed a system which has been commonly used and widely accepted.</p>
<p>【Keywords】:
direction-aware search; instant search; location-aware search</p>
<h3 id="88. WOW: what the world of (data) warehousing can learn from the World of Warcraft.">88. WOW: what the world of (data) warehousing can learn from the World of Warcraft.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465267">Paper Link</a>】    【Pages】:961-964</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/M=uuml=ller:Ren=eacute=">René Müller</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kaldewey:Tim">Tim Kaldewey</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lohman:Guy_M=">Guy M. Lohman</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/McPherson:John">John McPherson</a></p>
<p>【Abstract】:
Although originally designed to accelerate pixel monsters, graphics Processing Units (GPUs) have been used for some time as accelerators for selected data base operations. However, to the best of our knowledge, no one has yet reported building a complete system that allows executing complex analytics queries, much less an entire data warehouse benchmark at realistic scale. In this demo, we showcase such a complete system prototype running on a high-end GPU paired with an IBM storage system that achieves &gt;90% hardware efficiency. Our solution delivers sustainable high throughput for business analytics queries in a realistic scenario, i.e., the Star Schema Benchmark at scale factor 1,000. Attendees can interact with our system through a graphical user interface on a tablet PC. They will be able to experience first hand how queries that require processing more than six billion rows, or 100 GB of data, are answered in less than 20 seconds. The user interface allows submitting queries, live performance monitoring of the current query all the way down to the operator level, and viewing the result once the query completes.</p>
<p>【Keywords】:
gpgpu; hardware acceleration; olap; query processing</p>
<h3 id="89. Rule-based application development using Webdamlog.">89. Rule-based application development using Webdamlog.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465251">Paper Link</a>】    【Pages】:965-968</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Abiteboul:Serge">Serge Abiteboul</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Antoine:Emilien">Emilien Antoine</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Miklau:Gerome">Gerome Miklau</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Stoyanovich:Julia">Julia Stoyanovich</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Testard:Jules">Jules Testard</a></p>
<p>【Abstract】:
We present the WebdamLog system for managing distributed data on the Web in a peer-to-peer manner. We demonstrate the main features of the system through an application called Wepic for sharing pictures between attendees of the sigmod conference. Using Wepic, the attendees will be able to share, download, rate and annotate pictures in a highly decentralized manner. We show how WebdamLog handles heterogeneity of the devices and services used to share data in such a Web setting. We exhibit the simple rules that define the Wepic application and show how to easily modify the Wepic application.</p>
<p>【Keywords】:
datalog; declarative; peer to peer</p>
<h3 id="90. Speeding up database applications with Pyxis.">90. Speeding up database applications with Pyxis.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465265">Paper Link</a>】    【Pages】:969-972</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/c/Cheung:Alvin">Alvin Cheung</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Arden:Owen">Owen Arden</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Madden:Samuel">Samuel Madden</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Myers:Andrew_C=">Andrew C. Myers</a></p>
<p>【Abstract】:
We propose to demonstrate Pyxis, a system that optimizes database applications by pushing computation to the database server. Our system applies program analysis techniques to the application source code to determine pieces of application logic that should be moved to the database server to improve performance. This frees the developer from the need to understand the intricacies of database operations or learn a new programming language for stored procedures. In addition, by dynamically monitoring resource utilization on the database server, Pyxis can migrate computation between application and database in response to workload changes. Our previous experiments have shown that Pyxis can decrease latency up to 3x for transactional applications, and improve throughput up to 1.7x when compared to a standard implementation using embedded SQL statements in application logic. We will demonstrate these capabilities via a visualization of real-time performance as well as an interactive code partitioning tool we have developed.</p>
<p>【Keywords】:
database applications; performance; program optimization</p>
<h3 id="91. Peckalytics: analyzing experts and interests on Twitter.">91. Peckalytics: analyzing experts and interests on Twitter.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463679">Paper Link</a>】    【Pages】:973-976</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/c/Cheng:Alex">Alex Cheng</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bansal:Nilesh">Nilesh Bansal</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Koudas:Nick">Nick Koudas</a></p>
<p>【Abstract】:
We provide a description of Peckalytics, its technology and functionality. Peckalytics processes the entire Twitter data stream in real time and provides a flexible search interface to identify experts in any topic area as well as users with interests in any topic. It provides flexible analytics around sets of experts, their followers as well as sets of users with specific interests. The system is implemented to scale for large data sizes. At the time of this writing it operates on an archive of 30 billion tweets, with 220,000 new tweets crawled every minute. In addition to raw tweets, the social graph of users, and profile information, Peckalytics makes novel use of Twitter lists to assess the expertise of different users. Our aim is to facilitate targeting and optimization of advertising campaigns on the Twitter platform.</p>
<p>【Keywords】:
experts analysis; interest analysis; twitter analytics</p>
<h3 id="92. Packing experiments for sharing and publication.">92. Packing experiments for sharing and publication.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465269">Paper Link</a>】    【Pages】:977-980</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/c/Chirigati:Fernando_Seabra">Fernando Seabra Chirigati</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shasha:Dennis">Dennis Shasha</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Freire:Juliana">Juliana Freire</a></p>
<p>【Abstract】:
Reproducibility is a core component of the scientific process. Revisiting and reusing past results allow science to move forward - "standing on the shoulders of giants", as Newton once said. An impediment to the adoption of computational reproducibility is that authors find it difficult to generate a compendium that encompasses all the required components to correctly reproduce their experiments. Even when a compendium is available, reviewers and readers may have difficulties in verifying the results on platforms different from the ones where the experiments were originally run. As a step towards simplifying the process of creating reproducible experiments, we have developed ReproZip, a tool that automatically captures the provenance of experiments and packs all the necessary files, library dependencies and variables to reproduce the results. Reviewers can then unpack and run the experiments without having to install any additional software. We will demonstrate real use cases for ReproZip, how packages are created, and how reviewers can validate and explore experiments.</p>
<p>【Keywords】:
computational reproducibility; provenance; reprozip</p>
<h3 id="93. CHIC: a combination-based recommendation system.">93. CHIC: a combination-based recommendation system.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465270">Paper Link</a>】    【Pages】:981-984</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/v/Vartak:Manasi">Manasi Vartak</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Madden:Samuel">Samuel Madden</a></p>
<p>【Abstract】:
Current recommender systems are focused largely on recommending items based on similarity. For instance, Netflix can recommend movies similar to previously viewed movies, and Amazon can recommend items based on ratings of similar users. Although similarity-based recommendation works well for books and movies, it provides an incomplete solution for items such as clothing or furniture which are inherently used in combination with other items of the same type, e.g., shirt with pants, and desk with a chair. As a result, the decision to buy a clothing or furniture item depends not only on the item itself, but also on how well it works with other items of that type. Recommending such items therefore requires a combination-based recommendation system that given an item, can suggest interesting and diverse combinations containing that item. This problem is challenging because features affecting combination quality are often difficult to identify; quality, being a function of all items in the combination, cannot be computed independently; and there are an exponential number of combinations to explore. In this demonstration, we present CHIC, a first-of-its-kind, combination-based recommendation system for clothing. The audience will interact with our system through the CHIC mobile app which allows the user to take a picture of a clothing item and search for interesting combinations containing the item instantly. The audience can also compete with CHIC to create alternate ensembles and compare quality. Finally, we highlight via visualizations the core modules of CHIC including model building and our novel search and classification algorithm, C-Search.</p>
<p>【Keywords】:
combination; recommendation</p>
<h3 id="94. Noah: a dynamic ridesharing system.">94. Noah: a dynamic ridesharing system.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463695">Paper Link</a>】    【Pages】:985-988</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/t/Tian:Charles">Charles Tian</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Huang:Yan">Yan Huang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Liu:Zhi">Zhi Liu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bastani:Favyen">Favyen Bastani</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Jin:Ruoming">Ruoming Jin</a></p>
<p>【Abstract】:
This demo presents Noah: a dynamic ridesharing system. Noah supports large scale real-time ridesharing with service guarantee on road networks. Taxis and trip requests are dynamically matched. Different from traditional systems, a taxi can have more than one customer on board given that all waiting time and service time constraints of trips are satisfied. Noah's real-time response relies on three main components: (1) a fast shortest path algorithm with caching on road networks; (2) fast dynamic matching algorithms to schedule ridesharing on the fly; (3) a spatial indexing method for fast retrieving moving taxis. Users will be able to submit requests from a smartphone, choose specific parameters such as number of taxis in the system, service constraints, and matching algorithms, to explore the internal functionalities and implementations of Noah. The system analyzer will show the system performance including average waiting time, average detour percentage, average response time, and average level of sharing. Taxis, routes, and requests will be animated and visualized through Google Maps API. The demo is based on trips of 17,000 Shanghai taxis for one day (May 29, 2009); the dataset contains 432,327 trips. Each trip includes the starting and destination coordinates and the start time. An iPhone application is implemented to allow users to submit a trip request to the Noah system during the demonstration.</p>
<p>【Keywords】:
dynamic ridesharing; kinetic tree; mobile indexing; road networks</p>
<h3 id="95. A query answering system for data with evolution relationships.">95. A query answering system for data with evolution relationships.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463687">Paper Link</a>】    【Pages】:989-992</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Bykau:Siarhei">Siarhei Bykau</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Rizzolo:Flavio">Flavio Rizzolo</a> ; <a href="http://dblp.uni-trier.de/pers/hd/v/Velegrakis:Yannis">Yannis Velegrakis</a></p>
<p>【Abstract】:
Evolving data has attracted considerable research attention. Researchers have focused on modeling and querying of schema/instance-level structural changes, such as, insertion, deletion and modification of attributes. Databases with such a functionality are known as temporal databases. A limitation of the temporal databases is that they treat changes as independent events, while often the appearance (or elimination) of some structure in the database is the result of an evolution of some existing structure. We claim that maintaining the causal relationship between the two structures is of major importance since it allows additional reasoning to be performed and answers to be generated for queries that previously had no answers. We present the TrenDS, a system for exploiting the evolution relationships between the structures in the database. In particular, our system combines different structures that are associated through evolution relationships into virtual structures to be used during query answering. The virtual structures define ``possible'' database instances, in a fashion similar to the possible worlds in the probabilistic databases. TrenDS uses a query answering mechanism that allows queries to be answered over these possible databases without materializing them. Evaluation of such queries raises many technical challenges, since it requires the discovery of Steiner forests on the evolution graphs.</p>
<p>【Keywords】:
data evolution; graph algorithms; probabilistic databases</p>
<h2 id="Demo session 2: data analysis and mining; privacy; security    11">Demo session 2: data analysis and mining; privacy; security    11</h2>
<h3 id="96. GeoDeepDive: statistical inference using familiar data-processing languages.">96. GeoDeepDive: statistical inference using familiar data-processing languages.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463680">Paper Link</a>】    【Pages】:993-996</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Ce">Ce Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Govindaraju:Vidhya">Vidhya Govindaraju</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Borchardt:Jackson">Jackson Borchardt</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Foltz:Tim">Tim Foltz</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/R=eacute=:Christopher">Christopher Ré</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Peters:Shanan">Shanan Peters</a></p>
<p>【Abstract】:
We describe our proposed demonstration of GeoDeepDive, a system that helps geoscientists discover information and knowledge buried in the text, tables, and figures of geology journal articles. This requires solving a host of classical data management challenges including data acquisition (e.g., from scanned documents), data extraction, and data integration. SIGMOD attendees will see demonstrations of three aspects of our system: (1) an end-to-end system that is of a high enough quality to perform novel geological science, but is written by a small enough team so that each aspect can be manageably explained; (2) a simple feature engineering system that allows a user to write in familiar SQL or Python; and (3) the effect of different sources of feedback on result quality including expert labeling, distant supervision, traditional rules, and crowd-sourced data. Our prototype builds on our work integrating statistical inference and learning tools into traditional database systems. If successful, our demonstration will allow attendees to see that data processing systems that use machine learning contain many familiar data processing problems such as efficient querying, indexing, and supporting tools for database-backed websites, none of which are machine-learning problems, per se.</p>
<p>【Keywords】:
demonstration; geoscience; statistical inference</p>
<h3 id="97. Fact checking and analyzing the web.">97. Fact checking and analyzing the web.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463692">Paper Link</a>】    【Pages】:997-1000</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/g/Goasdou=eacute=:Fran=ccedil=ois">François Goasdoué</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Karanasos:Konstantinos">Konstantinos Karanasos</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Katsis:Yannis">Yannis Katsis</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Leblay:Julien">Julien Leblay</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Manolescu:Ioana">Ioana Manolescu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zampetakis:Stamatis">Stamatis Zampetakis</a></p>
<p>【Abstract】:
Fact checking and data journalism are currently strong trends. The sheer amount of data at hand makes it difficult even for trained professionals to spot biased, outdated or simply incorrect information. We propose to demonstrate FactMinder, a fact checking and analysis assistance application. SIGMOD attendees will be able to analyze documents using FactMinder and experience how background knowledge and open data repositories help build insightful overviews of current topics.</p>
<p>【Keywords】:
linked data; online fact checking; semantic annotations</p>
<h3 id="98. Data mining algorithms as a service in the cloud exploiting relational database systems.">98. Data mining algorithms as a service in the cloud exploiting relational database systems.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465240">Paper Link</a>】    【Pages】:1001-1004</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/o/Ordonez:Carlos">Carlos Ordonez</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Garc=iacute=a=Garc=iacute=a:Javier">Javier García-García</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Garcia=Alvarado:Carlos">Carlos Garcia-Alvarado</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Cabrera:Wellington">Wellington Cabrera</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Baladandayuthapani:Veerabhadran">Veerabhadran Baladandayuthapani</a> ; <a href="http://dblp.uni-trier.de/pers/hd/q/Quraishi:Mohammed_S=">Mohammed S. Quraishi</a></p>
<p>【Abstract】:
We present a novel cloud system based on DBMS technology, where data mining algorithms are offered as a service. A local DBMS connects to the cloud and the cloud system returns computed data mining models as small relational tables that are archived and which can be easily transferred, queried and integrated with the client database. Unlike other analytic systems, our solution is not based on MapReduce. Our system avoids exporting large tables outside the local DBMS and thus it avoids transmitting large volumes of data to the cloud. The system offers three processing modes: local, cloud and hybrid, where a linear cost model is used to choose processing mode. In hybrid mode processing is split between the local DBMS and the cloud DBMS. Our system has a job scheduler with FIFO, SJF and RR policies to enhance response time and get partial results early. The cloud DBMS performs dynamic job scheduling, model computation and model archive management. Our system incorporates several optimizations: local data set summarization with sufficient statistics, sampling, caching matrices in RAM and selectively transmitting small matrices, back and forth. We show that in general the most efficient computing mechanism is hybrid processing: summarizing or sampling the data set in the local DBMS, transferring small matrices back and forth, leaving mathematically complex methods as a task for the cloud DBMS.</p>
<p>【Keywords】:
algorithm; cloud; dbms; statistical model; udf</p>
<h3 id="99. SONDY: an open source platform for social dynamics mining and analysis.">99. SONDY: an open source platform for social dynamics mining and analysis.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463694">Paper Link</a>】    【Pages】:1005-1008</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/g/Guille:Adrien">Adrien Guille</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Favre:C=eacute=cile">Cécile Favre</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Hacid:Hakim">Hakim Hacid</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zighed:Djamel_A=">Djamel A. Zighed</a></p>
<p>【Abstract】:
This paper describes SONDY, a tool for analysis of trends and dynamics in online social network data. SONDY addresses two audiences: (i) end-users who want to explore social activity and (ii) researchers who want to experiment and compare mining techniques on social data. SONDY helps end-users like media analysts or journalists understand social network users interests and activity by providing emerging topics and events detection as well as network analysis functionalities. To this end, the application proposes visualizations such as interactive time-lines that summarize information and colored user graphs that reflect the structure of the network. SONDY also provides researchers an easy way to compare and evaluate recent techniques to mine social data, implement new algorithms and extend the application without being concerned with how to make it accessible. In the demo, participants will be invited to explore information from several datasets of various sizes and origins (such as a dataset consisting of 7,874,772 messages published by 1,697,759 Twitter users during a period of 7 days) and apply the different functionalities of the platform in real-time.</p>
<p>【Keywords】:
network analysis; online social networks; topic detection</p>
<h3 id="100. Interactive data mining with 3D-parallel-coordinate-trees.">100. Interactive data mining with 3D-parallel-coordinate-trees.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463696">Paper Link</a>】    【Pages】:1009-1012</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Achtert:Elke">Elke Achtert</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kriegel:Hans=Peter">Hans-Peter Kriegel</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Schubert:Erich">Erich Schubert</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zimek:Arthur">Arthur Zimek</a></p>
<p>【Abstract】:
Parallel coordinates are an established technique to visualize high-dimensional data, in particular for data mining purposes. A major challenge is the ordering of axes, as any axis can have at most two neighbors when placed in parallel on a 2D plane. By extending this concept to a 3D visualization space we can place several axes next to each other. However, finding a good arrangement often does not necessarily become easier, as still not all axes can be arranged pairwise adjacently to each other. Here, we provide a tool to explore complex data sets using 3D-parallel-coordinate-trees, along with a number of approaches to arrange the axes.</p>
<p>【Keywords】:
high-dimensional data; parallel coordinates; visualization</p>
<h3 id="101. Stat!: an interactive analytics environment for big data.">101. Stat!: an interactive analytics environment for big data.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463683">Paper Link</a>】    【Pages】:1013-1016</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Barnett:Mike">Mike Barnett</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Chandramouli:Badrish">Badrish Chandramouli</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/DeLine:Robert">Robert DeLine</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Drucker:Steven_M=">Steven M. Drucker</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Fisher:Danyel">Danyel Fisher</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Goldstein:Jonathan">Jonathan Goldstein</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Morrison:Patrick">Patrick Morrison</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Platt:John_C=">John C. Platt</a></p>
<p>【Abstract】:
Exploratory analysis on big data requires us to rethink data management across the entire stack -- from the underlying data processing techniques to the user experience. We demonstrate Stat! -- a visualization and analytics environment that allows users to rapidly experiment with exploratory queries over big data. Data scientists can use Stat! to quickly refine to the correct query, while getting immediate feedback after processing a fraction of the data. Stat! can work with multiple processing engines in the backend; in this demo, we use Stat! with the Microsoft StreamInsight streaming engine. StreamInsight is used to generate incremental early results to queries and refine these results as more data is processed. Stat! allows data scientists to explore data, dynamically compose multiple queries to generate streams of partial results, and display partial results in both textual and visual form.</p>
<p>【Keywords】:
analytics; big data; interactive; tool; visualization</p>
<h3 id="102. PARAS: interactive parameter space exploration for association rule mining.">102. PARAS: interactive parameter space exploration for association rule mining.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465245">Paper Link</a>】    【Pages】:1017-1020</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Mukherji:Abhishek">Abhishek Mukherji</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lin:Xika">Xika Lin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Botaish:Christopher_R=">Christopher R. Botaish</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Whitehouse:Jason">Jason Whitehouse</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Rundensteiner:Elke_A=">Elke A. Rundensteiner</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Ward:Matthew_O=">Matthew O. Ward</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Ruiz:Carolina">Carolina Ruiz</a></p>
<p>【Abstract】:
We demonstrate our PARAS technology for supporting interactive association mining at near real-time speeds. Key technical innovations of PARAS, in particular, stable region abstractions and rule redundancy management supporting novel parameter space-centric exploratory queries will be showcased. The audience will be able to interactively explore the parameter space view of rules. They will experience near real-time speeds achieved by PARAS for operations, such as comparing rule sets mined using different parameter values, that would otherwise take hours of computation and much manual investigation. Overall, we will demonstrate that the PARAS system provides a rich experience to data analysts through parameter tuning recommendations while significantly reducing the trial-and-error interactions.</p>
<p>【Keywords】:
association rules; interestingness parameters; visual mining</p>
<h3 id="103. STEM: a spatio-temporal miner for bursty activity.">103. STEM: a spatio-temporal miner for bursty activity.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463688">Paper Link</a>】    【Pages】:1021-1024</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Lappas:Theodoros">Theodoros Lappas</a> ; <a href="http://dblp.uni-trier.de/pers/hd/v/Vieira:Marcos_R=">Marcos R. Vieira</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Gunopulos:Dimitrios">Dimitrios Gunopulos</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tsotras:Vassilis_J=">Vassilis J. Tsotras</a></p>
<p>【Abstract】:
Burst identification has been extensively studied in the context of document streams, where a burst is generally exhibited when an unusually high frequency is observed for a term t. Previous works have focused exclusively on either temporal or spatial burstiness patterns. The former represents bursty timeframes within a single stream, while the latter characterizes sets of streams that simultaneously exhibited a bursty behavior for a user-specified timeframe. Our previous work was the first to study the spatiotemporal burstiness of terms. In this context, a burstiness pattern consists of both a timeframe and a set of streams, both of which need to be identified automatically. In this paper we describe STEM (Spatio-TEmporal Miner), a system for finding spatiotemporal burstiness patterns in a collection of spatially distributed frequency streams. STEM implements the full functionality required to mine spatiotemporal burstiness patterns from virtually any collection of geostamped streams. Examples of such collections include document streams (e.g. online newspapers), geo-aware microblogging platforms (e.g. Twitter). This paper describes the STEM system and discusses how its features can be accessed via a user-friendly interface.</p>
<p>【Keywords】:
spatiotemporal burstiness; streams</p>
<h3 id="104. The farm: where pig scripts are bred and raised.">104. The farm: where pig scripts are bred and raised.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465250">Paper Link</a>】    【Pages】:1025-1028</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Sayers:Craig_P=">Craig P. Sayers</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Simitsis:Alkis">Alkis Simitsis</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Koutrika:Georgia">Georgia Koutrika</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Gonzalez:Alejandro_Guerrero">Alejandro Guerrero Gonzalez</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Cantu:David_Tamez">David Tamez Cantu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Hsu:Meichun">Meichun Hsu</a></p>
<p>【Abstract】:
Even though scripting languages like Pig allow for simpler coding, performing analytics over Big Data using Map-Reduce engines remains challenging. To further assist developers, and support novice users, we offer "The Farm", a catalog of scriptable services supporting creation, discovery, composition, and optimized execution. Each Pig script added to The Farm becomes an executable service, with inputs and outputs defined by relation schemas. Those services are discoverable using natural language search, and composable using a drag-and-drop interface. To support efficient execution, composed services are automatically merged to a single executable script, which can then be run by a growing selection of platform-specific optimizers and interpreters.</p>
<p>【Keywords】:
analytics; cloud services; composition; natural language</p>
<h3 id="105. LinkIT: privacy preserving record linkage and integration via transformations.">105. LinkIT: privacy preserving record linkage and integration via transformations.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465259">Paper Link</a>】    【Pages】:1029-1032</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Bonomi:Luca">Luca Bonomi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/x/Xiong:Li">Li Xiong</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lu:James_J=">James J. Lu</a></p>
<p>【Abstract】:
We propose to demonstrate an open-source tool, LinkIT, for privacy preserving record Linkage and Integration via data Transformations. LinkIT implements novel algorithms that support data transformations for linking sensitive attributes, and is designed to work with our previously developed tool, FRIL (Fine-grained Record Integration and Linkage), to provide a complete record linkage solution. LinkIT can be also used as a stand-alone secure transformation tool to link string records. The system uses a novel embedding technique based on frequent variable length grams mined from original records with differential privacy, and utilizes a personalized threshold for performing linkage in the embedded space. Compared to the state-of-the-art secure transformation method [16], LinkIT guarantees stronger privacy with better scalability while achieving comparable utility results.</p>
<p>【Keywords】:
privacy; record linkage; security</p>
<h3 id="106. Secure database-as-a-service with Cipherbase.">106. Secure database-as-a-service with Cipherbase.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2467797">Paper Link</a>】    【Pages】:1033-1036</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Arasu:Arvind">Arvind Arasu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Blanas:Spyros">Spyros Blanas</a> ; <a href="http://dblp.uni-trier.de/pers/hd/e/Eguro:Ken">Ken Eguro</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Joglekar:Manas">Manas Joglekar</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kaushik:Raghav">Raghav Kaushik</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kossmann:Donald">Donald Kossmann</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Ramamurthy:Ravishankar">Ravishankar Ramamurthy</a> ; <a href="http://dblp.uni-trier.de/pers/hd/u/Upadhyaya:Prasang">Prasang Upadhyaya</a> ; <a href="http://dblp.uni-trier.de/pers/hd/v/Venkatesan:Ramarathnam">Ramarathnam Venkatesan</a></p>
<p>【Abstract】:
Data confidentiality is one of the main concerns for users of public cloud services. The key problem is protecting sensitive data from being accessed by cloud administrators who have root privileges and can remotely inspect the memory and disk contents of the cloud servers. While encryption is the basic mechanism that can leveraged to provide data confidentiality, providing an efficient database-as-a-service that can run on encrypted data raises several interesting challenges. In this demonstration we outline the functionality of Cipherbase --- a full fledged SQL database system that supports the full generality of a database system while providing high data confidentiality. Cipherbase has a novel architecture that tightly integrates custom-designed trusted hardware for performing operations on encrypted data securely such that an administrator cannot get access to any plaintext corresponding to sensitive data.</p>
<p>【Keywords】:
encryption; privacy; security; trusted hardware</p>
<h2 id="Demo session 3: database optimization; performance    11">Demo session 3: database optimization; performance    11</h2>
<h3 id="107. DBalancer: distributed load balancing for NoSQL data-stores.">107. DBalancer: distributed load balancing for NoSQL data-stores.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465232">Paper Link</a>】    【Pages】:1037-1040</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/k/Konstantinou:Ioannis">Ioannis Konstantinou</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tsoumakos:Dimitrios">Dimitrios Tsoumakos</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Mytilinis:Ioannis">Ioannis Mytilinis</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Koziris:Nectarios">Nectarios Koziris</a></p>
<p>【Abstract】:
Unanticipated load spikes or skewed data access patterns may lead to severe performance degradation in data serving applications, a typical problem of distributed NoSQL data-stores. In these cases, load balancing is a necessary operation. In this demonstration, we present the DBalancer, a generic distributed module that can be installed on top of a typical NoSQL data-store and provide an efficient and highly configurable load balancing mechanism. Balancing is performed by simple message exchanges and typical data movement operations supported by most modern NoSQL data-stores. We present the system's architecture, we describe in detail its modules and their interaction and we implement a suite of different algorithms on top of it. Through a web-based interactive GUI we allow the users to launch NoSQL clusters of various sizes, to apply numerous skewed and dynamic workloads and to compare the implemented load balancing algorithms. Videos and graphs showcasing each algorithm's effect on a number of indicative performance and cost metrics will be created on the fly for every setup. By browsing the results of different executions users will be able to grasp each algorithm's balancing mechanisms and performance impact in a number of representative setups.</p>
<p>【Keywords】:
cloud computing; load balancing; nosql</p>
<h3 id="108. COCCUS: self-configured cost-based query services in the cloud.">108. COCCUS: self-configured cost-based query services in the cloud.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465233">Paper Link</a>】    【Pages】:1041-1044</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/k/Konstantinou:Ioannis">Ioannis Konstantinou</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kantere:Verena">Verena Kantere</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tsoumakos:Dimitrios">Dimitrios Tsoumakos</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Koziris:Nectarios">Nectarios Koziris</a></p>
<p>【Abstract】:
Recently, a large number of pay-as-you-go data services are offered over cloud infrastructures. Data service providers need appropriate and flexible query charging mechanisms and query optimization that take into consideration cloud operational expenses, pricing strategies and user preferences. Yet, existing solutions are static and non-configurable. We demonstrate COCCUS, a modular system for cost-aware query execution, adaptive query charge and optimization of cloud data services. The audience can set their queries along with their execution preferences and budget constraints, while COCCUS adaptively determines query charge and manages secondary data structures according to various economic policies. We demonstrate COCCUS's operation over centralized and shared nothing CloudDBMS architectures on top of public and private IaaS clouds. The audience is enabled to set economic policies and execute various workloads through a comprehensive GUI. COCCUS's adaptability is showcased using real-time graphs depicting a number of key performance metrics.</p>
<p>【Keywords】:
amortization; cloud computing; economy</p>
<h3 id="109. Workload optimization using SharedDB.">109. Workload optimization using SharedDB.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463678">Paper Link</a>】    【Pages】:1045-1048</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/g/Giannikis:Georgios">Georgios Giannikis</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Makreshanski:Darko">Darko Makreshanski</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Alonso:Gustavo">Gustavo Alonso</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kossmann:Donald">Donald Kossmann</a></p>
<p>【Abstract】:
This demonstration presents SharedDB, an implementation of a relational database system capable of executing all SQL operators by sharing computation and resources across all running queries. SharedDB sidesteps the traditional query-at-a-time approach and executes queries in batches. Unlike proposed multi-query optimization ideas, in SharedDB queries do not have to contain common subexpressions in order to be part of the same batch, which allows for a higher degree of sharing. By sharing as much as possible, SharedDB avoids repeating parts of computation that is common across all running queries. The goal of this demonstration is to show the ability of shared query execution to a) answer complex and diverse workloads, and b) reduce the interaction among concurrently executed queries that is observed in traditional systems and leads to performance deterioration and instabilities.</p>
<p>【Keywords】:
main memory; shared query processing</p>
<h3 id="110. SciQL: array data processing inside an RDBMS.">110. SciQL: array data processing inside an RDBMS.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463684">Paper Link</a>】    【Pages】:1049-1052</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Ying">Ying Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kersten:Martin_L=">Martin L. Kersten</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Manegold:Stefan">Stefan Manegold</a></p>
<p>【Abstract】:
Scientific discoveries increasingly rely on the ability to efficiently grind massive amounts of experimental data using database technologies. To bridge the gap between the needs of the Data-Intensive Research fields and the current DBMS technologies, we have introduced SciQL (pronounced as 'cycle'). SciQL is the first SQL-based declarative query language for scientific applications with both tables and arrays as first class citizens. It provides a seamless symbiosis of array-, set- and sequence- interpretations. A key innovation is the extension of value-based grouping of SQL:2003 with structural grouping, i.e., group array elements based on their positions. This leads to a generalisation of window-based query processing with wide applicability in science domains. In this demo, we showcase a proof of concept implementation of SciQL in the relational database system MonetDB. First, with the Conway's Game of Life application implemented purely in SciQL queries, we demonstrate the storage of arrays in the MonetDB as first class citizens, and the execution of a comprehensive set of basic operations on arrays. Then, to show the usefulness of SciQL for real-world array data processing use cases, we demonstrate how various common image processing and remote sensing operations are executed as SciQL queries. The audience is invited to challenge SciQL with their use cases.</p>
<p>【Keywords】:
array database; array query language; scientific databases; sciql</p>
<h3 id="111. Iterative parallel data processing with stratosphere: an inside look.">111. Iterative parallel data processing with stratosphere: an inside look.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463693">Paper Link</a>】    【Pages】:1053-1056</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/e/Ewen:Stephan">Stephan Ewen</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Schelter:Sebastian">Sebastian Schelter</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tzoumas:Kostas">Kostas Tzoumas</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Warneke:Daniel">Daniel Warneke</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Markl:Volker">Volker Markl</a></p>
<p>【Abstract】:
Iterative algorithms occur in many domains of data analysis, such as machine learning or graph analysis. With increasing interest to run those algorithms on very large data sets, we see a need for new techniques to execute iterations in a massively parallel fashion. In prior work, we have shown how to extend and use a parallel data flow system to efficiently run iterative algorithms in a shared-nothing environment. Our approach supports the incremental processing nature of many of those algorithms. In this demonstration proposal we illustrate the process of implementing, compiling, optimizing, and executing iterative algorithms on Stratosphere using examples from graph analysis and machine learning. For the first step, we show the algorithm's code and a visualization of the produced data flow programs. The second step shows the optimizer's execution plan choices, while the last phase monitors the execution of the program, visualizing the state of the operators and additional metrics, such as per-iteration runtime and number of updates. To show that the data flow abstraction supports easy creation of custom programming APIs, we also present programs written against a lightweight Pregel API that is layered on top of our system with a small programming effort.</p>
<p>【Keywords】:
graph processing; iterative algorithms; machine learning; parallel databases; query execution; query optimization</p>
<h3 id="112. CARTILAGE: adding flexibility to the Hadoop skeleton.">112. CARTILAGE: adding flexibility to the Hadoop skeleton.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465258">Paper Link</a>】    【Pages】:1057-1060</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/j/Jindal:Alekh">Alekh Jindal</a> ; <a href="http://dblp.uni-trier.de/pers/hd/q/Quian=eacute==Ruiz:Jorge=Arnulfo">Jorge-Arnulfo Quiané-Ruiz</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Madden:Samuel">Samuel Madden</a></p>
<p>【Abstract】:
Modern enterprises have to deal with a variety of analytical queries over very large datasets. In this respect, Hadoop has gained much popularity since it scales to thousand of nodes and terabytes of data. However, Hadoop suffers from poor performance, especially in I/O performance. Several works have proposed alternate data storage for Hadoop in order to improve the query performance. However, many of these works end up making deep changes in Hadoop or HDFS. As a result, they are (i) difficult to adopt by several users, and (ii) not compatible with future Hadoop releases. In this paper, we present CARTILAGE, a comprehensive data storage framework built on top of HDFS. CARTILAGE allows users full control over their data storage, including data partitioning, data replication, data layouts, and data placement. Furthermore, CARTILAGE can be layered on top of an existing HDFS installation. This means that Hadoop, as well as other query engines, can readily make use of CARTILAGE. We describe several use-cases of CARTILAGE and propose to demonstrate the flexibility and efficiency of CARTILAGE through a set of novel scenarios.</p>
<p>【Keywords】:
ease of use; flexible storage; hdfs; portability</p>
<h3 id="113. Continuous outlier detection in data streams: an extensible framework and state-of-the-art algorithms.">113. Continuous outlier detection in data streams: an extensible framework and state-of-the-art algorithms.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463691">Paper Link</a>】    【Pages】:1061-1064</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/g/Georgiadis:Dimitrios">Dimitrios Georgiadis</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kontaki:Maria">Maria Kontaki</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Gounaris:Anastasios">Anastasios Gounaris</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Papadopoulos:Apostolos_N=">Apostolos N. Papadopoulos</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tsichlas:Kostas">Kostas Tsichlas</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Manolopoulos:Yannis">Yannis Manolopoulos</a></p>
<p>【Abstract】:
Anomaly detection is an important data mining task, aiming at the discovery of elements that show significant diversion from the expected behavior; such elements are termed as outliers. One of the most widely employed criteria for determining whether an element is an outlier is based on the number of neighboring elements within a fixed distance (R), against a fixed threshold (k). Such outliers are referred to as distance-based outliers and are the focus of this work. In this demo, we show both an extendible framework for outlier detection algorithms and specific outlier detection algorithms for the demanding case where outlier detection is continuously performed over a data stream. More specifically: i) first we demonstrate a novel flavor of an open-source publicly available tool for Massive Online Analysis (MOA) that is endowed with capabilities to encapsulate algorithms that continuously detect outliers and ii) second, we present four online outlier detection algorithms. Two of these algorithms have been designed by the authors of this demo, with a view to improving on key aspects related to outlier mining, such as running time, flexibility and space requirements.</p>
<p>【Keywords】:
continuous processing; data streams; metric space; outlier detection</p>
<h3 id="114. FAST: differentially private real-time aggregate monitor with filtering and adaptive sampling.">114. FAST: differentially private real-time aggregate monitor with filtering and adaptive sampling.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465253">Paper Link</a>】    【Pages】:1065-1068</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/f/Fan:Liyue">Liyue Fan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/x/Xiong:Li">Li Xiong</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Sunderam:Vaidy_S=">Vaidy S. Sunderam</a></p>
<p>【Abstract】:
Sharing aggregate statistics of private data can be of great value when data mining can be performed in real-time to understand important phenomena such as influenza outbreaks or traffic congestion. However, to this date there have been no tools for releasing real-time aggregated data with differential privacy, a strong and provable privacy guarantee. We propose FAST, a real-time system that allows differentially private aggregate sharing and time-series analytics. FAST employs a set of novel, adaptive strategies to improve the utility of shared/released data while guaranteeing the user-specified level of differential privacy. We will demonstrate the challenges and our solutions in the context of prepared data sets as well as live participation data dynamically collected among the SIGMOD'13 attendees.</p>
<p>【Keywords】:
differential privacy; estimation; sampling; time series</p>
<h3 id="115. Execution and optimization of continuous queries with cyclops.">115. Execution and optimization of continuous queries with cyclops.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465248">Paper Link</a>】    【Pages】:1069-1072</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Lim:Harold">Harold Lim</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Babu:Shivnath">Shivnath Babu</a></p>
<p>【Abstract】:
As the data collected by enterprises grows in scale, there is a growing trend of performing data analytics on large datasets. Batch processing systems that can handle petabyte scale of data, such as Hadoop, have flourished and gained traction in the industry. As the results of batch analytics have been used to continuously improve front-facing user experience, there is a growing interest in pushing the processing latency down. This trend has fueled a resurgence in the development and usage of execution engines that can process continuous queries. An important class of continuous queries is windowed aggregation queries. Such queries arise in a wide range of applications such as generating personalized content and results. Today, considerable manual effort goes into finding the most suitable execution engine for these queries and on tuning query performance on these engines. An ecosystem composed of multiple execution engines may be needed in order to run the overall query workload efficiently given the diverse set of requirements that arise in practice. Cyclops is a continuous query processing platform that manages and orchestrates windowed aggregation queries in an ecosystem composed of multiple continuous query execution engines. Cyclops employs a cost-based approach for picking the most suitable engine and plan for executing a given query. This demonstration first presents an interactive visualization of the rich execution plan space of windowed aggregation queries, which allows users to analyze and understand the differences among plans. The next part of the demonstration will drill down into the design of Cyclops. For a given query, we show the cost spectrum of query execution plans across three different execution engines---Esper, Storm, and Hadoop---as estimated by Cyclops.</p>
<p>【Keywords】:
continuous queries; windowed aggregation queries</p>
<h3 id="116. Less watts, more performance: an intelligent storage engine for data appliances.">116. Less watts, more performance: an intelligent storage engine for data appliances.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463685">Paper Link</a>】    【Pages】:1073-1076</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/w/Woods:Louis">Louis Woods</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Teubner:Jens">Jens Teubner</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Alonso:Gustavo">Gustavo Alonso</a></p>
<p>【Abstract】:
In this demonstration, we present Ibex, a novel storage engine featuring hybrid, FPGA-accelerated query processing. In Ibex, an FPGA is inserted along the path between the storage devices and the database engine. The FPGA acts as an intelligent storage engine supporting query off-loading from the query engine. Apart from significant performance improvements for many common SQL queries, the demo will show how Ibex reduces data movement, CPU usage, and overall energy consumption in database appliances.</p>
<p>【Keywords】:
data appliance; energy; fpga; ibex; intelligent; storage</p>
<h3 id="117. A demonstration of SQLVM: performance isolation in multi-tenant relational database-as-a-service.">117. A demonstration of SQLVM: performance isolation in multi-tenant relational database-as-a-service.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463686">Paper Link</a>】    【Pages】:1077-1080</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/n/Narasayya:Vivek_R=">Vivek R. Narasayya</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Das:Sudipto">Sudipto Das</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Syamala:Manoj">Manoj Syamala</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Chaudhuri:Surajit">Surajit Chaudhuri</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Li:Feng">Feng Li</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Park:Hyunjung">Hyunjung Park</a></p>
<p>【Abstract】:
Sharing resources of a single database server among multiple tenants is common in multi-tenant Database-as-a-Service providers, such as Microsoft SQL Azure. Multi-tenancy enables cost reduction for the cloud service provider which it can pass on as savings to the tenants. However, resource sharing can adversely affect a tenant's performance due to other tenants' workloads contending for shared resources. Service providers today do not provide any assurances to a tenant in terms of isolating its performance from other co-located tenants. SQLVM, a project at Microsoft Research, is an abstraction for performance isolation which is built on a promise of reserving key database server resources, such as CPU, I/O and memory, for each tenant. The key challenge is in supporting this abstraction within a RDBMS without statically allocating resources to tenants, while ensuring low overheads and scaling to large numbers of tenants. This demonstration will show how SQLVM can effectively isolate a tenant's performance from other tenant workloads co-located at the same database server. Our demonstration will use various scripted scenarios and a data collection and visualization framework to illustrate performance isolation using SQLVM.</p>
<p>【Keywords】:
cloud computing; multitenancy; performance isolation; relational database-as-a-service; resource isolation</p>
<h2 id="Demo session 4: graphs and networks; potpourris    11">Demo session 4: graphs and networks; potpourris    11</h2>
<h3 id="118. SQUIN: a traversal based query execution system for the web of linked data.">118. SQUIN: a traversal based query execution system for the web of linked data.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465231">Paper Link</a>】    【Pages】:1081-1084</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/h/Hartig:Olaf">Olaf Hartig</a></p>
<p>【Abstract】:
The World Wide Web (WWW) currently evolves into a Web of Linked Data where content providers publish and link their data as they have done with hypertext for the last 20 years. We understand this emerging dataspace as a huge, distributed database which is -at best- partially known to query execution systems. To tap the full potential of the Web, such a system must be able to answer a query using data from initially unknown data sources. For this purpose, traditional query execution paradigms are unsuitable because those assume a fixed set of potentially relevant data sources beforehand. We demonstrate the query execution system SQUIN which implements a novel query execution approach. The main idea is to integrate the traversal of data links into the result construction process. This approach allows the execution engine to discover potentially relevant data during the query execution. In our demonstration, attendees can query the Web of Linked Data using SQUIN and, thus, learn about the new query execution approach. Furthermore, attendees can experience the suitability of the approach for Web applications by using a simple, Linked Data based mash-up implemented on top of SQUIN.</p>
<p>【Keywords】:
link traversal based query execution; linked data; web of data</p>
<h3 id="119. GRDB: a system for declarative and interactive analysis of noisy information networks.">119. GRDB: a system for declarative and interactive analysis of noisy information networks.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465257">Paper Link</a>】    【Pages】:1085-1088</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Moustafa:Walaa_Eldin">Walaa Eldin Moustafa</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Miao:Hui">Hui Miao</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Deshpande:Amol">Amol Deshpande</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Getoor:Lise">Lise Getoor</a></p>
<p>【Abstract】:
There is a growing interest in methods for analyzing data describing networks of all types, including biological, physical, social, and scientific collaboration networks. Typically the data describing these networks is observational, and thus noisy and incomplete; it is often at the wrong level of fidelity and abstraction for meaningful data analysis. This demonstration presents GrDB, a system that enables data analysts to write declarative programs to specify and combine different network data cleaning tasks, visualize the output, and engage in the process of decision review and correction if necessary. The declarative interface of GrDB makes it very easy to quickly write analysis tasks and execute them over data, while the visual component facilitates debugging the program and performing fine grained corrections.</p>
<p>【Keywords】:
datalog; graph data; social network analysis</p>
<h3 id="120. HiNGE: enabling temporal network analytics at scale.">120. HiNGE: enabling temporal network analytics at scale.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465262">Paper Link</a>】    【Pages】:1089-1092</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/k/Khurana:Udayan">Udayan Khurana</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Deshpande:Amol">Amol Deshpande</a></p>
<p>【Abstract】:
However, much of the prior work on those topics has been restricted to static networks, a primary reason being the lack of efficient temporal data management systems to store and query large dynamic network datasets. In this demonstration proposal, we present HiNGE (Historical Network/Graph Explorer), a system that enables interactive exploration and analytics over large evolving networks through visualization and node-centric metric computations. HiNGE is built on top of a distributed graph database system that stores the entire history of a network, and enables efficiently retrieving and analyzing multiple graph snapshots from arbitrary time points in the past. The cornerstone of our system is a novel hierarchical parallelizable index structure, called DeltaGraph, that enables compact recording of the historical trace of a network on disk, and supports efficient retrieval of historical snapshots for single-site or parallel processing. The other key component of our system is an in-memory graph data structure, called GraphPool, that can maintain hundreds of historical graph snapshots in main memory in a non-redundant manner. We demonstrate the efficient and usability of our system at performing temporal analytics over large-scale dynamic networks.</p>
<p>【Keywords】:
graph databases; historical data management; snapshot queries; social network analysis; temporal data management</p>
<h3 id="121. Research-insight: providing insight on research by publication network analysis.">121. Research-insight: providing insight on research by publication network analysis.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463689">Paper Link</a>】    【Pages】:1093-1096</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/t/Tao:Fangbo">Fangbo Tao</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yu:Xiao">Xiao Yu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lei:Kin_Hou">Kin Hou Lei</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Brova:George">George Brova</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Cheng:Xiao">Xiao Cheng</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Han:Jiawei">Jiawei Han</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kanade:Rucha">Rucha Kanade</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Sun:Yizhou">Yizhou Sun</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang_0001:Chi">Chi Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Lidan">Lidan Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Weninger:Tim">Tim Weninger</a></p>
<p>【Abstract】:
A database contains rich, inter-related, multi-typed data and information, forming one or a set of gigantic, intercon- nected, heterogeneous information networks. Much knowl- edge can be derived from such information networks if we systematically develop an effective and scalable database-oriented information network analysis technology. In this system demo, we take a computer science research publica- tion network as an example, which is an information net- work derived from an integration of DBLP, other web-based information about researchers, and partially available cita- tion data, and construct a Research-Insight system in order to demonstrate the power of database-oriented information network analysis. We show that nontrivial research insight can be obtained from such analysis, including (1) ranking, clustering, classification and similarity search of researchers, terms and venues for research subfields and themes, (2) recommending good researchers and good research papers to read or cite when conducting research on certain topics (3) predicting potential collaborators for certain theme-oriented research, and (4) predicting advisor-advisee rela- tionships and affiliation history based on historical research publications. Although some of these functions have been studied in recent research, effective and scalable realization of such functions in large networks still poses challenging research problems. Moreover, some function are our on- going research tasks. By integrating these functionalities, Research-Insight may not only provide with us insightful rec- ommendations in CS research but also help us gain insight on how to perform effective data mining in large databases.</p>
<p>【Keywords】:
heterogeneous information network; recommendation system</p>
<h3 id="122. QUBLE: blending visual subgraph query formulation with query processing on large networks.">122. QUBLE: blending visual subgraph query formulation with query processing on large networks.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463681">Paper Link</a>】    【Pages】:1097-1100</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/h/Hung:Ho_Hoang">Ho Hoang Hung</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bhowmick:Sourav_S=">Sourav S. Bhowmick</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Truong:Ba_Quan">Ba Quan Truong</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Choi:Byron">Byron Choi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhou:Shuigeng">Shuigeng Zhou</a></p>
<p>【Abstract】:
In a previous paper, we laid out the vision of a novel graph query processing paradigm where instead of processing a visual query graph after its construction, it interleaves visual query formulation and processing by exploiting the latency offered by the GUI [4]. Our recent attempts at implementing this vision [4,6], show significant improvement in the system response time (SRT) for subgraph queries. However, these efforts are designed specifically for graph databases containing a large collection of small or medium-sized graphs. Consequently, its frequent fragment-based action-aware indexing schemes and query processing strategy are unsuitable for supporting subgraph queries on large networks containing thousands of nodes and edges. In this demonstration, we present a novel system called QUBLE (QUery Blender for Large nEtworks) to realize this novel paradigm on large networks. We demonstrate various innovative features of QUBLE and its promising performance.</p>
<p>【Keywords】:
action-aware indexes; action-aware query processing; blending; frequent fragments; large networks; query formulation; small infrequent fragments; visual graph querying</p>
<h3 id="123. StreamWorks: a system for dynamic graph search.">123. StreamWorks: a system for dynamic graph search.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463697">Paper Link</a>】    【Pages】:1101-1104</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/c/Choudhury:Sutanay">Sutanay Choudhury</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Holder:Lawrence_B=">Lawrence B. Holder</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Chin_Jr=:George">George Chin Jr.</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Ray:Abhik">Abhik Ray</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Beus:Sherman">Sherman Beus</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Feo:John">John Feo</a></p>
<p>【Abstract】:
Acting on time-critical events by processing ever growing social media, news or cyber data streams is a major technical challenge. Many of these data sources can be modeled as multi-relational graphs. Mining and searching for subgraph patterns in a continuous setting requires an efficient approach to incremental graph search. The goal of our work is to enable real-time search capabilities for graph databases. This demonstration will present a dynamic graph query system that leverages the structural and semantic characteristics of the underlying multi-relational graph.</p>
<p>【Keywords】:
continuous queries; dynamic graph search; subgraph matching</p>
<h3 id="124. Query processing on prefix trees live.">124. Query processing on prefix trees live.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463682">Paper Link</a>】    【Pages】:1105-1108</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/k/Kissinger:Thomas">Thomas Kissinger</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Schlegel:Benjamin">Benjamin Schlegel</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Habich:Dirk">Dirk Habich</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lehner:Wolfgang">Wolfgang Lehner</a></p>
<p>【Abstract】:
Modern database systems have to process huge amounts of data and should provide results with low latency at the same time. To achieve this, data is nowadays typically hold completely in main memory, to benefit of its high bandwidth and low access latency that could never be reached with disks. Current in-memory databases are usually column-stores that exchange columns or vectors between operators and suffer from a high tuple reconstruction overhead. In this demonstration proposal, we present DexterDB, which implements our novel prefix tree-based processing model that makes indexes the first-class citizen of the database system. The core idea is that each operator takes a set of indexes as input and builds a new index as output that is indexed on the attribute requested by the successive operator. With that, we are able to build composed operators, like the multi-way-select-join-group. Such operators speed up the processing of complex OLAP queries so that DexterDB outperforms state-of-the-art in-memory databases. Our demonstration focuses on the different optimization options for such query plans. Hence, we built an interactive GUI that connects to a DexterDB instance and allows the manipulation of query optimization parameters. The generated query plans and important execution statistics are visualized to help the visitor to understand our processing model.</p>
<p>【Keywords】:
in-memory query processing; indexing; prefix trees</p>
<h3 id="125. xPAD: a platform for analytic data flows.">125. xPAD: a platform for analytic data flows.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465247">Paper Link</a>】    【Pages】:1109-1112</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Simitsis:Alkis">Alkis Simitsis</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wilkinson:Kevin">Kevin Wilkinson</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Jovanovic_0001:Petar">Petar Jovanovic</a></p>
<p>【Abstract】:
As enterprises become more automated, real-time, and data-driven, they need to integrate new data sources and specialized processing engines. The traditional business intelligence architecture of Extract-Transform-Load (ETL) flows, followed by querying, reporting, and analytic operations, is being generalized to analytic data flows that utilize a variety of data types and operations. These complicated flows are difficult to design, implement and maintain since they span a variety of systems. Additionally, new design requirements may be imposed such as design for fault-tolerance, freshness, maintainability, sampling, etc. To reduce development time and maintenance costs, automation is needed. We present xPAD, our platform to manage analytic data flows. xPAD enables flow design. We show how these designs can be optimized, not just for performance, but for other objectives as well. xPAD is engine-agnostic. We show how it can generate executable code for a number of execution engines. It can also import existing flows from other engines and optimize those flows. In that way, it can transform a flow written for one engine into an optimized flow for a different engine. In our demonstration, we will also use various example flows to show optimization for different objectives and comparison of flow execution on different engines.</p>
<p>【Keywords】:
analytics; code generation; data flows; optimization</p>
<h3 id="126. PBS at work: advancing data management with consistency metrics.">126. PBS at work: advancing data management with consistency metrics.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465260">Paper Link</a>】    【Pages】:1113-1116</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Bailis:Peter">Peter Bailis</a> ; <a href="http://dblp.uni-trier.de/pers/hd/v/Venkataraman:Shivaram">Shivaram Venkataraman</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Franklin:Michael_J=">Michael J. Franklin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Hellerstein:Joseph_M=">Joseph M. Hellerstein</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Stoica:Ion">Ion Stoica</a></p>
<p>【Abstract】:
A large body of recent work has proposed analytical and empirical techniques for quantifying the data consistency properties of distributed data stores. In this demonstration, we begin to explore the wide range of new database functionality they enable, including dynamic query tuning, consistency SLAs, monitoring, and administration. Our demonstration will exhibit how both application programmers and database administrators can leverage these features. We describe three major application scenarios and present a system architecture for supporting them. We also describe our experience in integrating Probabilistically Bounded Staleness (PBS) predictions into Cassandra, a popular NoSQL store and sketch a demo platform that will allow SIGMOD attendees to experience the importance and applicability of real-time consistency metrics.</p>
<p>【Keywords】:
auto-tuning; eventual consistency; monitoring; prediction</p>
<h3 id="127. The power of data use management in action.">127. The power of data use management in action.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465264">Paper Link</a>】    【Pages】:1117-1120</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/u/Upadhyaya:Prasang">Prasang Upadhyaya</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Anderson:Nick_R=">Nick R. Anderson</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Balazinska:Magdalena">Magdalena Balazinska</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Howe:Bill">Bill Howe</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kaushik:Raghav">Raghav Kaushik</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Ramamurthy:Ravishankar">Ravishankar Ramamurthy</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Suciu:Dan">Dan Suciu</a></p>
<p>【Abstract】:
In this demonstration, we show-case a database management system extended with a new type of component that we call a Data Use Manager (DUM). The DUM enables DBAs to attach policies to data loaded into the DBMS. It then monitors how users query the data, flags potential policy violations, recommends possible fixes, and supports offline analysis of user activities related to data policies. The demonstration uses real healthcare data.</p>
<p>【Keywords】:
access control; data use management</p>
<h3 id="128. CTrace: semantic comparison of multi-granularity process traces.">128. CTrace: semantic comparison of multi-granularity process traces.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465268">Paper Link</a>】    【Pages】:1121-1124</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Liu:Qing">Qing Liu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Taylor:Kerry">Kerry Taylor</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhao:Xiang">Xiang Zhao</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Squire:Geoffrey">Geoffrey Squire</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lin:Xuemin">Xuemin Lin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kloppers:Corne">Corne Kloppers</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Miller:Richard">Richard Miller</a></p>
<p>【Abstract】:
A process trace describes the processes taken in a workflow to generate a particular result. Given many process traces, each with a large amount of very low level information, it is a challenge to make process traces meaningful to different users. It is more challenging to compare two complex process traces generated by heterogenous systems and have different levels of granularity. We present CTrace, a system that (1) lets users explore the conceptual abstraction of large process traces with different levels of granularity, and (2) provides semantic comparison among traces in which both the structural and the semantic similarity are considered. The above functions are underpinned by a novel notion of multi-granularity process trace and efficient multi-granularity similarity comparison algorithms.</p>
<p>【Keywords】:
multi-granularity; semantics; similarity</p>
<h2 id="Industry session 1: big data I    3">Industry session 1: big data I    3</h2>
<h3 id="129. The big data ecosystem at LinkedIn.">129. The big data ecosystem at LinkedIn.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463707">Paper Link</a>】    【Pages】:1125-1134</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Sumbaly:Roshan">Roshan Sumbaly</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kreps:Jay">Jay Kreps</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shah:Sam">Sam Shah</a></p>
<p>【Abstract】:
The use of large-scale data mining and machine learning has proliferated through the adoption of technologies such as Hadoop, with its simple programming semantics and rich and active ecosystem. This paper presents LinkedIn's Hadoop-based analytics stack, which allows data scientists and machine learning researchers to extract insights and build product features from massive amounts of data. In particular, we present our solutions to the ``last mile'' issues in providing a rich developer ecosystem. This includes easy ingress from and egress to online systems, and managing workflows as production processes. A key characteristic of our solution is that these distributed system concerns are completely abstracted away from researchers. For example, deploying data back into the online system is simply a 1-line Pig command that a data scientist can add to the end of their script. We also present case studies on how this ecosystem is used to solve problems ranging from recommendations to news feed updates to email digesting to descriptive analytical dashboards for our members.</p>
<p>【Keywords】:
big data; data mining; data pipeline; hadoop; machine learning; offline processing</p>
<h3 id="130. On brewing fresh espresso: LinkedIn's distributed data serving platform.">130. On brewing fresh espresso: LinkedIn's distributed data serving platform.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465298">Paper Link</a>】    【Pages】:1135-1146</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/q/Qiao:Lin">Lin Qiao</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Surlaker:Kapil">Kapil Surlaker</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Das:Shirshanka">Shirshanka Das</a> ; <a href="http://dblp.uni-trier.de/pers/hd/q/Quiggle:Tom">Tom Quiggle</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Schulman:Bob">Bob Schulman</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Ghosh:Bhaskar">Bhaskar Ghosh</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Curtis:Antony">Antony Curtis</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Seeliger:Oliver">Oliver Seeliger</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Zhen">Zhen Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Auradkar:Aditya">Aditya Auradkar</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Beaver:Chris">Chris Beaver</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Brandt:Gregory">Gregory Brandt</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Gandhi:Mihir">Mihir Gandhi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Gopalakrishna:Kishore">Kishore Gopalakrishna</a> ; <a href="http://dblp.uni-trier.de/pers/hd/i/Ip:Wai">Wai Ip</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Jagadish:Swaroop">Swaroop Jagadish</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lu:Shi">Shi Lu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Pachev:Alexander">Alexander Pachev</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Ramesh:Aditya">Aditya Ramesh</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Sebastian:Abraham">Abraham Sebastian</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shanbhag:Rupa">Rupa Shanbhag</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Subramaniam:Subbu">Subbu Subramaniam</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Sun:Yun">Yun Sun</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Topiwala:Sajid">Sajid Topiwala</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tran_0003:Cuong">Cuong Tran</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Westerman:Jemiah">Jemiah Westerman</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:David">David Zhang</a></p>
<p>【Abstract】:
Espresso is a document-oriented distributed data serving platform that has been built to address LinkedIn's requirements for a scalable, performant, source-of-truth primary store. It provides a hierarchical document model, transactional support for modifications to related documents, real-time secondary indexing, on-the-fly schema evolution and provides a timeline consistent change capture stream. This paper describes the motivation and design principles involved in building Espresso, the data model and capabilities exposed to clients, details of the replication and secondary indexing implementation and presents a set of experimental results that characterize the performance of the system along various dimensions. When we set out to build Espresso, we chose to apply best practices in industry, already published works in research and our own internal experience with different consistency models. Along the way, we built a novel generic distributed cluster management framework, a partition-aware change- capture pipeline and a high-performance inverted index implementation.</p>
<p>【Keywords】:
distributed key-document store; fault-tolerance</p>
<h3 id="131. Fast data in the era of big data: Twitter's real-time related query suggestion architecture.">131. Fast data in the era of big data: Twitter's real-time related query suggestion architecture.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465290">Paper Link</a>】    【Pages】:1147-1158</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Mishne:Gilad">Gilad Mishne</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Dalton:Jeff">Jeff Dalton</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Li:Zhenghua">Zhenghua Li</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Sharma:Aneesh">Aneesh Sharma</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lin:Jimmy">Jimmy Lin</a></p>
<p>【Abstract】:
We present the architecture behind Twitter's real-time related query suggestion and spelling correction service. Although these tasks have received much attention in the web search literature, the Twitter context introduces a real-time "twist": after significant breaking news events, we aim to provide relevant results within minutes. This paper provides a case study illustrating the challenges of real-time data processing in the era of "big data". We tell the story of how our system was built twice: our first implementation was built on a typical Hadoop-based analytics stack, but was later replaced because it did not meet the latency requirements necessary to generate meaningful real-time results. The second implementation, which is the system deployed in production today, is a custom in-memory processing engine specifically designed for the task. This experience taught us that the current typical usage of Hadoop as a "big data" platform, while great for experimentation, is not well suited to low-latency processing, and points the way to future work on data analytics platforms that can handle "big" as well as "fast" data.</p>
<p>【Keywords】:
hadoop; log analysis; mapreduce</p>
<h2 id="Industry session 2: enterprise data management    3">Industry session 2: enterprise data management    3</h2>
<h3 id="132. Enhancements to SQL server column stores.">132. Enhancements to SQL server column stores.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463708">Paper Link</a>】    【Pages】:1159-1168</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Larson:Per==Aring=ke">Per-Åke Larson</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Clinciu:Cipri">Cipri Clinciu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Fraser:Campbell">Campbell Fraser</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Hanson:Eric_N=">Eric N. Hanson</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Mokhtar:Mostafa">Mostafa Mokhtar</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/Nowakiewicz:Michal">Michal Nowakiewicz</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Papadimos:Vassilis">Vassilis Papadimos</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Price:Susan_L=">Susan L. Price</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Rangarajan:Srikumar">Srikumar Rangarajan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Rusanu:Remus">Remus Rusanu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Saubhasik:Mayukh">Mayukh Saubhasik</a></p>
<p>【Abstract】:
SQL Server 2012 introduced two innovations targeted for data warehousing workloads: column store indexes and batch (vectorized) processing mode. Together they greatly improve performance of typical data warehouse queries, routinely by 10X and in some cases by a 100X or more. The main limitations of the initial version are addressed in the upcoming release. Column store indexes are updatable and can be used as the base storage for a table. The repertoire of batch mode operators has been expanded, existing operators have been improved, and query optimization has been enhanced. This paper gives an overview of SQL Server's column stores and batch processing, in particular the enhancements introduced in the upcoming release.</p>
<p>【Keywords】:
column store; columnar storage; data warehousing; index; olap</p>
<h3 id="133. Query containment in entity SQL.">133. Query containment in entity SQL.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463711">Paper Link</a>】    【Pages】:1169-1172</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/r/Rull:Guillem">Guillem Rull</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bernstein:Philip_A=">Philip A. Bernstein</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Santos:Ivo_Garcia_dos">Ivo Garcia dos Santos</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Katsis:Yannis">Yannis Katsis</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Melnik:Sergey">Sergey Melnik</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Teniente:Ernest">Ernest Teniente</a></p>
<p>【Abstract】:
We describe a software architecture we have developed for a constructive containment checker of Entity SQL queries defined over extended ER schemas expressed in Microsoft's Entity Data Model. Our application of interest is compilation of object-to-relational mappings for Microsoft's ADO.NET Entity Framework, which has been shipping since 2007. The supported language includes several features which have been individually addressed in the past but, to the best of our knowledge, they have not been addressed all at once before. Moreover, when embarking on an implementation, we found no guidance in the literature on how to modularize the software or apply published algorithms to a commercially-supported language. This paper reports on our experience in addressing these real-world challenges.</p>
<p>【Keywords】:
canonical instance; entity data model; query; query containment</p>
<h3 id="134. Timeline index: a unified data structure for processing queries on temporal data in SAP HANA.">134. Timeline index: a unified data structure for processing queries on temporal data in SAP HANA.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465293">Paper Link</a>】    【Pages】:1173-1184</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/k/Kaufmann:Martin">Martin Kaufmann</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Manjili:Amin_Amiri">Amin Amiri Manjili</a> ; <a href="http://dblp.uni-trier.de/pers/hd/v/Vagenas:Panagiotis">Panagiotis Vagenas</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Fischer_0001:Peter_M=">Peter M. Fischer</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kossmann:Donald">Donald Kossmann</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/F=auml=rber:Franz">Franz Färber</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/May:Norman">Norman May</a></p>
<p>【Abstract】:
Managing temporal data is becoming increasingly important for many applications. Several database systems already support the time dimension, but provide only few temporal operators, which also often exhibit poor performance characteristics. On the academic side, a large number of algorithms and data structures have been proposed, but they often address a subset of these temporal operators only. In this paper, we develop the Timeline Index as a novel, unified data structure that efficiently supports temporal operators such as temporal aggregation, time travel, and temporal joins. As the Timeline Index is independent of the physical order of the data, it provides flexibility in physical design; e.g., it supports any kind of compression scheme, which is crucial for main memory column stores. Our experiments show that the Timeline Index has predictable performance and beats state-of-the-art approaches significantly, sometimes by orders of magnitude.</p>
<p>【Keywords】:
algorithm; index; temporal data; temporal operator</p>
<h2 id="Industry session 3: big data II and web    3">Industry session 3: big data II and web    3</h2>
<h3 id="135. LinkBench: a database benchmark based on the Facebook social graph.">135. LinkBench: a database benchmark based on the Facebook social graph.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465296">Paper Link</a>】    【Pages】:1185-1196</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Armstrong:Timothy_G=">Timothy G. Armstrong</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Ponnekanti:Vamsi">Vamsi Ponnekanti</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Borthakur:Dhruba">Dhruba Borthakur</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Callaghan:Mark">Mark Callaghan</a></p>
<p>【Abstract】:
Database benchmarks are an important tool for database researchers and practitioners that ease the process of making informed comparisons between different database hardware, software and configurations. Large scale web services such as social networks are a major and growing database application area, but currently there are few benchmarks that accurately model web service workloads. In this paper we present a new synthetic benchmark called LinkBench. LinkBench is based on traces from production databases that store "social graph" data at Facebook, a major social network. We characterize the data and query workload in many dimensions, and use the insights gained to construct a realistic synthetic benchmark. LinkBench provides a realistic and challenging test for persistent storage of social and web service data, filling a gap in the available tools for researchers, developers and administrators.</p>
<p>【Keywords】:
database benchmarks; database workload analysis; hbase; mysql; social networks</p>
<h3 id="136. BigBench: towards an industry standard benchmark for big data analytics.">136. BigBench: towards an industry standard benchmark for big data analytics.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463712">Paper Link</a>】    【Pages】:1197-1208</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/g/Ghazal:Ahmad">Ahmad Ghazal</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Rabl:Tilmann">Tilmann Rabl</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Hu:Minqing">Minqing Hu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Raab:Francois">Francois Raab</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Poess:Meikel">Meikel Poess</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Crolotte:Alain">Alain Crolotte</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Jacobsen:Hans=Arno">Hans-Arno Jacobsen</a></p>
<p>【Abstract】:
There is a tremendous interest in big data by academia, industry and a large user base. Several commercial and open source providers unleashed a variety of products to support big data storage and processing. As these products mature, there is a need to evaluate and compare the performance of these systems. In this paper, we present BigBench, an end-to-end big data benchmark proposal. The underlying business model of BigBench is a product retailer. The proposal covers a data model and synthetic data generator that addresses the variety, velocity and volume aspects of big data systems containing structured, semi-structured and unstructured data. The structured part of the BigBench data model is adopted from the TPC-DS benchmark, which is enriched with semi-structured and unstructured data components. The semi-structured part captures registered and guest user clicks on the retailer's website. The unstructured data captures product reviews submitted online. The data generator designed for BigBench provides scalable volumes of raw data based on a scale factor. The BigBench workload is designed around a set of queries against the data model. From a business prospective, the queries cover the different categories of big data analytics proposed by McKinsey. From a technical prospective, the queries are designed to span three different dimensions based on data sources, query processing types and analytic techniques. We illustrate the feasibility of BigBench by implementing it on the Teradata Aster Database. The test includes generating and loading a 200 Gigabyte BigBench data set and testing the workload by executing the BigBench queries (written using Teradata Aster SQL-MR) and reporting their response times.</p>
<p>【Keywords】:
benchmarking; big data; map reduce</p>
<h3 id="137. Building, maintaining, and using knowledge bases: a report from the trenches.">137. Building, maintaining, and using knowledge bases: a report from the trenches.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465297">Paper Link</a>】    【Pages】:1209-1220</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/d/Deshpande:Omkar">Omkar Deshpande</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lamba:Digvijay_S=">Digvijay S. Lamba</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tourn:Michel">Michel Tourn</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Das:Sanjib">Sanjib Das</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Subramaniam:Sri">Sri Subramaniam</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Rajaraman:Anand">Anand Rajaraman</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Harinarayan:Venky">Venky Harinarayan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Doan:AnHai">AnHai Doan</a></p>
<p>【Abstract】:
A knowledge base (KB) contains a set of concepts, instances, and relationships. Over the past decade, numerous KBs have been built, and used to power a growing array of applications. Despite this flurry of activities, however, surprisingly little has been published about the end-to-end process of building, maintaining, and using such KBs in industry. In this paper we describe such a process. In particular, we describe how we build, update, and curate a large KB at Kosmix, a Bay Area startup, and later at WalmartLabs, a development and research lab of Walmart. We discuss how we use this KB to power a range of applications, including query understanding, Deep Web search, in-context advertising, event monitoring in social media, product search, social gifting, and social mining. Finally, we discuss how the KB team is organized, and the lessons learned. Our goal with this paper is to provide a real-world case study, and to contribute to the emerging direction of building, maintaining, and using knowledge bases for data management applications.</p>
<p>【Keywords】:
data integration; human curation; information extraction; knowledge base; social media; taxonomy; wikipedia</p>
<h2 id="Industry session 4: systems and new hardware trends    3">Industry session 4: systems and new hardware trends    3</h2>
<h3 id="138. Query processing on smart SSDs: opportunities and challenges.">138. Query processing on smart SSDs: opportunities and challenges.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465295">Paper Link</a>】    【Pages】:1221-1230</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/d/Do:Jaeyoung">Jaeyoung Do</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kee:Yang=Suk">Yang-Suk Kee</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Patel:Jignesh_M=">Jignesh M. Patel</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Park:Chanik">Chanik Park</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Park:Kwanghyun">Kwanghyun Park</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/DeWitt:David_J=">David J. DeWitt</a></p>
<p>【Abstract】:
Data storage devices are getting "smarter." Smart Flash storage devices (a.k.a. "Smart SSD") are on the horizon and will package CPU processing and DRAM storage inside a Smart SSD, and make that available to run user programs inside a Smart SSD. The focus of this paper is on exploring the opportunities and challenges associated with exploiting this functionality of Smart SSDs for relational analytic query processing. We have implemented an initial prototype of Microsoft SQL Server running on a Samsung Smart SSD. Our results demonstrate that significant performance and energy gains can be achieved by pushing selected query processing components inside the Smart SSDs. We also identify various changes that SSD device manufacturers can make to increase the benefits of using Smart SSDs for data processing applications, and also suggest possible research opportunities for the database community.</p>
<p>【Keywords】:
smart ssd</p>
<h3 id="139. Micro adaptivity in Vectorwise.">139. Micro adaptivity in Vectorwise.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465292">Paper Link</a>】    【Pages】:1231-1242</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/r/Raducanu:Bogdan">Bogdan Raducanu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Boncz:Peter_A=">Peter A. Boncz</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zukowski:Marcin">Marcin Zukowski</a></p>
<p>【Abstract】:
Performance of query processing functions in a DBMS can be affected by many factors, including the hardware platform, data distributions, predicate parameters, compilation method, algorithmic variations and the interactions between these. Given that there are often different function implementations possible, there is a latent performance diversity which represents both a threat to performance robustness if ignored (as is usual now) and an opportunity to increase the performance if one would be able to use the best performing implementation in each situation. Micro Adaptivity, proposed here, is a framework that keeps many alternative function implementations (flavors) in a system. It uses a learning algorithm to choose the most promising flavor potentially at each function call, guided by the actual costs observed so far. We argue that Micro Adaptivity both increases performance robustness, and saves development time spent in finding and tuning heuristics and cost model thresholds in query optimization. In this paper, we (i) characterize a number of factors that cause performance diversity between primitive flavors, (ii) describe an e-greedy learning algorithm that casts the flavor selection into a multi-armed bandit problem, and (iii) describe the software framework for Micro Adaptivity that we implemented in the Vectorwise system. We provide micro-benchmarks, and an overall evaluation on TPC-H, showing consistent improvements.</p>
<p>【Keywords】:
adaptive; query processing; self tuning</p>
<h3 id="140. Hekaton: SQL server's memory-optimized OLTP engine.">140. Hekaton: SQL server's memory-optimized OLTP engine.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463710">Paper Link</a>】    【Pages】:1243-1254</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/d/Diaconu:Cristian">Cristian Diaconu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Freedman:Craig">Craig Freedman</a> ; <a href="http://dblp.uni-trier.de/pers/hd/i/Ismert:Erik">Erik Ismert</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Larson:Per==Aring=ke">Per-Åke Larson</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Mittal:Pravin">Pravin Mittal</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Stonecipher:Ryan">Ryan Stonecipher</a> ; <a href="http://dblp.uni-trier.de/pers/hd/v/Verma:Nitin">Nitin Verma</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zwilling:Mike">Mike Zwilling</a></p>
<p>【Abstract】:
Hekaton is a new database engine optimized for memory resident data and OLTP workloads. Hekaton is fully integrated into SQL Server; it is not a separate system. To take advantage of Hekaton, a user simply declares a table memory optimized. Hekaton tables are fully transactional and durable and accessed using T-SQL in the same way as regular SQL Server tables. A query can reference both Hekaton tables and regular tables and a transaction can update data in both types of tables. T-SQL stored procedures that reference only Hekaton tables can be compiled into machine code for further performance improvements. The engine is designed for high con-currency. To achieve this it uses only latch-free data structures and a new optimistic, multiversion concurrency control technique. This paper gives an overview of the design of the Hekaton engine and reports some experimental results.</p>
<p>【Keywords】:
compilation to native code; lock-free data structures; main-memory databases; multiversion concurrency control; oltp; optimistic concurrency control; sql server</p>
<h2 id="Industry session 5: big data III and more    3">Industry session 5: big data III and more    3</h2>
<h3 id="141. Split query processing in polybase.">141. Split query processing in polybase.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463709">Paper Link</a>】    【Pages】:1255-1266</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/d/DeWitt:David_J=">David J. DeWitt</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Halverson:Alan">Alan Halverson</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/Nehme:Rimma_V=">Rimma V. Nehme</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shankar:Srinath">Srinath Shankar</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Aguilar=Saborit:Josep">Josep Aguilar-Saborit</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Avanes:Artin">Artin Avanes</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Flasza:Miro">Miro Flasza</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Gramling:Jim">Jim Gramling</a></p>
<p>【Abstract】:
This paper presents Polybase, a feature of SQL Server PDW V2 that allows users to manage and query data stored in a Hadoop cluster using the standard SQL query language. Unlike other database systems that provide only a relational view over HDFS-resident data through the use of an external table mechanism, Polybase employs a split query processing paradigm in which SQL operators on HDFS-resident data are translated into MapReduce jobs by the PDW query optimizer and then executed on the Hadoop cluster. The paper describes the design and implementation of Polybase along with a thorough performance evaluation that explores the benefits of employing a split query processing paradigm for executing queries that involve both structured data in a relational DBMS and unstructured data in Hadoop. Our results demonstrate that while the use of a split-based query execution paradigm can improve the performance of some queries by as much as 10X, one must employ a cost-based query optimizer that considers a broad set of factors when deciding whether or not it is advantageous to push a SQL operator to Hadoop. These factors include the selectivity factor of the predicate, the relative sizes of the two clusters, and whether or not their nodes are co-located. In addition, differences in the semantics of the Java and SQL languages must be carefully considered in order to avoid altering the expected results of a query.</p>
<p>【Keywords】:
hadoop; hdfs; parallel database systems; split query execution</p>
<h3 id="142. Petabyte scale databases and storage systems at Facebook.">142. Petabyte scale databases and storage systems at Facebook.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463713">Paper Link</a>】    【Pages】:1267-1268</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Borthakur:Dhruba">Dhruba Borthakur</a></p>
<p>【Abstract】:
At Facebook, we use various types of databases and storage system to satisfy the needs of different applications. The solutions built around these data store systems have a common set of requirements: they have to be highly scalable, maintenance costs should be low and they have to perform efficiently. We use a sharded mySQL+memcache solution to support real-time access of tens of petabytes of data and we use TAO to provide consistency of this web-scale database across geographical distances. We use Haystack data store for storing the 3 billion new photos we host every week. We use Apache Hadoop to mine intelligence from 100 petabytes of click logs and combine it with the power of Apache HBase to store all Facebook Messages. This paper describes the reasons why each of these databases is appropriate for that workload and the design decisions and tradeoffs that were made while implementing these solutions. We touch upon the consistency, availability and partitioning tolerance of each of these solutions. We touch upon the reasons why some of these systems need ACID semantics and other systems do not. We describe the techniques we have used to map the Facebook Graph Database into a set of relational tables. We speak of how we plan to do big-data deployments across geographical locations and our requirements for a new breed of pure-memory and pure-SSD based transactional database. Esteemed researchers in the Database Management community have benchmarked query latencies on Hive/Hadoop to be less performant than a traditional Parallel DBMS. We describe why these benchmarks are insufficient for Big Data deployments and why we continue to use Hadoop/Hive. We present an alternate set of benchmark techniques that measure capacity of a database, the value/byte in that database and the efficiency of inbuilt crowd-sourcing techniques to reduce administration costs of that database.</p>
<p>【Keywords】:
bigdata; facebook</p>
<h3 id="143. Incremental mapping compilation in an object-to-relational mapping system.">143. Incremental mapping compilation in an object-to-relational mapping system.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465294">Paper Link</a>】    【Pages】:1269-1280</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Bernstein:Philip_A=">Philip A. Bernstein</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Jacob:Marie">Marie Jacob</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/P=eacute=rez_0001:Jorge">Jorge Pérez</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Rull:Guillem">Guillem Rull</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Terwilliger:James_F=">James F. Terwilliger</a></p>
<p>【Abstract】:
In an object-to-relational mapping system (ORM), mapping expressions explain how to expose relational data as objects and how to store objects in tables. If mappings are sufficiently expressive, then it is possible to define lossy mappings. If a user updates an object, stores it in the database based on a lossy mapping, and then retrieves the object from the database, the user might get a different result than the updated state of the object; that is, the mapping might not "roundtrip." To avoid this, the ORM should validate that user-defined mappings roundtrip the data. However, this problem is NP-hard, so mapping validation can be very slow for large or complex mappings. We circumvent this problem by developing an incremental compiler for OR mappings. Given a validated mapping, a modification to the object schema is compiled into incremental modifications of the mapping. We define the problem formally, present algorithms to solve it for Microsoft's Entity Framework, and report on an implementation. For some mappings, incremental compilation is over 100 times faster than a full mapping compilation, in one case dropping from 8 hours to 50 seconds.</p>
<p>【Keywords】:
incremental compilation; object-to-relational mapping</p>
<h2 id="Undergraduate research    6">Undergraduate research    6</h2>
<h3 id="144. FriendRouter: real-time path finder in social networks.">144. FriendRouter: real-time path finder in social networks.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465340">Paper Link</a>】    【Pages】:1281-1282</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/v/Viana:Wladston">Wladston Viana</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Moro:Mirella_M=">Mirella M. Moro</a></p>
<p>【Abstract】:
Online social networks have become a platform for running and optimizing classical algorithms. Here, we introduce a tool for finding paths between social network users in real-time, a task that classical solutions are not tailored for.</p>
<p>【Keywords】:
path search algorithms; social networks</p>
<h3 id="145. Adaptive log compression for massive log data.">145. Adaptive log compression for massive log data.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465341">Paper Link</a>】    【Pages】:1283-1284</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/c/Christensen:Robert">Robert Christensen</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Li:Feifei">Feifei Li</a></p>
<p>【Abstract】:
We present a novel adaptive log compression scheme. Results show 30% improvement on compression ratios over existing approaches.</p>
<p>【Keywords】:
adaptive log compression; log compression; log data management</p>
<h3 id="146. BUZZARD: a NUMA-aware in-memory indexing system.">146. BUZZARD: a NUMA-aware in-memory indexing system.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465342">Paper Link</a>】    【Pages】:1285-1286</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Maas:Lukas_M=">Lukas M. Maas</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kissinger:Thomas">Thomas Kissinger</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Habich:Dirk">Dirk Habich</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lehner:Wolfgang">Wolfgang Lehner</a></p>
<p>【Abstract】:
With the availability of large main memory capacities, in-memory index structures have become an important component of modern data management platforms. Current research even suggests index-based query processing as an alternative or supplement for traditional tuple-at-a-time processing models. However, while simple sequential scan operations can fully exploit the high bandwidth provided by main memory, indexes are mainly latency bound and spend most of their time waiting for memory accesses. Considering current hardware trends, the problem of high memory latency is further exacerbated as modern shared-memory multiprocessors with non-uniform memory access (NUMA) become increasingly common. On those NUMA platforms, the execution time of index operations is dominated by memory access latency that increases dramatically when accessing memory on remote sockets. Therefore, good index performance can only be achieved through careful optimization of the index structure to the given topology. BUZZARD is a NUMA-aware in-memory indexing system. Using adaptive data partitioning techniques, BUZZARD distributes a prefix-tree-based index across the NUMA system and hands off incoming requests to worker threads located on each partition's respective NUMA node. This approach reduces the number of remote memory accesses to a minimum and improves cache utilization. In addition, all indexes inside BUZZARD are only accessed by their respective owner, eliminating the need for synchronization primitives like compare-and-swap.</p>
<p>【Keywords】:
in-memory; indexing; numa; prefix trees</p>
<h3 id="147. Resa: realtime elastic streaming analytics in the cloud.">147. Resa: realtime elastic streaming analytics in the cloud.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465343">Paper Link</a>】    【Pages】:1287-1288</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/t/Tan:Tian">Tian Tan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Ma:Richard_T=_B=">Richard T. B. Ma</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Winslett:Marianne">Marianne Winslett</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yang:Yin">Yin Yang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yu:Yong">Yong Yu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Zhenjie">Zhenjie Zhang</a></p>
<p>【Abstract】:
We propose Resa, a novel framework for robust, elastic and realtime stream processing in the cloud. In addition to traditional functionalities of streaming and cloud systems, Resa provides (i) a novel mechanism that handles dynamic additions and removals nodes in an operator, and (ii) a node re-assignment scheme that minimizes output latency using a queuing model. We have implemented Resa on top of Twitter Storm. Experiments using real data demonstrate the effectiveness and efficiency of Resa.</p>
<p>【Keywords】:
cloud; migration; resource allocation; stream</p>
<h3 id="148. Natural language question answering over RDF data.">148. Natural language question answering over RDF data.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2463725">Paper Link</a>】    【Pages】:1289-1290</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/h/Huang:Ruizhe">Ruizhe Huang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zou:Lei">Lei Zou</a></p>
<p>【Abstract】:
As more and more RDF data becomes available, such as DBpedia, Yago and Freebase, it is desired to provide users with simple interfaces to access the datasets. Although the SPARQL query language is a standard way to query RDF data, it remains tedious and difficult even for expert users because of the formality of the language and the complexity of the underlying schema of RDF data. An ideal system should allow users to express queries in their own languages. In this work, we propose a methodology to translate natural language questions into SPARQL queries, which can be answered by existing RDF engines and fulfill users? information need.</p>
<p>【Keywords】:
natural language; question answering; rdf; sparql</p>
<h3 id="149. Mobile interaction and query optimizationin a protein-ligand data analysis system.">149. Mobile interaction and query optimizationin a protein-ligand data analysis system.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2465344">Paper Link</a>】    【Pages】:1291-1292</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Lapeine:Marvin">Marvin Lapeine</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Herbert:Katherine_G=">Katherine G. Herbert</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Hill:Emily">Emily Hill</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Goodey:Nina_M=">Nina M. Goodey</a></p>
<p>【Abstract】:
With current trends in integrating phylogenetic analysis into pharma-research, computing systems that integrate the two areas can help the drug discovery field. DrugTree is a tool that overlays ligand data on a protein-motivated phylogenetic tree. While initial tests of DrugTree are successful, it has been noticed that there are a number of lags concerning querying the tree. Due to the interleaving nature of the data, query optimization can become problematic since the data is being obtained from multiple sources, integrated and then presented to the user with the phylogenetic imposed upon the phylogenetic analysis layer. This poster presents our initial methodologies for addressing the query optimization issues. Our approach applies standards as well as uses novel mechanisms to help improve performance time.</p>
<p>【Keywords】:
bioinformatics; data integration; pharmaceutical informatics; phylogenetics; query processing</p>
<h2 id="New researcher symposium    1">New researcher symposium    1</h2>
<h3 id="150. SIGMOD 2013 new researcher symposium.">150. SIGMOD 2013 new researcher symposium.</h3>
<p>【<a href="http://doi.acm.org/10.1145/2463676.2483587">Paper Link</a>】    【Pages】:1293-1294</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Sarma:Anish_Das">Anish Das Sarma</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Dong:Xin_Luna">Xin Luna Dong</a></p>
<p>【Abstract】:</p>
<p>【Keywords】:
data management career; job search; paper writing; research</p>
 

<div class="home">
<i title='主页' onclick="location.href='../index.html'"><i class="fa fa-home fa-lg"></i></i>
</div>

<div class="toc">
<i id="showLeftPush" title='目录'><i class="fa fa-list fa-lg"></i></i>
</div>

<!-- Classie - class helper functions by @desandro https://github.com/desandro/classie -->
<script>
	var menuLeft = document.getElementById( 'menu-s1' ),
		showLeftPush = document.getElementById( 'showLeftPush' ),
		body = document.body;

	showLeftPush.onclick = function() {
		classie.toggle( this, 'active' );
		classie.toggle( body, 'cbp-spmenu-push-toright' );
		classie.toggle( menuLeft, 'cbp-spmenu-open' );
		disableOther( 'showLeftPush' );
	};
</script>

<div class="go-top" >
<i title='顶部' onclick="window.scrollTo('0', '0')"><i class="fa fa-angle-double-up fa-2x"></i></i>
</div>

<div class="theme" >
<i title='主题' onclick="change_css()"><i class="fa fa-adjust fa-lg"></i></i>
</div>

<div id="footer">

  <p> <i class="fa fa-envelope-o fa-1x"></i>:&nbsp huntercmd@163.com &nbsp Published under<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh"> (CC) BY-NC-SA 3.0</a></p>

  <p>&copy; 2013 HunterCmd &nbsp <a href="http://huntercmd.github.io"><i class="fa fa-github fa-1x"></i>
  </p>
</div>

</body>
