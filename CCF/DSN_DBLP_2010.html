 
<head>
<meta name="HunterCmd" charset="utf-8">

<link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link id="cssfile" rel="stylesheet" type="text/css" href="https://cdn.rawgit.com/huntercmd/blog/master/config/css/light.css">
<script src="https://cdn.rawgit.com/huntercmd/blog/master/config/css/skin.js"></script>
<script src="https://cdn.rawgit.com/huntercmd/blog/master/config/css/classie.js"></script>

<!-- This is for Mathjax -->

<script type="text/x-mathjax-config">
	MathJax.Hub.Config({
		tex2jax: {
			inlineMath: [ ['$','$'], ["$","$"] ],
			displayMath: [ ['$$','$$'], ["$$","$$"] ],
			processEscapes: true
			},
		TeX: {equationNumbers: {autoNumber: ["AMS"], useLabelIds: true}},
		"HTML-CSS": {linebreaks: {automatic: true}},
		SVG: {linebreaks: {automatic: true}}
	});
</script>

<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<title>HunterCmd</title>
</head>

<body class="cbp-spmenu-push">

<nav class="cbp-spmenu cbp-spmenu-vertical cbp-spmenu-left" id="menu-s1" style="width: 320px;overflow: auto;
">

<h1>Table of contents</h1>
<ul>
<li><a href="#DSN 2010:Chicago, IL, USA">DSN 2010:Chicago, IL, USA</a><ul>
<li><a href="#Paper Num: 69 || Session Num: 0">Paper Num: 69 || Session Num: 0</a><ul>
<li><a href="#1. Scalable RFID systems: a privacy-preserving protocol with constant-time identification.">1. Scalable RFID systems: a privacy-preserving protocol with constant-time identification.</a></li>
<li><a href="#2. Detecting selfish carrier-sense behavior in WiFi networks by passive monitoring.">2. Detecting selfish carrier-sense behavior in WiFi networks by passive monitoring.</a></li>
<li><a href="#3. Detecting Sybil nodes in wireless networks with physical layer network coding.">3. Detecting Sybil nodes in wireless networks with physical layer network coding.</a></li>
<li><a href="#4. Observable non-Sybil quorums construction in one-hop wireless ad hoc networks.">4. Observable non-Sybil quorums construction in one-hop wireless ad hoc networks.</a></li>
<li><a href="#5. Reliable MLC NAND flash memories based on nonlinear t-error-correcting codes.">5. Reliable MLC NAND flash memories based on nonlinear t-error-correcting codes.</a></li>
<li><a href="#6. Code-M: A non-MDS erasure code scheme to support fast recovery from up to two-disk failures in storage systems.">6. Code-M: A non-MDS erasure code scheme to support fast recovery from up to two-disk failures in storage systems.</a></li>
<li><a href="#7. Decoding STAR code for tolerating simultaneous disk failure and silent errors.">7. Decoding STAR code for tolerating simultaneous disk failure and silent errors.</a></li>
<li><a href="#8. Diverse Partial Memory Replication.">8. Diverse Partial Memory Replication.</a></li>
<li><a href="#9. Data recovery for web applications.">9. Data recovery for web applications.</a></li>
<li><a href="#10. Programming support and adaptive checkpointing for high-throughput data services with log-based recovery.">10. Programming support and adaptive checkpointing for high-throughput data services with log-based recovery.</a></li>
<li><a href="#11. StageWeb: Interweaving pipeline stages into a wearout and variation tolerant CMP fabric.">11. StageWeb: Interweaving pipeline stages into a wearout and variation tolerant CMP fabric.</a></li>
<li><a href="#12. Architecting reliable multi-core network-on-chip for small scale processing technology.">12. Architecting reliable multi-core network-on-chip for small scale processing technology.</a></li>
<li><a href="#13. Energy-efficient fault tolerance in chip multiprocessors using Critical Value Forwarding.">13. Energy-efficient fault tolerance in chip multiprocessors using Critical Value Forwarding.</a></li>
<li><a href="#14. A fast and accurate multi-cycle soft error rate estimation approach to resilient embedded systems design.">14. A fast and accurate multi-cycle soft error rate estimation approach to resilient embedded systems design.</a></li>
<li><a href="#15. Bit-slice logic interleaving for spatial multi-bit soft-error tolerance.">15. Bit-slice logic interleaving for spatial multi-bit soft-error tolerance.</a></li>
<li><a href="#16. WearMon: Reliability monitoring using adaptive critical path testing.">16. WearMon: Reliability monitoring using adaptive critical path testing.</a></li>
<li><a href="#17. A numerical optimization-based methodology for application robustification: Transforming applications for error tolerance.">17. A numerical optimization-based methodology for application robustification: Transforming applications for error tolerance.</a></li>
<li><a href="#18. Blue Banana: resilience to avatar mobility in distributed MMOGs.">18. Blue Banana: resilience to avatar mobility in distributed MMOGs.</a></li>
<li><a href="#19. Efficient eventual consistency in Pahoehoe, an erasure-coded key-blob archive.">19. Efficient eventual consistency in Pahoehoe, an erasure-coded key-blob archive.</a></li>
<li><a href="#20. Using correlated surprise to infer shared influence.">20. Using correlated surprise to infer shared influence.</a></li>
<li><a href="#21. Keystroke biometrics with number-pad input.">21. Keystroke biometrics with number-pad input.</a></li>
<li><a href="#22. Using Bayesian networks for cyber security analysis.">22. Using Bayesian networks for cyber security analysis.</a></li>
<li><a href="#23. A study of the internal and external effects of concurrency bugs.">23. A study of the internal and external effects of concurrency bugs.</a></li>
<li><a href="#24. AutomaDeD: Automata-based debugging for dissimilar parallel tasks.">24. AutomaDeD: Automata-based debugging for dissimilar parallel tasks.</a></li>
<li><a href="#25. Detecting vulnerabilities in C programs using trace-based testing.">25. Detecting vulnerabilities in C programs using trace-based testing.</a></li>
<li><a href="#26. Mash-IF: Practical information-flow control within client-side mashups.">26. Mash-IF: Practical information-flow control within client-side mashups.</a></li>
<li><a href="#27. DataGuard: Dynamic data attestation in wireless sensor networks.">27. DataGuard: Dynamic data attestation in wireless sensor networks.</a></li>
<li><a href="#28. iProve: A scalable technique for consumer-verifiable software guarantees.">28. iProve: A scalable technique for consumer-verifiable software guarantees.</a></li>
<li><a href="#29. Reuse-oriented camouflaging trojan: Vulnerability detection and attack construction.">29. Reuse-oriented camouflaging trojan: Vulnerability detection and attack construction.</a></li>
<li><a href="#30. Detection of botnets using combined host- and network-level information.">30. Detection of botnets using combined host- and network-level information.</a></li>
<li><a href="#31. Dependable connection setup for network capabilities.">31. Dependable connection setup for network capabilities.</a></li>
<li><a href="#32. Why software hangs and what can be done with it.">32. Why software hangs and what can be done with it.</a></li>
<li><a href="#33. Finding stable cliques of PlanetLab nodes.">33. Finding stable cliques of PlanetLab nodes.</a></li>
<li><a href="#34. Who is peeping at your passwords at Starbucks? - To catch an evil twin access point.">34. Who is peeping at your passwords at Starbucks? - To catch an evil twin access point.</a></li>
<li><a href="#35. Improving privacy and lifetime of PCM-based main memory.">35. Improving privacy and lifetime of PCM-based main memory.</a></li>
<li><a href="#36. Generic construction of consensus algorithms for benign and Byzantine faults.">36. Generic construction of consensus algorithms for benign and Byzantine faults.</a></li>
<li><a href="#37. Scrooge: Reducing the costs of fast Byzantine replication in presence of unresponsive replicas.">37. Scrooge: Reducing the costs of fast Byzantine replication in presence of unresponsive replicas.</a></li>
<li><a href="#38. Zzyzx: Scalable fault tolerance through Byzantine locking.">38. Zzyzx: Scalable fault tolerance through Byzantine locking.</a></li>
<li><a href="#39. Doubly-expedited one-step Byzantine consensus.">39. Doubly-expedited one-step Byzantine consensus.</a></li>
<li><a href="#40. A passive approach to wireless device fingerprinting.">40. A passive approach to wireless device fingerprinting.</a></li>
<li><a href="#41. Exploiting diverse observation perspectives to get insights on the malware landscape.">41. Exploiting diverse observation perspectives to get insights on the malware landscape.</a></li>
<li><a href="#42. Combined performance and risk analysis for border management applications.">42. Combined performance and risk analysis for border management applications.</a></li>
<li><a href="#43. Experimental validation of a fault tolerant microcomputer system against intermittent faults.">43. Experimental validation of a fault tolerant microcomputer system against intermittent faults.</a></li>
<li><a href="#44. Evaluating repair strategies for a water-treatment facility using Arcade.">44. Evaluating repair strategies for a water-treatment facility using Arcade.</a></li>
<li><a href="#45. Application of a fault injection based dependability assessment process to a commercial safety critical nuclear reactor protection system.">45. Application of a fault injection based dependability assessment process to a commercial safety critical nuclear reactor protection system.</a></li>
<li><a href="#46. Measurement-based analysis of fault and error sensitivities of dynamic memory.">46. Measurement-based analysis of fault and error sensitivities of dynamic memory.</a></li>
<li><a href="#47. Representativeness analysis of injected software faults in complex software.">47. Representativeness analysis of injected software faults in complex software.</a></li>
<li><a href="#48. An empirical investigation of fault types in space mission system software.">48. An empirical investigation of fault types in space mission system software.</a></li>
<li><a href="#49. Assessing and improving the effectiveness of logs for the analysis of software faults.">49. Assessing and improving the effectiveness of logs for the analysis of software faults.</a></li>
<li><a href="#50. Statistical guarantees of performance for MIMO designs.">50. Statistical guarantees of performance for MIMO designs.</a></li>
<li><a href="#51. Transient fault models and AVF estimation revisited.">51. Transient fault models and AVF estimation revisited.</a></li>
<li><a href="#52. A unified model for timing speculation: Evaluating the impact of technology scaling, CMOS design style, and fault recovery mechanism.">52. A unified model for timing speculation: Evaluating the impact of technology scaling, CMOS design style, and fault recovery mechanism.</a></li>
<li><a href="#53. Performance and availability aware regeneration for cloud based multitier applications.">53. Performance and availability aware regeneration for cloud based multitier applications.</a></li>
<li><a href="#54. Adaptive on-line software aging prediction based on machine learning.">54. Adaptive on-line software aging prediction based on machine learning.</a></li>
<li><a href="#55. Correlating failures with asynchronous changes for root cause analysis in enterprise environments.">55. Correlating failures with asynchronous changes for root cause analysis in enterprise environments.</a></li>
<li><a href="#56. Ring Paxos: A high-throughput atomic broadcast protocol.">56. Ring Paxos: A high-throughput atomic broadcast protocol.</a></li>
<li><a href="#57. Turquois: Byzantine consensus in wireless ad hoc networks.">57. Turquois: Byzantine consensus in wireless ad hoc networks.</a></li>
<li><a href="#58. Diversity-inspired clustering for self-healing MANETs: Motivation, protocol, and performability evaluation.">58. Diversity-inspired clustering for self-healing MANETs: Motivation, protocol, and performability evaluation.</a></li>
<li><a href="#59. GOOFI-2: A tool for experimental dependability assessment.">59. GOOFI-2: A tool for experimental dependability assessment.</a></li>
<li><a href="#60. Studying application-library interaction and behavior with LibTrac.">60. Studying application-library interaction and behavior with LibTrac.</a></li>
<li><a href="#61. Experiences with a CANoe-based fault injection framework for AUTOSAR.">61. Experiences with a CANoe-based fault injection framework for AUTOSAR.</a></li>
<li><a href="#62. Empirical characterization of uncongested optical lambda networks and 10GbE commodity endpoints.">62. Empirical characterization of uncongested optical lambda networks and 10GbE commodity endpoints.</a></li>
<li><a href="#63. On/off process modeling of IP network failures.">63. On/off process modeling of IP network failures.</a></li>
<li><a href="#64. An automated technique to support the verification and validation of simulation models.">64. An automated technique to support the verification and validation of simulation models.</a></li>
<li><a href="#65. Model checking CSLTA with Deterministic and Stochastic Petri Nets.">65. Model checking CSLTA with Deterministic and Stochastic Petri Nets.</a></li>
<li><a href="#66. 1st workshop on fault-tolerance for HPC at extreme scale FTXS 2010.">66. 1st workshop on fault-tolerance for HPC at extreme scale FTXS 2010.</a></li>
<li><a href="#67. Second workshop on proactive failure avoidance, recovery, and maintenance (PFARM">67. Second workshop on proactive failure avoidance, recovery, and maintenance (PFARM).</a>.)</li>
<li><a href="#68. Fourth workshop on dependable and secure nanocomputing.">68. Fourth workshop on dependable and secure nanocomputing.</a></li>
<li><a href="#69. 4th workshop on recent advances in intrusion-tolerant systems WRAITS 2010.">69. 4th workshop on recent advances in intrusion-tolerant systems WRAITS 2010.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav><h1 id="DSN 2010:Chicago, IL, USA">DSN 2010:Chicago, IL, USA</h1>
<p><a href="http://ieeexplore.ieee.org/xpl/mostRecentIssue.jsp?punumber=5532324">Proceedings of the 2010 IEEE/IFIP International Conference on Dependable Systems and Networks, DSN 2010, Chicago, IL, USA, June 28 - July 1 2010.</a> IEEE Computer Society
【<a href="http://dblp.uni-trier.de/db/conf/dsn/dsn2010.html">DBLP Link</a>】</p>
<h2 id="Paper Num: 69 || Session Num: 0">Paper Num: 69 || Session Num: 0</h2>
<h3 id="1. Scalable RFID systems: a privacy-preserving protocol with constant-time identification.">1. Scalable RFID systems: a privacy-preserving protocol with constant-time identification.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5545008">Paper Link</a>】    【Pages】:1-10</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Alomair:Basel">Basel Alomair</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Clark:Andrew">Andrew Clark</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Cu=eacute=llar:Jorge">Jorge Cuéllar</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Poovendran:Radha">Radha Poovendran</a></p>
<p>【Abstract】:
In RFID literature, most &#x201C;privacy-preserving&#x201D; protocols require the reader to search all tags in the system in order to identify a single tag. In another class of protocols, the search complexity is reduced to be logarithmic in the number of tags, but it comes with two major drawbacks: it requires a large communication overhead over the fragile wireless channel, and the compromise of a tag in the system reveals secret information about other, uncompro-mised, tags in the same system. In this work, we take a different approach to address time-complexity of private identification in large-scale RFID systems. We utilize the special architecture of RFID systems to propose the first symmetric-key privacy-preserving authentication protocol for RFID systems with constant-time identification. Instead of increasing communication overhead, the existence of a large storage device in RFID systems, the database, is utilized for improving the time efficiency of tag identification.</p>
<p>【Keywords】:
Radiofrequency identification; Radio frequency; Public key; RFID tags; Public key cryptography; Databases; Data privacy; Wireless application protocol; Large-scale systems; Authentication</p>
<h3 id="2. Detecting selfish carrier-sense behavior in WiFi networks by passive monitoring.">2. Detecting selfish carrier-sense behavior in WiFi networks by passive monitoring.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544261">Paper Link</a>】    【Pages】:11-20</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/p/Paul:Utpal">Utpal Paul</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Das:Samir_R=">Samir R. Das</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Maheshwari:Ritesh">Ritesh Maheshwari</a></p>
<p>【Abstract】:
With the advent of programmability in radios, it is becoming easier for wireless network nodes to cheat to obtain an unfair share of the bandwidth. In this work we study the widely used 802.11 protocol and present a solution to detect selfish carrier-sensing behavior where a node raises the CCA (clear channel assessment) threshold for carrier-sensing, or simply does not sense carrier (possibly randomly to avoid detection). Our approach is based on detecting any asymmetry in carrier-sense behavior between node pairs and finding multiple such witnesses to raise confidence. The approach is completely passive. It requires deploying multiple sniffers across the network to capture wireless traffic traces. These traces are then analyzed by using a machine learning approach to infer carrier-sense relationships between network nodes. Evaluations using a real testbed as well as ns2 simulation studies demonstrate excellent detection ability. The metric of selfishness used to estimate selfish behaviormatches closely with actual degree of selfishness observed.</p>
<p>【Keywords】:
MAC layer misbehavior; 802.11 protocol; Hidden Markov Model</p>
<h3 id="3. Detecting Sybil nodes in wireless networks with physical layer network coding.">3. Detecting Sybil nodes in wireless networks with physical layer network coding.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5545011">Paper Link</a>】    【Pages】:21-30</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Weichao">Weichao Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Pu:Di">Di Pu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wyglinski:Alexander_M=">Alexander M. Wyglinski</a></p>
<p>【Abstract】:
Previous research on the security of network coding focuses on the detection of pollution attacks. The capabilities of network coding to detect malicious attacks have not been fully explored. We propose a new mechanism based on physical layer network coding to detect the Sybil nodes. When two signal sequences collide at the receiver, the starting point of the collision is determined by the distances between the receiver and the senders. When the distance between two receivers is large enough, they can combine their interference sequences to recover the original data packets. On the contrary, the Sybil nodes attached to the same physical device cannot accomplish the data recovery procedure. We have proposed several schemes at both physical and network layers to transform the idea into a practical approach. The investigation shows that the wireless nodes can effectively detect Sybil nodes without the adoption of special hardware or time synchronization.</p>
<p>【Keywords】:
Wireless networks; Physical layer; Network coding; Hardware; Pollution; Communication system security; Data security; Interference; Network topology; Routing protocols</p>
<h3 id="4. Observable non-Sybil quorums construction in one-hop wireless ad hoc networks.">4. Observable non-Sybil quorums construction in one-hop wireless ad hoc networks.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5545006">Paper Link</a>】    【Pages】:31-40</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/M=oacute=nica:Diogo">Diogo Mónica</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Leit=atilde=o:Jo=atilde=o">João Leitão</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Rodrigues:Lu=iacute=s_E=_T=">Luís E. T. Rodrigues</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Ribeiro:Carlos">Carlos Ribeiro</a></p>
<p>【Abstract】:
The Sybil Attack is a serious threat to the secure and dependable operation of wireless ad hoc networks. This paper proposes an algorithm to provide each correct node in an one-hop wireless network with a quorum of non-Sybil identities from the neighbourhood. The quorums provided to different correct nodes may differ, but their intersection is composed by a majority of correct identities, with an arbitrarily close to 1 probability. Therefore, the quorums may be used for different purposes, such as voting. The algorithm is based on the combination of different resource tests, to efficiently detect (and exclude) Sybil identities.</p>
<p>【Keywords】:
Mobile ad hoc networks; Voting; Ad hoc networks; Wireless networks; System testing; Aggregates; Robustness; Routing protocols; Intrusion detection; Wireless communication</p>
<h3 id="5. Reliable MLC NAND flash memories based on nonlinear t-error-correcting codes.">5. Reliable MLC NAND flash memories based on nonlinear t-error-correcting codes.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5545014">Paper Link</a>】    【Pages】:41-50</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Zhen">Zhen Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Karpovsky:Mark_G=">Mark G. Karpovsky</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Joshi:Ajay">Ajay Joshi</a></p>
<p>【Abstract】:
Multi-level cell (MLC) NAND flash memories are very popular storage media because of their power efficiency and big storage density. This paper proposes to use nonlinear t-error-correcting codes to replace linear BCH codes for error detection and correction in MLC NAND flash memories. Compared to linear BCH codes with the same bit-error correcting capability t, the proposed codes have less errors miscorrected by all codewords and nearly no undetectable errors. For example, the proposed (8281, 8201, 11) 5-error-correcting code has no errors of multiplicity six miscorrected by all codewords while the widely used (8262, 8192, 11) linear shortened BCH code has 11 over 6 &#x00D7; A<inf>11</inf> errors in this class, where A<inf>11</inf> &#x2248; 10<sup>14</sup> is the number of codewords of Hamming weight eleven in the shortened BCH code. Moreover, in spite of the fact that the Hamming distance of the proposed code is 2t+1, it can also correct some errors of multiplicity t+1 and t+2 requiring no extra hardware overhead and latency penalty. In this paper, the constructions and the error correction algorithm for the nonlinear t-error-correcting codes are presented. The architecture of the encoder and the decoder for the codes are shown. The error correcting capabilities, the hardware overhead, the latency and the power consumption for the encoder and the decoder will be analyzed and compared to that of the linear BCH codes to demonstrate the advantages of the proposed codes for error detection and correction in MLC NAND flash memories.</p>
<p>【Keywords】:
Error correction codes; Power system reliability; Hardware; Delay; Decoding; Portable media players; Threshold voltage; Bit error rate; Computer networks; Laboratories</p>
<h3 id="6. Code-M: A non-MDS erasure code scheme to support fast recovery from up to two-disk failures in storage systems.">6. Code-M: A non-MDS erasure code scheme to support fast recovery from up to two-disk failures in storage systems.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5545009">Paper Link</a>】    【Pages】:51-60</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/w/Wan:Shenggang">Shenggang Wan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Cao:Qiang">Qiang Cao</a> ; <a href="http://dblp.uni-trier.de/pers/hd/x/Xie:Changsheng">Changsheng Xie</a> ; <a href="http://dblp.uni-trier.de/pers/hd/e/Eckart:Benjamin">Benjamin Eckart</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/He:Xubin">Xubin He</a></p>
<p>【Abstract】:
In this paper, we present a novel coding scheme that can tolerate up to two-disk failures, satisfying the RAID-6 property. Our coding scheme, Code-M, is a non-MDS (Maximum Distance Separable, tolerating maximum failures with a given amount of redundancy) code that is optimized by trading rate for fast recovery times. Code-M is lowest density and its parity chain length is fixed at 2C &#x2212; 1 for a given number of columns in a strip-set C. The rate of Code-M, or percentage of disk space occupied by non-parity data, is (C &#x2212; 1)/C. We perform theoretical analysis and evaluation of the coding scheme under different configurations. Our theoretical analysis shows that Code-M has favorable reconstruction times compared to RDP, another well-established RAID-6 code. The quantitative comparisons of Code-M against RDP demonstrate recovery performance improvement by a factor of up to 5.18 under single disk failure and 2.8 under double failures using the same number of disks. Overall, Code-M is a RAID-6 type code supporting fast recovery with reduced I/O complexity.</p>
<p>【Keywords】:
Disk drives; Computer networks; Redundancy; Performance evaluation; Performance analysis; Helium; Costs</p>
<h3 id="7. Decoding STAR code for tolerating simultaneous disk failure and silent errors.">7. Decoding STAR code for tolerating simultaneous disk failure and silent errors.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544948">Paper Link</a>】    【Pages】:61-70</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Luo:Jianqiang">Jianqiang Luo</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Huang:Cheng">Cheng Huang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/x/Xu:Lihao">Lihao Xu</a></p>
<p>【Abstract】:
As storage systems grow in size and complexity, various hardware and software component failures inevitably occur, resulting in disk malfunction in failures, as well as silent errors. Existing techniques and schemes overcome the failures and silent errors in a separate fashion. In this paper, we advocate using the STAR code as a unified and systematic mechanism to simultaneously tolerate failures on one disk and silent errors on another. By exploring the unique geometric structure of the STAR code, we propose a novel efficient decoding algorithm - EEL. Both theoretical and experimental performance evaluations show that EEL constantly outperforms a naive Try-and-Test approach by large factors in overall decoding throughput.</p>
<p>【Keywords】:
Decoding; Error correction codes; Error correction; Disk drives; Hardware; Microprogramming; Performance loss; Throughput; Software performance; Computer bugs</p>
<h3 id="8. Diverse Partial Memory Replication.">8. Diverse Partial Memory Replication.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5545012">Paper Link</a>】    【Pages】:71-80</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Lefever:Ryan_M=">Ryan M. Lefever</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Adve:Vikram_S=">Vikram S. Adve</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Sanders:William_H=">William H. Sanders</a></p>
<p>【Abstract】:
An important approach for software dependability is the use of diversity to detect and/or tolerate errors. We develop and evaluate an approach for automated program diversity called Diverse Partial Memory Replication (DPMR), aimed at detecting memory safety errors. DPMR is an automatic compiler transformation that replicates some subset of an executable's data memory and applies one or more diversity transformations to the replica. DPMR can detect any kind of memory safety errors in any part of a program's data memory. Moreover, DPMR is novel because it uses partial replication within a single address space, replicating (and comparing) only a subset of a program's memory. We also perform a detailed study of the diversity mechanisms and state comparison policies in DPMR (a first of its kind for such diversity approaches), which is valuable for exploiting the high flexibility of DPMR.</p>
<p>【Keywords】:
experimental evaluation; software memory errors; diversity; replication; fault injection</p>
<h3 id="9. Data recovery for web applications.">9. Data recovery for web applications.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544951">Paper Link</a>】    【Pages】:81-90</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Akkus:Istemi_Ekin">Istemi Ekin Akkus</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Goel:Ashvin">Ashvin Goel</a></p>
<p>【Abstract】:
Web-based applications store their data at the server side. This design has several benefits, but it can also cause a serious problem because a misconfiguration, bug or vulnerability leading to data loss or corruption can affect many users. While data backup solutions can help resolve some of these issues, they do not help diagnose the events that led to the corruption or the precise set of changes caused by these events. In this paper, we describe the design of a recovery system that helps administrators recover from data corruption caused by bugs in web applications. Our system tracks application requests, helping identify requests that cause data corruption, and reuses undo logs already kept by databases to selectively recover from the effects of these requests. The main challenge is to correlate requests across the multiple tiers of the application to determine the correct recovery actions. We explore using dependencies both within and across requests at three layers (database, application, and client) to help identify data corruption accurately. We evaluate our system using known bugs in popular web applications, including Wordpress, Drupal and Gallery2. Our results show that our system enables recovery from data corruption without loss of critical data and incurs small runtime overhead.</p>
<p>【Keywords】:
Computer bugs; Databases; Network servers; Runtime; Manuals; Content management; Pricing; Testing; Blogs</p>
<h3 id="10. Programming support and adaptive checkpointing for high-throughput data services with log-based recovery.">10. Programming support and adaptive checkpointing for high-throughput data services with log-based recovery.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5545015">Paper Link</a>】    【Pages】:91-100</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/z/Zhou:Jingyu">Jingyu Zhou</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Caijie">Caijie Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tang:Hong">Hong Tang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wu:Jiesheng">Jiesheng Wu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yang:Tao">Tao Yang</a></p>
<p>【Abstract】:
Many applications in large-scale data mining and offline processing are organized as network services, running continuously or for a long period of time. To sustain high-throughput, these services often keep their data in memory, thus susceptible to failures. On the other hand, the availability requirement for these services is not as stringent as online services exposed to millions of users. But those data-intensive offline or mining applications do require data persistence to survive failures. This paper presents programming and runtime support called SLACH for building multi-threaded high-throughput persistent services. To keep in-memory objects persistent, SLACH employs application-assisted logging and checkpointing for log-based recovery while maximizing throughput and concurrency. SLACH adaptively adjusts checkpointing frequency based on log growth and throughput demand to balance between runtime overhead and recovery speed. This paper describes the design and API of SLACH, adaptive checkpoint control, and our experiences and experiments in using SLACH at Ask.com.</p>
<p>【Keywords】:
Checkpointing; Runtime; Throughput; Large-scale systems; Data mining; Availability; Buildings; Concurrent computing; Frequency; Programmable control</p>
<h3 id="11. StageWeb: Interweaving pipeline stages into a wearout and variation tolerant CMP fabric.">11. StageWeb: Interweaving pipeline stages into a wearout and variation tolerant CMP fabric.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544915">Paper Link</a>】    【Pages】:101-110</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/g/Gupta:Shantanu">Shantanu Gupta</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Ansari:Amin">Amin Ansari</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Feng:Shuguang">Shuguang Feng</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Mahlke:Scott_A=">Scott A. Mahlke</a></p>
<p>【Abstract】:
Manufacture-time process variation and life-time failure projections have become a major industry concern. Consequently, fault tolerance, historically of interest only for mission-critical systems, is now gaining attention in the mainstream computing space. Traditionally reliability issues have been addressed at a coarse granularity, e.g., by disabling faulty cores in chip multiprocessors. However, this is not scalable to higher failure rates. In this paper, we propose StageWeb, a fine-grained wearout and variation tolerance solution, that employs a reconfigurable web of replicated processor pipeline stages to construct dependable many-core chips. The interconnection flexibility of StageWeb simultaneously tackles wearout failures (by isolating broken stages) and process variation (by selectively disabling slower stages). Our experiments show that through its wearout tolerance, a StageWeb chip performs up to 70% more cumulative work than a comparable chip multiprocessor. Further, variation mitigation in StageWeb enables it to scale supply voltage more aggressively, resulting in up to 16% energy savings.</p>
<p>【Keywords】:
reliability; permanent faults; process variation; multicore; architecture</p>
<h3 id="12. Architecting reliable multi-core network-on-chip for small scale processing technology.">12. Architecting reliable multi-core network-on-chip for small scale processing technology.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544949">Paper Link</a>】    【Pages】:111-120</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/f/Fu:Xin">Xin Fu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Li:Tao">Tao Li</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Fortes:Jos=eacute=_A=_B=">José A. B. Fortes</a></p>
<p>【Abstract】:
The trend towards multi-/many- core design has made network-on-chip (NoC) a crucial component of future microprocessors. With CMOS processing technologies continuously scaling down to the nanometer regime, effects such as process variation (PV) and negative bias temperature instability (NBTI) significantly decrease hardware reliability and lifetime. Therefore, it is imperative for multi-core architects to consider and mitigate these effects in NoCs implemented using small-scale processing technology. This paper reports on a first step to optimize NoC architecture reliability in light of both PV and NBTI effects. We propose novel techniques that can hierarchically alleviate PV and NBTI effects on NoC while leveraging their benign interaction. Our low-level design improves PV and NBTI efficiency of key components (e.g. virtual channel allocation logics, virtual channels) of critical paths of the pipelined router microarchitecture. Our high-level mechanisms leverage NBTI degradation and PV information from multiple routers to intelligently route packets, delivering optimized performance-power-reliability across the NoC substrate. Experimental results show that our intra-router level techniques (i.e. VA_M1 and VC_M2) reduce guardband by 47% while improving network throughput by 24%. Our inter-router optimization scheme (i.e. IR_M3) results in 50% guardband reduction and 19% network latency improvement.</p>
<p>【Keywords】:
Network-on-a-chip; Niobium compounds; Titanium compounds; CMOS technology; Microprocessors; CMOS process; Negative bias temperature instability; Hardware; Channel allocation; Logic design</p>
<h3 id="13. Energy-efficient fault tolerance in chip multiprocessors using Critical Value Forwarding.">13. Energy-efficient fault tolerance in chip multiprocessors using Critical Value Forwarding.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544918">Paper Link</a>】    【Pages】:121-130</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Subramanyan:Pramod">Pramod Subramanyan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Singh:Virendra">Virendra Singh</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Saluja:Kewal_K=">Kewal K. Saluja</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Larsson:Erik">Erik Larsson</a></p>
<p>【Abstract】:
Relentless CMOS scaling coupled with lower design tolerances is making ICs increasingly susceptible to wear-out related permanent faults and transient faults, necessitating on-chip fault tolerance in future chip microprocessors (CMPs). In this paper we introduce a new energy-efficient fault-tolerant CMP architecture known as Redundant Execution using Critical Value Forwarding (RECVF). RECVF is based on two observations: (i) forwarding critical instruction results from the leading to the trailing core enables the latter to execute faster, and (ii) this speedup can be exploited to reduce energy consumption by operating the trailing core at a lower voltage-frequency level. Our evaluation shows that RECVF consumes 37% less energy than conventional dual modular redundant (DMR) execution of a program. It consumes only 1.26 times the energy of a non-fault-tolerant baseline and has a performance overhead of just 1.2%.</p>
<p>【Keywords】:
Energy efficiency; Fault tolerance; Microprocessors; Fault tolerant systems; Hardware; Temperature; Power dissipation; Energy consumption; Fault detection; Proposals</p>
<h3 id="14. A fast and accurate multi-cycle soft error rate estimation approach to resilient embedded systems design.">14. A fast and accurate multi-cycle soft error rate estimation approach to resilient embedded systems design.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544952">Paper Link</a>】    【Pages】:131-140</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/f/Fazeli:Mahdi">Mahdi Fazeli</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Miremadi:Seyed_Ghassem">Seyed Ghassem Miremadi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Asadi:Hossein">Hossein Asadi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Ahmadian:Seyed_Nematollah">Seyed Nematollah Ahmadian</a></p>
<p>【Abstract】:
In this paper, we propose a very fast and accurate analytical approach to estimate the overall SER and to identify the most vulnerable gates, flip-flops, and paths of a circuit. Using such information, designers can selectively protect the vulnerable parts resulting in lower power and area overheads that are the most important factors in embedded systems. Unlike previous approaches, the proposed approach firstly does not rely on fault injection or fault simulation; secondly it measures the SER for multi cycles of circuit operation; thirdly, the proposed approach accurately computes all three masking factors, namely, logical, electrical, and timing masking; fourthly, the effects of error propagation in re-convergent fanouts are considered in the proposed approach. SERs estimated by the proposed approach for some ISCAS89 circuit benchmarks are compared with that estimated by the Monte Carlo (MC) simulation based fault injection approach. The results show that the proposed approach is about four orders of magnitude faster than the MC fault injection approach while having an accuracy of about 97%. This level of fastness and accuracy makes the proposed approach a viable solution to measure the SER of very large size circuits used in industry.</p>
<p>【Keywords】:
Error analysis; Estimation error; Embedded system; Circuit faults; Computational modeling; Circuit simulation; Flip-flops; Power system protection; Electric variables measurement; Timing</p>
<h3 id="15. Bit-slice logic interleaving for spatial multi-bit soft-error tolerance.">15. Bit-slice logic interleaving for spatial multi-bit soft-error tolerance.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544920">Paper Link</a>】    【Pages】:141-150</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/g/George:Nishant_J=">Nishant J. George</a> ; <a href="http://dblp.uni-trier.de/pers/hd/e/Elks:Carl_R=">Carl R. Elks</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Johnson:Barry_W=">Barry W. Johnson</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lach:John">John Lach</a></p>
<p>【Abstract】:
Semiconductor devices are becoming more susceptible to single event upsets (SEUs) as device dimensions, operating voltages and frequencies are scaled. The majority of architecture-, logic- and circuit-level techniques that have been developed to address SEUs in logic assume a single-point fault model. This will soon be insufficient as the occurrence of spatial multi-bit errors is becoming prevalent in highly scaled devices. In this paper, we explore this new fault model and evaluate the effectiveness of conventional fault tolerance techniques to mitigate such faults. We also extend the idea of bit interleaving in memory to logic bit slices and explore its utility as an approach to spatial multi-bit error mitigation in logic. We present a comparison of these techniques using a case study of a Brent-Kung adder at a 90-nm process.</p>
<p>【Keywords】:
Interleaved codes; Logic devices; Circuit faults; Single event transient; Semiconductor devices; Single event upset; Voltage; Frequency; Logic circuits; Fault tolerance</p>
<h3 id="16. WearMon: Reliability monitoring using adaptive critical path testing.">16. WearMon: Reliability monitoring using adaptive critical path testing.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544916">Paper Link</a>】    【Pages】:151-160</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/z/Zandian:Bardia">Bardia Zandian</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Dweik:Waleed">Waleed Dweik</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kang:Suk_Hun">Suk Hun Kang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Punihaole:Thomas">Thomas Punihaole</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Annavaram:Murali">Murali Annavaram</a></p>
<p>【Abstract】:
As processor reliability becomes a first order design constraint, this research argues for a need to provide continuous reliability monitoring. We present WearMon, an adaptive critical path monitoring architecture which provides accurate and real-time measure of the processor's timing margin degradation. Special test patterns check a set of critical paths in the circuit-under-test. By activating the actual devices and signal paths used in normal operation of the chip, each test will capture up-to-date timing margin of these paths. The monitoring architecture dynamically adapts testing interval and complexity based on analysis of prior test results, which increases efficiency and accuracy of monitoring. Experimental results based on FPGA implementation show that the proposed monitoring unit can be easily integrated into existing designs. Monitoring overhead can be reduced to zero by scheduling tests only when a unit is idle.</p>
<p>【Keywords】:
Timing Margins; Reliability; Critical Paths</p>
<h3 id="17. A numerical optimization-based methodology for application robustification: Transforming applications for error tolerance.">17. A numerical optimization-based methodology for application robustification: Transforming applications for error tolerance.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544923">Paper Link</a>】    【Pages】:161-170</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Sloan:Joseph">Joseph Sloan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kesler:David">David Kesler</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kumar_0002:Rakesh">Rakesh Kumar</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Rahimi:Ali">Ali Rahimi</a></p>
<p>【Abstract】:
There have been several attempts at correcting process variation induced errors by identifying and masking these errors at the circuit and architecture level [10, 27]. These approaches take up valuable die area and power on the chip. As an alternative, we explore the feasibility of an approach that allows these errors to occur freely, and handle them in software, at the algorithmic level. In this paper, we present a general approach to converting applications into an error tolerant form by recasting these applications as numerical optimization problems, which can then be solved reliably via stochastic optimization. We evaluate the potential robustness and energy benefits of the proposed approach using an FPGA-based framework that emulates timing errors in the floating point unit (FPU) of a Leon3 processor [11]. We show that stochastic versions of applications have the potential to produce good quality outputs in the face of timing errors under certain assumptions. We also show that good quality results are possible for both intrinsically robust algorithms as well as fragile applications under these assumptions.</p>
<p>【Keywords】:
Optimization methods; Robustness; Error correction; Application software; Stochastic processes; Timing; Circuits; Computer architecture; Software algorithms; Potential energy</p>
<h3 id="18. Blue Banana: resilience to avatar mobility in distributed MMOGs.">18. Blue Banana: resilience to avatar mobility in distributed MMOGs.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544919">Paper Link</a>】    【Pages】:171-180</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Legtchenko:Sergey">Sergey Legtchenko</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Monnet:S=eacute=bastien">Sébastien Monnet</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Thomas_0001:Ga=euml=l">Gaël Thomas</a></p>
<p>【Abstract】:
Massively Multiplayer Online Games (MMOGs) recently emerged as a popular class of applications with millions of users. To offer acceptable gaming experience, such applications need to render the virtual world surrounding the player with a very low latency. However, current state-of-the-art MMOGs based on peer-to-peer overlays fail to satisfy these requirements. This happens because avatar mobility implies many data exchanges through the overlay. As state-of-the-art overlays do not anticipate this mobility, the needed data is not delivered on time, which leads to transient failures at the application level. To solve this problem, we propose Blue Banana, a mechanism that models and predicts avatar movement, allowing the overlay to adapt itself by anticipation to the MMOG needs. Our evaluation is based on large-scale traces derived from Second life. It shows that our anticipation mechanism decreases by 20% the number of transient failures with only a network overhead of 2%.</p>
<p>【Keywords】:
Resilience; Avatars; Peer to peer computing; Information retrieval; Delay; Large-scale systems; Second Life; Degradation; Online Communities/Technical Collaboration; Scalability</p>
<h3 id="19. Efficient eventual consistency in Pahoehoe, an erasure-coded key-blob archive.">19. Efficient eventual consistency in Pahoehoe, an erasure-coded key-blob archive.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544926">Paper Link</a>】    【Pages】:181-190</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Anderson:Eric">Eric Anderson</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Li:Xiaozhou">Xiaozhou Li</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Merchant:Arif">Arif Merchant</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shah:Mehul_A=">Mehul A. Shah</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Smathers:Kevin">Kevin Smathers</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tucek:Joseph">Joseph Tucek</a> ; <a href="http://dblp.uni-trier.de/pers/hd/u/Uysal:Mustafa">Mustafa Uysal</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wylie:Jay_J=">Jay J. Wylie</a></p>
<p>【Abstract】:
Cloud computing demands cheap, always-on, and reliable storage. We describe Pahoehoe, a key-value cloud storage system we designed to store large objects cost-effectively with high availability. Pahoehoe stores objects across multiple data centers and provides eventual consistency so to be available during network partitions. Pahoehoe uses erasure codes to store objects with high reliability at low cost. Its use of erasure codes distinguishes Pahoehoe from other cloud storage systems, and presents a challenge for efficiently providing eventual consistency. We describe Pahoehoe's put, get, and convergence protocols&#x2014;convergence being the decentralized protocol that ensures eventual consistency. We use simulated executions of Pahoehoe to evaluate the efficiency of convergence, in terms of message count and message bytes sent, for failure-free and expected failure scenarios (e.g., partitions and server unavailability). We describe and evaluate optimizations to the na&#x00EF;ve convergence protocol that reduce the cost of convergence in all scenarios.</p>
<p>【Keywords】:
Convergence; Availability; Network servers; Computer crashes; Frequency selective surfaces; Cloud computing; Laboratories; Access protocols; Cost function; Social network services</p>
<h3 id="20. Using correlated surprise to infer shared influence.">20. Using correlated surprise to infer shared influence.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544921">Paper Link</a>】    【Pages】:191-200</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/o/Oliner:Adam_J=">Adam J. Oliner</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kulkarni:Ashutosh_V=">Ashutosh V. Kulkarni</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Aiken:Alex">Alex Aiken</a></p>
<p>【Abstract】:
We propose a method for identifying the sources of problems in complex production systems where, due to the prohibitive costs of instrumentation, the data available for analysis may be noisy or incomplete. In particular, we may not have complete knowledge of all components and their interactions. We define influences as a class of component interactions that includes direct communication and resource contention. Our method infers the influences among components in a system by looking for pairs of components with time-correlated anomalous behavior. We summarize the strength and directionality of shared influences using a Structure-of-Influence Graph (SIG). This paper explains how to construct a SIG and use it to isolate system misbehavior, and presents both simulations and in-depth case studies with two autonomous vehicles and a 9024-node production supercomputer.</p>
<p>【Keywords】:
Production systems; Instruments; Computer science; Costs; Silicon carbide; Data analysis; Remotely operated vehicles; Mobile robots; Supercomputers; Delay effects</p>
<h3 id="21. Keystroke biometrics with number-pad input.">21. Keystroke biometrics with number-pad input.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544311">Paper Link</a>】    【Pages】:201-210</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Maxion:Roy_A=">Roy A. Maxion</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Killourhy:Kevin_S=">Kevin S. Killourhy</a></p>
<p>【Abstract】:
Keystroke dynamics is the process of identifying individual users on the basis of their typing rhythms, which are in turn derived from the timestamps of key-press and key-release events in the keyboard. Many researchers have explored this domain, with mixed results, but few have examined the relatively impoverished territory of digits only, particularly when restricted to using a single finger - which might come into play on an automated teller machine, a mobile phone, a digital telephone dial, or a digital electronic security keypad at a building entrance. In this work, 28 users typed the same 10-digit number, using only the right-hand index finger. Employing statistical machine-learning techniques (random forest), we achieved an unweighted correct-detection rate of 99.97% with a corresponding false-alarm rate of 1.51%, using practiced 2-of-3 encore typing with outlier handling. This level of accuracy approaches sufficiency for two-factor authentication for passwords or PIN numbers.</p>
<p>【Keywords】:
Biometrics; Keyboards; Rhythm; Authentication; Telegraphy; Laboratories; Computer science; Telephony; Security; Europe</p>
<h3 id="22. Using Bayesian networks for cyber security analysis.">22. Using Bayesian networks for cyber security analysis.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544924">Paper Link</a>】    【Pages】:211-220</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/x/Xie:Peng">Peng Xie</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Li:Jason_H=">Jason H. Li</a> ; <a href="http://dblp.uni-trier.de/pers/hd/o/Ou:Xinming">Xinming Ou</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Liu_0005:Peng">Peng Liu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Levy:Renato">Renato Levy</a></p>
<p>【Abstract】:
Capturing the uncertain aspects in cyber security is important for security analysis in enterprise networks. However, there has been insufficient effort in studying what modeling approaches correctly capture such uncertainty, and how to construct the models to make them useful in practice. In this paper, we present our work on justifying uncertainty modeling for cyber security, and initial evidence indicating that it is a useful approach. Our work is centered around near real-time security analysis such as intrusion response. We need to know what is really happening, the scope and severity level, possible consequences, and potential countermeasures. We report our current efforts on identifying the important types of uncertainty and on using Bayesian networks to capture them for enhanced security analysis. We build an example Bayesian network based on a current security graph model, justify our modeling approach through attack semantics and experimental study, and show that the resulting Bayesian network is not sensitive to parameter perturbation.</p>
<p>【Keywords】:
Bayesian methods; Computer security; Uncertainty; File servers; Web server; Access protocols; USA Councils; Graphical models; Workstations; Intrusion detection</p>
<h3 id="23. A study of the internal and external effects of concurrency bugs.">23. A study of the internal and external effects of concurrency bugs.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544315">Paper Link</a>】    【Pages】:221-230</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/f/Fonseca_0001:Pedro">Pedro Fonseca</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Li_0001:Cheng">Cheng Li</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Singhal:Vishal">Vishal Singhal</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Rodrigues:Rodrigo">Rodrigo Rodrigues</a></p>
<p>【Abstract】:
Concurrent programming is increasingly important for achieving performance gains in the multi-core era, but it is also a difficult and error-prone task. Concurrency bugs are particularly difficult to avoid and diagnose, and therefore in order to improve methods for handling such bugs, we need a better understanding of their characteristics. In this paper we present a study of concurrency bugs in MySQL, a widely used database server. While previous studies of real-world concurrency bugs exist, they have centered their attention on the causes of these bugs. In this paper we provide a complementary focus on their effects, which is important for understanding how to detect or tolerate such bugs at run-time. Our study uncovered several interesting facts, such as the existence of a significant number of latent concurrency bugs, which silently corrupt data structures and are exposed to the user potentially much later. We also highlight several implications of our findings for the design of reliable concurrent systems.</p>
<p>【Keywords】:
Concurrent computing; Computer bugs; Interleaved codes; Performance gain; Programming profession; Fault detection; Manufacturing processes; Software performance; Software systems</p>
<h3 id="24. AutomaDeD: Automata-based debugging for dissimilar parallel tasks.">24. AutomaDeD: Automata-based debugging for dissimilar parallel tasks.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544927">Paper Link</a>】    【Pages】:231-240</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Bronevetsky:Greg">Greg Bronevetsky</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Laguna:Ignacio">Ignacio Laguna</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bagchi:Saurabh">Saurabh Bagchi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Supinski:Bronis_R=_de">Bronis R. de Supinski</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Ahn:Dong_H=">Dong H. Ahn</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Schulz_0001:Martin">Martin Schulz</a></p>
<p>【Abstract】:
Today's largest systems have over 100,000 cores, with million-core systems expected over the next few years. This growing scale makes debugging the applications that run on them a daunting challenge. Few debugging tools perform well at this scale and most provide an overload of information about the entire job. Developers need tools that quickly direct them to the root cause of the problem. This paper presents AutomaDeD, a tool that identifies which tasks of a large-scale application first manifest a bug at a specific code region and specific program execution point. AutomaDeD statistically models the application's control-flow and timing behavior, grouping tasks and identifying deviations from normal execution, which significantly reduces debugging effort. In addition to a case study in which AutomaDeD locates a bug that occurred during development of MVAPICH, we evaluate AutomaDeD on a range of bugs injected into the NAS parallel benchmarks. Our results demonstrate that AutomaDeD detects the time period when a bug first manifested with 90% accuracy for stalls and hangs and 70% accuracy for interference faults. It identifies the subset of processes first affected by the fault with 80% accuracy and 70% accuracy, respectively and the code region where the fault first manifested with 90% and 50% accuracy, respectively.</p>
<p>【Keywords】:
Debugging; Government; Protection; Large-scale systems; Timing; Computer bugs; Fault detection; Interference; Fault diagnosis; Histograms</p>
<h3 id="25. Detecting vulnerabilities in C programs using trace-based testing.">25. Detecting vulnerabilities in C programs using trace-based testing.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544310">Paper Link</a>】    【Pages】:241-250</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Dazhi">Dazhi Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Liu:Donggang">Donggang Liu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lei:Yu">Yu Lei</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kung:David_Chenho">David Chenho Kung</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Csallner:Christoph">Christoph Csallner</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Wenhua">Wenhua Wang</a></p>
<p>【Abstract】:
Security testing has gained significant attention recently due to frequent attacks against software systems. This paper presents a trace-based security testing approach. It reuses test cases generated from previous testing methods to produce execution traces. An execution trace is a sequence of program statements exercised by a test case. Each trace is symbolically executed to produce program constraints and security constraints. A program constraint is a constraint imposed by program logic on program variables. A security constraint is a condition on program variables that must be satisfied to ensure system security. A security flaw exists if there is an assignment of values to program variables that satisfies the program constraint but violates the security constraint. This approach detects security flaws even if existing test cases do not trigger them. The novelty of this method is a test model that unifies program constraints and security constraints such that formal reasoning can be applied to detect vulnerabilities. A tool named SecTAC is implemented and applied to 14 benchmark programs and 3 open-source programs. The experiment shows that SecTAC quickly detects all reported vulnerabilities and 13 new ones that have not been detected before.</p>
<p>【Keywords】:
Data security; Vehicle crash testing; System testing; Software testing; Open source software; Computer crashes; Runtime; Automatic testing; Computer science; Computer security</p>
<h3 id="26. Mash-IF: Practical information-flow control within client-side mashups.">26. Mash-IF: Practical information-flow control within client-side mashups.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544312">Paper Link</a>】    【Pages】:251-260</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Li:Zhou">Zhou Li</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Kehuan">Kehuan Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang:XiaoFeng">XiaoFeng Wang</a></p>
<p>【Abstract】:
Mashup is a representative of Web 2.0 technology that needs both convenience of cross-domain access and protection against the security risks it brings in. Solutions proposed by prior research focused on mediating access to the data in different domains, but little has been done to control the use of the data after the access. In this paper, we present Mash-IF, a new technique for information-flow control within mashups. Our approach allows cross-domain communications within a browser, but disallows disclosure of sensitive information to remote parties without the user's permission. It mediates the cross-domain channels in existing mashups and works on the client without collaborations from other parties. Also of particular interest is a novel technique that automatically generates declassification rules for a script by statically analyzing its code. Such rules can be efficiently enforced through monitoring the script's call sequences and DOM operations.</p>
<p>【Keywords】:
Information-Flow Control; Web; Browser; Mashup; Protection; Security Model</p>
<h3 id="27. DataGuard: Dynamic data attestation in wireless sensor networks.">27. DataGuard: Dynamic data attestation in wireless sensor networks.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544307">Paper Link</a>】    【Pages】:261-270</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Dazhi">Dazhi Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Liu:Donggang">Donggang Liu</a></p>
<p>【Abstract】:
Attestation has become a promising approach for ensuring software integrity in wireless sensor networks. However, current attestation either focuses on static system properties, e.g., code integrity, or requires hardware support such as Trusted Platform Module (TPM). However, there are attacks exploiting vulnerabilities that do not violate static system properties, and sensor platforms may not have hardware-based security support. This paper presents a software attestation scheme for dynamic data integrity based on data boundary integrity. It automatically transforms the source code and inserts data guards to track run-time program data. A data guard is unrecoverable once it is corrupted by an attacker, even if the attacker fully controls the system later. The corruption of any data guard at runtime can be remotely detected. A corruption either indicates a software attack or a bug in the software that needs immediate attention. The benefits of the proposed attestation scheme are as follows. First, it does not rely on any additional hardware support, making it suitable for low-cost sensor nodes. Second, it introduces minimal communication cost and has adjustable runtime memory overhead. Third, it works even if sensor nodes use different hardware platforms, as long as they run the same software. The prototype implementation and the experiments on TelosB motes show that the proposed technique is both effective and efficient for sensor networks.</p>
<p>【Keywords】:
Wireless sensor networks; Hardware; Runtime; Sensor systems; Data security; Automatic control; Control systems; Costs; Software prototyping; Prototypes</p>
<h3 id="28. iProve: A scalable technique for consumer-verifiable software guarantees.">28. iProve: A scalable technique for consumer-verifiable software guarantees.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544309">Paper Link</a>】    【Pages】:271-280</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Andrica:Silviu">Silviu Andrica</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Jula:Horatiu">Horatiu Jula</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Candea:George">George Candea</a></p>
<p>【Abstract】:
Formally proving complex program properties is still considered impractical for systems with over a million lines of code. We present iProve, an approach that enables guaranteeing useful properties in large Java systems. Desired properties are proven in iProve as a combination of two proofs: one of a complex property applied to a small piece of code&#x2014;a nucleus&#x2014;using existing theorem provers, and a proof of a simple property applied to the rest of the code&#x2014;the program body&#x2014;using iProve. We show how iProve can be used to guarantee properties such as communication security, deadlock immunity, data privacy, and resource usage bounds in Java programs with millions of lines of code. iProve scales well, requires no access to source code, and allows nuclei to be reused with an unlimited number of systems and to be written in verification-friendly languages.</p>
<p>【Keywords】:
System recovery; Java; Communication system software; Computer networks; Data privacy; Automatic control</p>
<h3 id="29. Reuse-oriented camouflaging trojan: Vulnerability detection and attack construction.">29. Reuse-oriented camouflaging trojan: Vulnerability detection and attack construction.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544305">Paper Link</a>】    【Pages】:281-290</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Lin:Zhiqiang">Zhiqiang Lin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Xiangyu">Xiangyu Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/x/Xu:Dongyan">Dongyan Xu</a></p>
<p>【Abstract】:
We introduce the reuse-oriented camouflaging trojan &#x2014; a new threat to legitimate software binaries. To perform a malicious action, such a trojan identifies and reuses an existing function in a legal binary program instead of implementing the function itself. Furthermore, this trojan is stealthy in that the malicious invocation of a targeted function usually takes place in a location where it is legal to do so, closely mimicking a legal invocation. At the network level, the victim binary can still follow its communication protocol without exhibiting any anomalous behavior. Meanwhile, many close-source shareware binaries are rich in functions that can be maliciously &#x201C;reused&#x201D;, making them attractive targets of this type of attack. In this paper, we present a framework to determine if a given binary program is vulnerable to this attack and to construct a concrete trojan if so. Our experiments with a number of real-world software binaries demonstrate that the reuse-oriented camouflaging trojans are a real threat and vulnerabilities of this type in legal binaries can be effectively revealed and confirmed.</p>
<p>【Keywords】:
Law; Legal factors; Payloads; Computer science; Protocols; Concrete; Logic; Security; Computer worms; Sockets</p>
<h3 id="30. Detection of botnets using combined host- and network-level information.">30. Detection of botnets using combined host- and network-level information.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544306">Paper Link</a>】    【Pages】:291-300</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/z/Zeng:Yuanyuan">Yuanyuan Zeng</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Hu:Xin">Xin Hu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shin:Kang_G=">Kang G. Shin</a></p>
<p>【Abstract】:
Bots are coordinated by a command and control (C&amp;C) infrastructure to launch attacks that seriously threaten the Internet services and users. Most botnet-detection approaches function at the network level and require the analysis of packets' payloads, raising privacy concerns and incurring large computational overheads. Moreover, network traffic analysis alone can seldom provide a complete picture of botnets' behavior. By contrast, in-host detection approaches are useful to identify each bot's host-wide behavior, but are susceptible to the host-resident malware if used alone. To address these limitations, we consider both the coordination within a botnet and the malicious behavior each bot exhibits at the host level, and propose a C&amp;C protocol-independent detection framework that combines host- and network-level information for making detection decisions. The framework is shown to be effective in detecting various types of botnets with low false-alarm rates.</p>
<p>【Keywords】:
Web server; Storms; Protocols; Telecommunication traffic; Computer worms; Inspection; Command and control systems; Web and internet services; Counting circuits; Relays</p>
<h3 id="31. Dependable connection setup for network capabilities.">31. Dependable connection setup for network capabilities.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544303">Paper Link</a>】    【Pages】:301-310</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Lee:Soo_Bum">Soo Bum Lee</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Gligor:Virgil_D=">Virgil D. Gligor</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Perrig:Adrian">Adrian Perrig</a></p>
<p>【Abstract】:
Network-layer capabilities offer strong protection against link flooding by authorizing individual flows with unforgeable credentials (i.e., capabilities). However, the capability-setup channel is vulnerable to flooding attacks that prevent legitimate clients from acquiring capabilities; i.e., in Denial of Capability (DoC) attacks. Based on the observation that the distribution of attack sources in the current Internet is highly non-uniform, we provide a router-level scheme that confines the effects of DoC attacks to specified locales or neighborhoods (e.g., one or more administrative domains of the Internet). Our scheme provides precise access guarantees for capability schemes, even in the face of flooding attacks. The effectiveness of our scheme is evaluated by ns2 simulations under different attack scenarios.</p>
<p>【Keywords】:
Floods; Internet; Protection; Authorization; Aggregates; Counting circuits; Large-scale systems; Filtering; Filters; Telecommunication traffic</p>
<h3 id="32. Why software hangs and what can be done with it.">32. Why software hangs and what can be done with it.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544304">Paper Link</a>】    【Pages】:311-316</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Song:Xiang">Xiang Song</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Chen:Haibo">Haibo Chen</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zang:Binyu">Binyu Zang</a></p>
<p>【Abstract】:
Software hang is an annoying behavior and forms a major threat to the dependability of many software systems. To avoid software hang at the design phase or fix it in production runs, it is desirable to understand its characteristics. Unfortunately, to our knowledge, there is currently no comprehensive study on why software hangs and how to deal with it. In this paper, we study the reported hang-related bugs of four typical open-source software applications, aiming to gain insight into characteristics of software hang and provide some guidelines to fix them at the first place or remedy them in production runs.</p>
<p>【Keywords】:
Computer bugs; Open source software; Concurrent computing; Software systems; Software debugging; Application software; Databases; System recovery; Runtime environment; Network servers</p>
<h3 id="33. Finding stable cliques of PlanetLab nodes.">33. Finding stable cliques of PlanetLab nodes.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544300">Paper Link</a>】    【Pages】:317-322</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/d/Duarte_Jr=:Elias_Proc=oacute=pio">Elias Procópio Duarte Jr.</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Garrett:Thiago">Thiago Garrett</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bona:Luis_C=_E=">Luis C. E. Bona</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Carmo:Renato">Renato Carmo</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Z=uuml=ge:Alexandre_P=">Alexandre P. Züge</a></p>
<p>【Abstract】:
Users of large scale network testbeds often execute experiments that require a set of nodes that behave and communicate among themselves in a reasonably stable pattern. In this work we call such a set of nodes a stable clique, and introduce a monitoring strategy that allows their detection in PlanetLab, a non-trivial task for such a large scale dynamic network. Nodes monitor each other by sampling the RTT (Round-Trip-Time) and computing its variation. Based on this data and a threshold, pairs of nodes are classified as stable or unstable. A set of graphs is generated, on which maximum sized cliques are computed. Three experiments were conducted in which hundreds of nodes were monitored for several days. Results show the unexpected behavior of some nodes, and the size of the maximum stable clique for different time windows and different thresholds.</p>
<p>【Keywords】:
Monitoring; Testing; Protocols; Large-scale systems; Communication channels; Internet; Informatics; Sampling methods; Proposals; Stability</p>
<h3 id="34. Who is peeping at your passwords at Starbucks? - To catch an evil twin access point.">34. Who is peeping at your passwords at Starbucks? - To catch an evil twin access point.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544302">Paper Link</a>】    【Pages】:323-332</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Song:Yimin">Yimin Song</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yang:Chao">Chao Yang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Gu:Guofei">Guofei Gu</a></p>
<p>【Abstract】:
In this paper, we consider the problem of &#x201C;evil twin&#x201D; attacks in wireless local area networks (WLANs). An evil twin is essentially a phishing (rogue) Wi-Fi access point (AP) that looks like a legitimate one (with the same SSID name). It is set up by an adversary, who can eavesdrop on wireless communications of users' Internet access. Existing evil twin detection solutions are mostly for wireless network administrators to verify whether a given AP is in an authorized list or not, instead of for a wireless client to detect whether a given AP is authentic or evil. Such administrator-side solutions are limited, expensive, and not available for many scenarios. For example, for traveling users who use wireless networks at airports, hotels, or cafes, they need to protect themselves from evil twin attacks (instead of relying on those wireless network providers, which typically may not provide strong security monitoring/management service). Thus, a lightweight and effective solution for these users is highly desired. In this work, we propose a novel user-side evil twin detection technique that outperforms traditional administrator-side detection methods in several aspects. Unlike previous approaches, our technique does not need a known authorized AP/host list, thus it is suitable for users to identify and avoid evil twins. Our technique does not strictly rely on training data of target wireless networks, nor depend on the types of wireless networks. We propose to exploit fundamental communication structures and properties of such evil twin attacks in wireless networks and to design new active, statistical and anomaly detection algorithms. Our preliminary evaluation in real-world widely deployed 802.11b and 802.11g wireless networks shows very promising results. We can identify evil twins with a very high detection rate while keeping a very low false positive rate.</p>
<p>【Keywords】:
Wireless networks; Wireless LAN; Wireless communication; Internet; Airports; Protection; Monitoring; Training data; Algorithm design and analysis; Detection algorithms</p>
<h3 id="35. Improving privacy and lifetime of PCM-based main memory.">35. Improving privacy and lifetime of PCM-based main memory.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544298">Paper Link</a>】    【Pages】:333-342</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/k/Kong:Jingfei">Jingfei Kong</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhou:Huiyang">Huiyang Zhou</a></p>
<p>【Abstract】:
Phase change memory (PCM) is a promising technology for computer memory systems. However, the non-volatile nature of PCM poses serious threats to computer privacy. The low programming endurance of PCM devices also limits the lifetime of PCM-based main memory (PRAM). In this paper, we first adopt counter-mode encryption for privacy protection and show that encryption significantly reduces the effectiveness of some previously proposed wear-leveling techniques for PRAM. To mitigate such adverse impact, we propose simple, yet effective extensions to the encryption scheme. In addition, we propose to reuse the encryption counters as age counters and to dynamically adjust the strength of error correction code (ECC) to extend the lifetime of PRAM. Our experiments show that our mechanisms effectively achieve privacy protection and lifetime extension for PRAM with very low performance overhead.</p>
<p>【Keywords】:
Phase change random access memory; Phase change materials; Counting circuits; Elliptic curve cryptography; Protection; Phase change memory; Error correction codes; Delay; Data privacy; Computer science</p>
<h3 id="36. Generic construction of consensus algorithms for benign and Byzantine faults.">36. Generic construction of consensus algorithms for benign and Byzantine faults.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544299">Paper Link</a>】    【Pages】:343-352</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/r/R=uuml=tti:Olivier">Olivier Rütti</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Milosevic_0001:Zarko">Zarko Milosevic</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Schiper:Andr=eacute=">André Schiper</a></p>
<p>【Abstract】:
The paper proposes a generic consensus algorithm that highlights the basic and common features of known consensus algorithms. The parameters of the generic algorithm encapsulate the core differences between various consensus algorithms, including leader-based and leader-free algorithms, addressing benign faults, authenticated Byzantine faults and Byzantine faults. This leads to the identification of three classes of consensus algorithms. With the proposed classification, Paxos and PBFT indeed belong to the same class, while FaB Paxos belongs to a different class. Interestingly, the classification allowed us to identify a new Byzantine consensus algorithm that requires n &#x003E; 4b, where b is the maximum number of Byzantine processes.</p>
<p>【Keywords】:
Fault diagnosis; Fault tolerance; Distributed computing; Reactive power; Lead; Fault detection; Detectors</p>
<h3 id="37. Scrooge: Reducing the costs of fast Byzantine replication in presence of unresponsive replicas.">37. Scrooge: Reducing the costs of fast Byzantine replication in presence of unresponsive replicas.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544295">Paper Link</a>】    【Pages】:353-362</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Serafini:Marco">Marco Serafini</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bokor:P=eacute=ter">Péter Bokor</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Dobre:Dan">Dan Dobre</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Majuntke:Matthias">Matthias Majuntke</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Suri:Neeraj">Neeraj Suri</a></p>
<p>【Abstract】:
Byzantine-Fault-Tolerant (BFT) state machine replication is an appealing technique to tolerate arbitrary failures. However, Byzantine agreement incurs a fundamental trade-off between being fast (i.e. optimal latency) and achieving optimal resilience (i.e. 2f + b + 1 replicas, where f is the bound on failures and b the bound on Byzantine failures [9]). Achieving fast Byzantine replication despite f failures requires at least f + b &#x2212; 2 additional replicas [10, 6, 8]. In this paper we show, perhaps surprisingly, that fast Byzantine agreement despite f failures is practically attainable using only b &#x2212; 1 additional replicas, which is independent of the number of crashes tolerated. This makes our approach particularly appealing for systems that must tolerate many crashes (large f) and few Byzantine faults (small b). The core principle of our approach is to have replicas agree on a quorum of responsive replicas before agreeing on requests. This is key to circumventing the resilience lower bound of fast Byzantine agreement [6].</p>
<p>【Keywords】:
Costs; Protocols; Resilience; Delay; Content addressable storage; Computer crashes; Fault tolerance; Distributed computing; Throughput</p>
<h3 id="38. Zzyzx: Scalable fault tolerance through Byzantine locking.">38. Zzyzx: Scalable fault tolerance through Byzantine locking.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544297">Paper Link</a>】    【Pages】:363-372</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/h/Hendricks:James">James Hendricks</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Sinnamohideen:Shafeeq">Shafeeq Sinnamohideen</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Ganger:Gregory_R=">Gregory R. Ganger</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Reiter:Michael_K=">Michael K. Reiter</a></p>
<p>【Abstract】:
Zzyzx is a Byzantine fault-tolerant replicated state machine protocol that outperforms prior approaches and provides near-linear throughput scaling. Using a new technique called Byzantine Locking, Zzyzx allows a client to extract state from an underlying replicated state machine and access it via a second protocol specialized for use by a single client. This second protocol requires just one round-trip and 2 f + 1 responsive servers&#x2014;compared to Zyzzyva, this results in 39&#x2013;43% lower response times and a factor of 2.2&#x2212;2.9&#x00D7; higher throughput. Furthermore, the extracted state can be transferred to other servers, allowing non-overlapping sets of servers to manage different state. Thus, Zzyzx allows throughput to be scaled by adding servers when concurrent data sharing is not common. When data sharing is common, performance can match that of the underlying replicated state machine protocol.</p>
<p>【Keywords】:
Fault tolerance; Throughput; Fault tolerant systems; Access protocols; File servers; Delay; Data mining; Scalability; Physics computing; Computer bugs</p>
<h3 id="39. Doubly-expedited one-step Byzantine consensus.">39. Doubly-expedited one-step Byzantine consensus.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544293">Paper Link</a>】    【Pages】:373-382</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Banu:Nazreen">Nazreen Banu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/i/Izumi:Taisuke">Taisuke Izumi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wada:Koichi">Koichi Wada</a></p>
<p>【Abstract】:
It is known that Byzantine consensus algorithms guarantee one-step decision only in favorable situations (e.g. when all processes propose the same value) and no one-step algorithm can support two-step decision. This paper presents DEX, a novel one-step Byzantine algorithm that circumvents these impossibilities using the condition-based approach. Algorithm DEX has two distinguished features: Adaptiveness and Double-expedition property. Adaptiveness makes it sensitive to only actual number of failures so that it provides fast termination for more number of inputs when there are fewer failures (a common case in practice). The double-expedition property facilitates two-step decision in addition to one-step decision by running two condition-based mechanisms in parallel. To the best of our knowledge, double-expedition property is the new concept introduced by this paper, and DEX is the first algorithm having such a feature. Although DEX takes four steps at worst in well-behaved runs while existing one-step algorithms take only three, it is expected to work efficiently because the worst-case does not occur so often in practice.</p>
<p>【Keywords】:
Broadcasting; Computer crashes; Educational institutions; Mechanical factors; Fault tolerant systems; Magnetic heads; Detectors</p>
<h3 id="40. A passive approach to wireless device fingerprinting.">40. A passive approach to wireless device fingerprinting.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544294">Paper Link</a>】    【Pages】:383-392</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/g/Gao:Ke">Ke Gao</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Corbett:Cherita_L=">Cherita L. Corbett</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Beyah:Raheem_A=">Raheem A. Beyah</a></p>
<p>【Abstract】:
We propose a passive blackbox-based technique for determining the type of access point (AP) connected to a network. Essentially, a stimulant (i.e., packet train) that emulates normal data transmission is sent through the access point. Since access points from different vendors are architecturally heterogeneous (e.g., chipset, firmware, driver), each AP will act upon the packet train differently. By applying wavelet analysis to the resultant packet train, a distinct but reproducible pattern is extracted allowing a clear classification of different AP types. This has two important applications: (1) as a system administrator, this technique can be used to determine if a rogue access point has connected to the network; and (2) as an attacker, fingerprinting the access point is necessary to launch driver/firmware specific attacks. Extensive experiments were conducted (over 60GB of data was collected) to differentiate 6 APs. We show that this technique can classify APs with a high accuracy (in some cases, we can classify successfully 100% of the time) with as little as 100000 packets. Further, we illustrate that this technique is independent of the stimulant traffic type (e.g., TCP or UDP). Finally, we show that the AP profile is stable across multiple models of the same AP.</p>
<p>【Keywords】:
Fingerprint recognition; Computer science; Pattern analysis; Data communication; Microprogramming; Wavelet analysis; Wavelet packets; Data mining; Traffic control; Data analysis</p>
<h3 id="41. Exploiting diverse observation perspectives to get insights on the malware landscape.">41. Exploiting diverse observation perspectives to get insights on the malware landscape.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544291">Paper Link</a>】    【Pages】:393-402</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Leita:Corrado">Corrado Leita</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bayer:Ulrich">Ulrich Bayer</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kirda:Engin">Engin Kirda</a></p>
<p>【Abstract】:
We are witnessing an increasing complexity in the malware analysis scenario. The usage of polymorphic techniques generates a new challenge: it is often difficult to discern the instance of a known polymorphic malware from that of a newly encountered malware family, and to evaluate the impact of patching and code sharing among malware writers in order to prioritize analysis efforts. This paper offers an empirical study on the value of exploiting the complementarity of different information sources in studying malware relationships. By leveraging real-world data generated by a distributed honeypot deployment, we combine clustering techniques based on static and behavioral characteristics of the samples, and we show how this combination helps in detecting clustering anomalies. We also show how the different characteristics of the approaches can help, once combined, to underline relationships among different code variants. Finally, we highlight the importance of contextual information on malware propagation for getting a deeper understanding of the evolution and the &#x201C;economy&#x201D; of the different threats.</p>
<p>【Keywords】:
Explosions; Protocols; Character generation; Marine vehicles; Internet; Control systems; Computer crime; Computer worms; Security; Engines</p>
<h3 id="42. Combined performance and risk analysis for border management applications.">42. Combined performance and risk analysis for border management applications.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544292">Paper Link</a>】    【Pages】:403-412</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Sacanamboy:Mayra">Mayra Sacanamboy</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Cukic:Bojan">Bojan Cukic</a></p>
<p>【Abstract】:
When designing critical applications, trade offs between different security solutions and their performance implications are common. Unfortunately, understanding the precise implications of such tradeoffs early in the system development lifecycle is difficult. This paper proposes a methodology for combined analysis of performance and security risk. We transform system requirements into a Layered Queueing Network (LQN) model that subsequently provides analytical performance analysis feedback when considering a set of security mechanisms and incurred security risks. We quantify security risks using cost curves. The proposed approach is illustrated through a realistic case study of a border management application.</p>
<p>【Keywords】:
Risk analysis; Risk management; Security; Performance analysis; Costs; Software performance; Application software; Conference management; Queueing analysis; Delay</p>
<h3 id="43. Experimental validation of a fault tolerant microcomputer system against intermittent faults.">43. Experimental validation of a fault tolerant microcomputer system against intermittent faults.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544288">Paper Link</a>】    【Pages】:413-418</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/g/Gracia=Moran:Joaquin">Joaquin Gracia-Moran</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Gil=Tomas:Daniel">Daniel Gil-Tomas</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Saiz=Adalid:Luis_J=">Luis J. Saiz-Adalid</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Baraza:Juan_Carlos">Juan Carlos Baraza</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Gil=Vicente:Pedro_J=">Pedro J. Gil-Vicente</a></p>
<p>【Abstract】:
As technologies shrink, new kinds of faults arise. Intermittent faults are part of these new faults. They are expected to be an increasing challenge in modern VLSI circuits. Up to now, transient and permanent faults used to be injected for the experimental validation of fault tolerance mechanisms. The main objective of this work is to improve the dependability assessment by injecting also intermittent faults. Furthermore, we have compared intermittent faults impact with the influence of transient and permanent faults. To carry out this study, we have injected bursts of intermittent faults in a fault-tolerant microcomputer system with some well known fault detection and recovery mechanisms. The methodology used lies in VHDL-Based Fault Injection technique, which allows a systematic and exhaustive analysis. Results show that intermittent faults have a notable impact on recovery mechanisms. They must be taken into account besides permanent and transient faults to implement an accurate dependability assessment.</p>
<p>【Keywords】:
Fault tolerant systems; Microcomputers; Circuit faults; Computational modeling; Fault tolerance; Fault detection; Very large scale integration; Manufacturing processes; Temperature; Voltage</p>
<h3 id="44. Evaluating repair strategies for a water-treatment facility using Arcade.">44. Evaluating repair strategies for a water-treatment facility using Arcade.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544290">Paper Link</a>】    【Pages】:419-424</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/h/Haverkort:Boudewijn_R=">Boudewijn R. Haverkort</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kuntz:Matthias">Matthias Kuntz</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Remke:Anne">Anne Remke</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Roolvink:S=">S. Roolvink</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Stoelinga:Mari=euml=lle">Mariëlle Stoelinga</a></p>
<p>【Abstract】:
The performance and dependability of critical infrastructures, such as water-treatment facilities is essential. In this paper we use various performance and dependability measures to analyze a simplified model of a water treatment facility. Building on the existing architectural framework Arcade a model is derived in XML format and then automatically mapped to the model checker PRISM. Using the stochastic model checking capabilities that PRISM offers, we compare different repair strategies, with respect to their costs, system reliability, availability and survivability. For this case study we conclude that using non-preemtive priority scheduling with additional repair crews is the best choice with respect to performance, dependability and costs.</p>
<p>【Keywords】:
Stochastic processes; Performance analysis; Costs; Availability; XML; Reliability; Government; Logic design; Buildings; Stochastic systems</p>
<h3 id="45. Application of a fault injection based dependability assessment process to a commercial safety critical nuclear reactor protection system.">45. Application of a fault injection based dependability assessment process to a commercial safety critical nuclear reactor protection system.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544285">Paper Link</a>】    【Pages】:425-430</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/e/Elks:Carl_R=">Carl R. Elks</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Reynolds:Michael">Michael Reynolds</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/George:Nishant_J=">Nishant J. George</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Miklo:Marko">Marko Miklo</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bingham:Scott">Scott Bingham</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Williams:Ronald_D=">Ronald D. Williams</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Johnson:Barry_W=">Barry W. Johnson</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Waterman:Michael">Michael Waterman</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Dion:Jeanne">Jeanne Dion</a></p>
<p>【Abstract】:
Existing nuclear power generation facilities are currently seeking to replace obsolete analog Instrumentation and Control (I&amp;C) systems with contemporary digital and processor based systems. However, as new technology is introduced into existing and new plants, it becomes vital to assess the impact of that technology on plant safety. From a regulatory point of view, the introduction or consideration of new digital I&amp;C systems into nuclear power plants raises concerns regarding the possibility that the fielding of these I&amp;C systems may introduce unknown or unanticipated failure modes. In this paper, we present a fault injection based safety assessment methodology that was applied to a commercial safety grade digital Reactor Protection System. Approximately 10,000 fault injections were applied to the system. This paper presents a overview of the research effort, lessons learned, and the results of the endeavor.</p>
<p>【Keywords】:
Safety; Protection; Control systems; Power generation; Inductors; Delay; Application software; Analog computers; Power engineering computing; Power engineering and energy</p>
<h3 id="46. Measurement-based analysis of fault and error sensitivities of dynamic memory.">46. Measurement-based analysis of fault and error sensitivities of dynamic memory.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544287">Paper Link</a>】    【Pages】:431-436</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/y/Yim:Keun_Soo">Keun Soo Yim</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kalbarczyk:Zbigniew">Zbigniew Kalbarczyk</a> ; <a href="http://dblp.uni-trier.de/pers/hd/i/Iyer:Ravishankar_K=">Ravishankar K. Iyer</a></p>
<p>【Abstract】:
This paper presents a measurement-based analysis of the fault and error sensitivities of dynamic memory. We extend a software-implemented fault injector to support data-type-aware fault injection into dynamic memory. The results indicate that dynamic memory exhibits about 18 times higher fault sensitivity than static memory, mainly because of the higher activation rate. Furthermore, we show that errors in a large portion of static and dynamic memory space are recoverable by simple software techniques (e.g., reloading data from a disk). The recoverable data include pages filled with identical values (e.g., &#x2018;0&#x2019;) and pages loaded from files unmodified during the computation. Consequently, the selection of targets for protection should be based on knowledge of recoverability rather than on error sensitivity alone.</p>
<p>【Keywords】:
Protection; Error correction codes; Costs; Hardware; Coordinate measuring machines; Application software; Target tracking; Fault location; Computer networks; Random access memory</p>
<h3 id="47. Representativeness analysis of injected software faults in complex software.">47. Representativeness analysis of injected software faults in complex software.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544282">Paper Link</a>】    【Pages】:437-446</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/n/Natella:Roberto">Roberto Natella</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Cotroneo:Domenico">Domenico Cotroneo</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Dur=atilde=es:Jo=atilde=o">João Durães</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Madeira:Henrique">Henrique Madeira</a></p>
<p>【Abstract】:
Despite of the existence of several techniques for emulating software faults, there are still open issues regarding representativeness of the faults being injected. An important aspect, not considered by existing techniques, is the non-trivial activation condition (trigger) of real faults, which causes them to elude testing and remain hidden until operation.</p>
<p>【Keywords】:
Software testing; Control system synthesis; Computer crashes; Acceleration; Programming profession; Pattern analysis; Computer bugs; Production; Fault tolerant systems; Benchmark testing</p>
<h3 id="48. An empirical investigation of fault types in space mission system software.">48. An empirical investigation of fault types in space mission system software.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544284">Paper Link</a>】    【Pages】:447-456</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/g/Grottke:Michael">Michael Grottke</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/Nikora:Allen_P=">Allen P. Nikora</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Trivedi:Kishor_S=">Kishor S. Trivedi</a></p>
<p>【Abstract】:
As space mission software becomes more complex, the ability to effectively deal with faults is increasingly important. The strategies that can be employed for fighting a software bug depend on its fault type. Bohrbugs are easily isolated and removed during software testing. Mandelbugs appear to behave chaotically. While it is more difficult to detect these faults during testing, it may not be necessary to correct them; a simple retry after a failure occurrence may work. Aging-related bugs, a sub-class of Mandelbugs, can cause an increasing failure rate. For these faults, proactive techniques may prevent future failures. In this paper, we analyze the faults discovered in the on-board software for 18 JPL/NASA space missions. We present the proportions of the various fault types and study how they have evolved over time. Moreover, we examine whether or not the fault type and attributes such as the failure effect are independent.</p>
<p>【Keywords】:
Space missions; System software; Computer bugs; Testing; Fault detection; Application software; Propulsion; Laboratories; Isolation technology; Space technology</p>
<h3 id="49. Assessing and improving the effectiveness of logs for the analysis of software faults.">49. Assessing and improving the effectiveness of logs for the analysis of software faults.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544279">Paper Link</a>】    【Pages】:457-466</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/c/Cinque:Marcello">Marcello Cinque</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Cotroneo:Domenico">Domenico Cotroneo</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/Natella:Roberto">Roberto Natella</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Pecchia:Antonio">Antonio Pecchia</a></p>
<p>【Abstract】:
Event logs are the primary source of data to characterize the dependability behavior of a computing system during the operational phase. However, they are inadequate to provide evidence of software faults, which are nowadays among the main causes of system outages. This paper proposes an approach based on software fault injection to assess the effectiveness of logs to keep track of software faults triggered in the field. Injection results are used to provide guidelines to improve the ability of logging mechanisms to report the effects of software faults. The benefits of the approach are shown by means of experimental results on three widely used software systems.</p>
<p>【Keywords】:
Open source software; Software systems; Computer networks; Guidelines; Supercomputers; Runtime; Computer crashes; Computer errors; Fault diagnosis; Web server</p>
<h3 id="50. Statistical guarantees of performance for MIMO designs.">50. Statistical guarantees of performance for MIMO designs.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544281">Paper Link</a>】    【Pages】:467-476</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/k/Kumar:Jayanand_Asok">Jayanand Asok Kumar</a> ; <a href="http://dblp.uni-trier.de/pers/hd/v/Vasudevan:Shobha">Shobha Vasudevan</a></p>
<p>【Abstract】:
Sources of noise such as quantization, introduce randomness into Register Transfer Level (RTL) designs of Multiple Input Multiple Output (MIMO) systems. Performance of these MIMO RTL designs is typically quantified by metrics averaged over simulations. In this paper, we introduce a formal approach to compute these metrics with high confidence. We define best, bounded and average case performance metrics as properties in a probabilistic temporal logic. We then use probabilistic model checking to verify these properties for MIMO RTL and thereby guarantee the statistical performance. If a property fails, we show a characterization of error. However, probabilistic model checking is known to encounter the problem of state space explosion. With respect to the properties of interest, we show sound and efficient reductions that significantly improve the scalability of our approach. We illustrate our approach on different non-trivial components of MIMO system designs.</p>
<p>【Keywords】:
MIMO; Acoustic noise; Noise level; Quantization; Registers; Computational modeling; Measurement; Probabilistic logic; State-space methods; Explosions</p>
<h3 id="51. Transient fault models and AVF estimation revisited.">51. Transient fault models and AVF estimation revisited.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544276">Paper Link</a>】    【Pages】:477-486</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/g/George:Nishant_J=">Nishant J. George</a> ; <a href="http://dblp.uni-trier.de/pers/hd/e/Elks:Carl_R=">Carl R. Elks</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Johnson:Barry_W=">Barry W. Johnson</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lach:John">John Lach</a></p>
<p>【Abstract】:
Transient faults (also known as soft-errors) resulting from high-energy particle strikes on silicon are typically modeled as single bit-flips in memory arrays. Most Architectural Vulnerability Factor (AVF) analyses assume this model. However, accelerated radiation tests on static random access memory (SRAM) arrays built using modern technologies show evidence of clustered upsets resulting from single particle strikes. In this paper, these observations are used to define a scalable fault model capable of representing fault multiplicities. Applying this model, a probabilistic framework for incorporating vulnerability of SRAM arrays to different fault multiplicities into AVF is proposed. An experimental fault injection setup using a detailed microarchitecture simulation running generic benchmarks was used to demonstrate vulnerability characterization in light of the new fault model. Further, rigorous fault injection is used to demonstrate that conventional methods of AVF estimation overestimate vulnerability up to 7&#x00D7; for some structures.</p>
<p>【Keywords】:
ACE analysis; SEU; spatial multi-bit upset; fault injection; AVF</p>
<h3 id="52. A unified model for timing speculation: Evaluating the impact of technology scaling, CMOS design style, and fault recovery mechanism.">52. A unified model for timing speculation: Evaluating the impact of technology scaling, CMOS design style, and fault recovery mechanism.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544278">Paper Link</a>】    【Pages】:487-496</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/k/Kruijf:Marc_de">Marc de Kruijf</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/Nomura:Shuou">Shuou Nomura</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Sankaralingam:Karthikeyan">Karthikeyan Sankaralingam</a></p>
<p>【Abstract】:
Due to fundamental device properties, energy efficiency from CMOS scaling is showing diminishing improvements. To overcome the energy efficiency challenges, timing speculation has been proposed to optimize for common-case timing conditions, with errors occurring under worst-case conditions detected and corrected in hardware. Although various timing speculation techniques have been proposed, no general framework exists for reasoning about the trade-offs and high-level design considerations of timing speculation. This paper develops two models to study the end-to-end behavior of timing speculation: a hardware-level efficiency model that considers the effects of process variations on path delays, and a complementary system-level recovery model. When combined, the models are used to assess the impact of technology scaling, CMOS design style, and fault recovery mechanism on the efficiency of timing speculation. Our results show that (1) efficiency gains from timing speculation do not improve as technology scales, (2) ultra-low power (sub-threshold) CMOS designs benefit most from timing speculation &#x2014; we report a 47% potential energy-delay reduction, and (3) fine-grained fault recovery is key to significant energy improvements. The combined model uses only high-level inputs to derive quantitative energy efficiency benefits without any need for detailed simulation, making it a potentially useful tool for hardware developers.</p>
<p>【Keywords】:
CMOS technology; Semiconductor device modeling; Timing; Energy efficiency; Hardware; Power system modeling; Circuit faults; Error correction; Error analysis; Mechanical factors</p>
<h3 id="53. Performance and availability aware regeneration for cloud based multitier applications.">53. Performance and availability aware regeneration for cloud based multitier applications.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544273">Paper Link</a>】    【Pages】:497-506</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/j/Jung:Gueyoung">Gueyoung Jung</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Joshi:Kaustubh_R=">Kaustubh R. Joshi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Hiltunen:Matti_A=">Matti A. Hiltunen</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Schlichting:Richard_D=">Richard D. Schlichting</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Pu:Calton">Calton Pu</a></p>
<p>【Abstract】:
Virtual machine technology enables agile system deployments in which software components can be cheaply moved, replicated, and allocated hardware resources in a controlled fashion. This paper examines how these facilities can be used to provide enhanced solutions to the classic problem of ensuring high availability while maintaining performance. By regenerating software components to restore the redundancy of a system whenever failures occur, we achieve improved availability compared to a system with a fixed redundancy level. Moreover, by smartly controlling component placement and resource allocation using information about application control flow and performance predictions from queuing models, we ensure that the resulting performance degradation is minimized. We consider an environment in which a collection of multitier enterprise applications operates across multiple hosts, racks, clusters, and data centers to maximize failure independence. Simulation results show that our proposed approach provides better availability and significantly lower degradation of system response times compared to traditional approaches.</p>
<p>【Keywords】:
Availability; Clouds; Application software; Resource management; Degradation; Virtual machining; Hardware; Control systems; Predictive models; Delay</p>
<h3 id="54. Adaptive on-line software aging prediction based on machine learning.">54. Adaptive on-line software aging prediction based on machine learning.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544275">Paper Link</a>】    【Pages】:507-516</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Alonso:Javier">Javier Alonso</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Torres:Jordi">Jordi Torres</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Berral:Josep_Lluis">Josep Lluis Berral</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Gavald=agrave=:Ricard">Ricard Gavaldà</a></p>
<p>【Abstract】:
The growing complexity of software systems is resulting in an increasing number of software faults. According to the literature, software faults are becoming one of the main sources of unplanned system outages, and have an important impact on company benefits and image. For this reason, a lot of techniques (such as clustering, fail-over techniques, or server redundancy) have been proposed to avoid software failures, and yet they still happen. Many software failures are those due to the software aging phenomena. In this work, we present a detailed evaluation of our chosen machine learning prediction algorithm (M5P) in front of dynamic and non-deterministic software aging. We have tested our prediction model on a three-tier web J2EE application achieving acceptable prediction accuracy against complex scenarios with small training data sets. Furthermore, we have found an interesting approach to help to determine the root cause failure: The model generated by machine learning algorithms.</p>
<p>【Keywords】:
Aging; Machine learning; Machine learning algorithms; Software systems; Redundancy; Clustering algorithms; Prediction algorithms; Software algorithms; Testing; Predictive models</p>
<h3 id="55. Correlating failures with asynchronous changes for root cause analysis in enterprise environments.">55. Correlating failures with asynchronous changes for root cause analysis in enterprise environments.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544270">Paper Link</a>】    【Pages】:517-526</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Agarwal:Manoj_K=">Manoj K. Agarwal</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Madduri:Venkateswara_Reddy">Venkateswara Reddy Madduri</a></p>
<p>【Abstract】:
In enterprise environments, it is critical to find the root cause of performance failures as quickly as possible. More often, root cause for these failures are the change events that are done deliberately by system administrator to fix existing problems in the system. However, these changes may themselves manifest as faults with the change in operating conditions over time. Hence, time lag between the changes that manifest themselves as faults and resulting failures may be unbounded. Most existing approaches fail to find such root cause faults as they consider only time correlated symptom events and real root cause event(s) are not even considered. In this paper we present a novel approach to identify such changes, from the set of changes done over the time, which may be the root cause of current failures. Our system automatically associates failures with these changes without any time window constraint. The approach presented in this paper does not require existence of any baseline model. As per our understanding, ours is a first system that associates changes with current failures without these assumptions. We have implemented this system in a real life test bed and it shows promising results.</p>
<p>【Keywords】:
Performance failures; Change Management; Root Cause Analysis; Enterprise Systems</p>
<h3 id="56. Ring Paxos: A high-throughput atomic broadcast protocol.">56. Ring Paxos: A high-throughput atomic broadcast protocol.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544272">Paper Link</a>】    【Pages】:527-536</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Marandi:Parisa_Jalili">Parisa Jalili Marandi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Primi:Marco">Marco Primi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Schiper:Nicolas">Nicolas Schiper</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Pedone:Fernando">Fernando Pedone</a></p>
<p>【Abstract】:
Atomic broadcast is an important communication primitive often used to implement state-machine replication. Despite the large number of atomic broadcast algorithms proposed in the literature, few papers have discussed how to turn these algorithms into efficient executable protocols. Our main contribution, Ring Paxos, is a protocol derived from Paxos. Ring Paxos inherits the reliability of Paxos and can be implemented very efficiently. We report a detailed performance analysis of Ring Paxos and compare it to other atomic broadcast protocols.</p>
<p>【Keywords】:
Broadcasting; Protocols; Switches; Throughput; Unicast; Communication switching; Atomic measurements; Context; Performance analysis; Atomic layer deposition</p>
<h3 id="57. Turquois: Byzantine consensus in wireless ad hoc networks.">57. Turquois: Byzantine consensus in wireless ad hoc networks.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544268">Paper Link</a>】    【Pages】:537-546</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Moniz:Henrique">Henrique Moniz</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/Neves:Nuno_Ferreira">Nuno Ferreira Neves</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Correia:Miguel">Miguel Correia</a></p>
<p>【Abstract】:
The operation of wireless ad hoc networks is intrinsically tied to the ability of nodes to coordinate their actions in a dependable and efficient manner. The failure of some nodes and momentary breakdown of communications, either of accidental or malicious nature, should not result in the failure of the entire system. This paper presents Turquois - an intrusion-tolerant consensus protocol specifically designed for resource-constrained wireless ad hoc networks. Turquois allows an efficient utilization of the broadcasting medium, avoids synchrony assumptions, and refrains from public-key cryptography during its normal operation. The protocol is safe despite the arbitrary failure of f &lt; n over 3 processes from a total of n processes, and unrestricted message omissions. The protocol was prototyped and subject to a comparative performance evaluation against two well-known intrusion-tolerant consensus protocols. The results show that, as the system scales, Turquois outperforms the other protocols by more than an order of magnitude.</p>
<p>【Keywords】:
Mobile ad hoc networks; Cryptographic protocols; Wireless application protocol; Broadcasting; Synchronization; Ad hoc networks; Electric breakdown; Public key cryptography; Prototypes; Wire</p>
<h3 id="58. Diversity-inspired clustering for self-healing MANETs: Motivation, protocol, and performability evaluation.">58. Diversity-inspired clustering for self-healing MANETs: Motivation, protocol, and performability evaluation.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544269">Paper Link</a>】    【Pages】:547-556</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/t/Tai:Ann_T=">Ann T. Tai</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tso:Kam_S=">Kam S. Tso</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Sanders:William_H=">William H. Sanders</a></p>
<p>【Abstract】:
Swarm systems, which typically comprise a large number of lightweight mobile components, must be capable of self-healing. In this paper, we propose a self-organizing, self-healing framework called &#x201C;superimposed&#x201D; clustering for such systems. The framework makes a significant departure from traditional clustering algorithms that apply a single policy to form clusters through iterations. Specifically, our superimposed clustering protocol (SCP) selects a pair of diversified clustering polices to simultaneously build two sets of clusters, which we view as two cluster layers with one on top of the other. Via redundancy shadowing, SCP is able to extract and combine the complementary portions of the two layers to form a clustered network such that the vast majority of nodes can be organized through a single round. Moreover, SCP exploits shadow redundancy to enable gracefully degradable clustering coverage to mitigate cluster damage caused by node failure, death, or migration. We present the notion of superimposed clustering by devising a protocol and conducting a performability evaluation.</p>
<p>【Keywords】:
Protocols; Performance evaluation; Degradation; Redundancy; Clustering algorithms; Robot kinematics; Shadow mapping; Aggregates; Performance loss; Nanobioscience</p>
<h3 id="59. GOOFI-2: A tool for experimental dependability assessment.">59. GOOFI-2: A tool for experimental dependability assessment.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544265">Paper Link</a>】    【Pages】:557-562</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Skarin:Daniel">Daniel Skarin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Barbosa:Raul">Raul Barbosa</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Karlsson:Johan">Johan Karlsson</a></p>
<p>【Abstract】:
This paper presents GOOFI-2, a comprehensive fault injection tool for experimental dependability assessment of embedded systems. The tool includes a large number of extensions and improvements over its predecessor, GOOFI. These include support for three widely used fault injection techniques, two target processors, and a variety of new features for storing, disseminating and analyzing experimental data. We report on our experiences and lessons learned from the use and development of GOOFI-2. In particular, we compare and discuss properties of three fault injection techniques: Nexus-based, exception-based and instrumentation-based injection. The comparison relies on several sets of experiments with two target processors, Freescale's MPC565 and MPC5554.</p>
<p>【Keywords】:
Debugging; Instruments; Testing; Fault diagnosis; Fault tolerance; ISO standards; Road safety; Computer science; Embedded system; Data analysis</p>
<h3 id="60. Studying application-library interaction and behavior with LibTrac.">60. Studying application-library interaction and behavior with LibTrac.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544267">Paper Link</a>】    【Pages】:563-568</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Bisolfati:Eric">Eric Bisolfati</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Marinescu:Paul_Dan">Paul Dan Marinescu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Candea:George">George Candea</a></p>
<p>【Abstract】:
LibTrac is a tool for studying the program/library boundary and answering questions like: Which library functions are called most often? Are there library usage patterns that distinguish one class of applications from the others? Do programs generally retry failed I/O calls or not?</p>
<p>【Keywords】:
Software libraries; Statistics; Runtime; Linux; Computer networks; System testing; Application software; Software testing; Costs; Computer interfaces</p>
<h3 id="61. Experiences with a CANoe-based fault injection framework for AUTOSAR.">61. Experiences with a CANoe-based fault injection framework for AUTOSAR.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544419">Paper Link</a>】    【Pages】:569-574</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Lanigan:Patrick_E=">Patrick E. Lanigan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/Narasimhan:Priya">Priya Narasimhan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Fuhrman:Thomas_E=">Thomas E. Fuhrman</a></p>
<p>【Abstract】:
Standardized software architectures, such as AUTomotive Open System ARchitecture (AUTOSAR), are being pursued within the automotive industry in order to reduce the cost of developing new vehicle features. Many of these features will need to be highly dependable. Fault injection plays an important role during the dependability analysis of such software. This work evaluates the feasibility of leveraging the CANoe simulation environment to develop software-based methods for injecting faults into AUTOSAR applications. We describe a proof-of-concept fault-injection framework with example fault-injection scenarios, as well as implementation issues faced and addressed, lessons learned, and the suitability of using CANoe as a fault-injection environment.</p>
<p>【Keywords】:
Costs; Vehicles; Automotive engineering; Application software; Computer industry; ISO standards; Hardware; Data structures; Software architecture; Computer architecture</p>
<h3 id="62. Empirical characterization of uncongested optical lambda networks and 10GbE commodity endpoints.">62. Empirical characterization of uncongested optical lambda networks and 10GbE commodity endpoints.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544264">Paper Link</a>】    【Pages】:575-584</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Marian:Tudor">Tudor Marian</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Freedman:Daniel_A=">Daniel A. Freedman</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Birman:Ken">Ken Birman</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Weatherspoon:Hakim">Hakim Weatherspoon</a></p>
<p>【Abstract】:
High-bandwidth, semi-private optical lambda networks carry growing volumes of data on behalf of large data centers, both in cloud computing environments and for scientific, financial, defense, and other enterprises. This paper undertakes a careful examination of the end-to-end characteristics of an uncongested lambda network running at high speeds over long distances, identifying scenarios associated with loss, latency variations, and degraded throughput at attached end-hosts. We use identical fast commodity source and destination platforms, hence expect the destination to receive more or less what we send. We observe otherwise: degraded performance is common and easily provoked. In particular, the receiver loses packets even when the sender employs relatively low data rates. Data rates of future optical network components are projected to outpace clock speeds of commodity end-host processors, hence more and more end-to-end applications will confront the same issue we encounter. Our work thus poses a new challenge for those hoping to achieve dependable performance in higher-end networked settings.</p>
<p>【Keywords】:
Optical fiber networks; High speed optical techniques; Optical losses; Optical network units; Optical receivers; Degradation; Bandwidth; Optical fibers; Computer science; Cloud computing</p>
<h3 id="63. On/off process modeling of IP network failures.">63. On/off process modeling of IP network failures.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544427">Paper Link</a>】    【Pages】:585-594</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/k/Kuusela:Pirkko">Pirkko Kuusela</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/Norros:Ilkka">Ilkka Norros</a></p>
<p>【Abstract】:
A reliability model for IP networks is considered, where the routers and links are modeled by independent stationary on/off processes. Component downtimes may obey any probability distribution. The model combines component reliability to a topological analysis, taking into account the routing rules of the network. This allows the derivation of on-off processes describing with high accuracy the IP-availability delivered to customers of each access router. The approach also provides estimates for risk in terms of lost traffic and allows analytic comparison of basic strategies for reliability improvement. The methodology is illustrated by studying the Finnish research backbone network.</p>
<p>【Keywords】:
IP networks; Network topology; Probability distribution; Availability; Telecommunication traffic; Spine; Protection; Routing; Risk analysis; Access protocols</p>
<h3 id="64. An automated technique to support the verification and validation of simulation models.">64. An automated technique to support the verification and validation of simulation models.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544417">Paper Link</a>】    【Pages】:595-604</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/k/Klock:Samuel_K=">Samuel K. Klock</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kemper:Peter">Peter Kemper</a></p>
<p>【Abstract】:
Simulation modeling requires model validation and verification to ensure that computed results are worth being considered. While we cannot expect a magic solution to the general problem, automated techniques for particular aspects of validation and verification are feasible. In this paper, we propose a technique to deduce model properties automatically from simulation runs performed for verification and validation and to use those properties for runtime monitoring during production runs. Properties are represented as formulas in linear temporal logic and are limited to functional properties. We demonstrate the applicability of the approach with using an extended version of a stochastic Botnet model originally developed by Van Ruitenbeek and Sanders.</p>
<p>【Keywords】:
Runtime; Formal specifications; Automatic testing; Software testing; Logic; Monitoring; Computational modeling; Software engineering; Performance analysis; Computer simulation</p>
<h3 id="65. Model checking CSLTA with Deterministic and Stochastic Petri Nets.">65. Model checking CSLTA with Deterministic and Stochastic Petri Nets.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544425">Paper Link</a>】    【Pages】:605-614</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Amparore:Elvio_Gilberto">Elvio Gilberto Amparore</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Donatelli:Susanna">Susanna Donatelli</a></p>
<p>【Abstract】:
CSLTA is a stochastic temporal logic for continuous-time Markov chains (CTMC), that can verify the probability of following paths specified by a Deterministic Timed Automaton (DTA). A DTA expresses both logic and time constraints over a CTMC path, yielding to a very flexible way of describing performance and dependability properties. This paper explores a model checking algorithm for CSL<sup>TA</sup> based on the translation into a Deterministic and Stochastic Petri Net (DSPN). The algorithm has been implemented in a simple Model Checker prototype, that relies on existing DSPN solvers to do the actual numerical computations.</p>
<p>【Keywords】:
DSPN; Stochastic Model Checking</p>
<h3 id="66. 1st workshop on fault-tolerance for HPC at extreme scale FTXS 2010.">66. 1st workshop on fault-tolerance for HPC at extreme scale FTXS 2010.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544426">Paper Link</a>】    【Pages】:615</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/d/Daly:John_T=">John T. Daly</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/DeBardeleben:Nathan">Nathan DeBardeleben</a></p>
<p>【Abstract】:
With the emergence of many-core processors, accelerators, and alternative/heterogeneous architectures, the HPC community faces a new challenge: a scaling in number of processing elements that supersedes the historical trend of scaling in processor frequencies. The attendant increase in system complexity has first-order implications for fault tolerance. Mounting evidence invalidates traditional assumptions of HPC fault tolerance: faults are increasingly multiple-point instead of single-point and interdependent instead of independent; silent failures and silent data corruption are no longer rare enough to discount; stabilization time consumes a larger fraction of useful system lifetime, with failure rates projected to exceed one per hour on the largest systems; and application interrupt rates are apparently diverging from system failure rates.</p>
<p>【Keywords】:
Fault tolerant systems; Fault tolerance; Laboratories; Hardware; Software performance; Error correction; Predictive models; Government; Space technology; Conferences</p>
<h3 id="67. Second workshop on proactive failure avoidance, recovery, and maintenance (PFARM).">67. Second workshop on proactive failure avoidance, recovery, and maintenance (PFARM).</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544422">Paper Link</a>】    【Pages】:616-618</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Malek:Miroslaw">Miroslaw Malek</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Salfner:Felix">Felix Salfner</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Trivedi:Kishor_S=">Kishor S. Trivedi</a></p>
<p>【Abstract】:
Proactive approaches to failure avoidance, recovery and maintenance have recently attracted increased interest among researchers and practitioners from various areas of dependable system design and operation. This first workshop provided a stimulating, and fruitful forum to foster collaboration among researchers working on proactive fault management, to discuss ideas, exchange experiences and to find new answers to the overall challenge of significantly improving system dependability in contemporary computing and communication systems.</p>
<p>【Keywords】:</p>
<h3 id="68. Fourth workshop on dependable and secure nanocomputing.">68. Fourth workshop on dependable and secure nanocomputing.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544423">Paper Link</a>】    【Pages】:619-620</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Arlat:Jean">Jean Arlat</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Constantinescu:Cristian">Cristian Constantinescu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/i/Iyer:Ravishankar_K=">Ravishankar K. Iyer</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Karlsson:Johan">Johan Karlsson</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/Nicolaidis:Michael">Michael Nicolaidis</a></p>
<p>【Abstract】:
Nanocomputing technologies hold the promise for higher performance, lower power consumption as well as increased functionality. However, the dependability of these unprecedentedly small scale devices remains uncertain. The main sources of concern are: &#x2022; Nanometer devices are expected to be highly sensitive to process variations. The guard-bands used today for avoiding the impact of such variations will not represent a feasible solution in the future. Thus, timing errors may occur more frequently. &#x2022; New failure modes, specific to new materials, are expected to raise serious challenges to the design and test engineers. &#x2022; Environment induced errors, like single event upsets (SEU), are likely to occur more frequently than in the case of conventional semiconductor devices. &#x2022; New hardware redundancy techniques are needed to enable development of energy efficient systems. &#x2022; The increased complexity of the systems based on nanotechnology will require improved computer aided design (CAD) tools, as well as better validation techniques. &#x2022; Security of nanocomputing systems may be threatened by malicious attacks targeting new vulnerable areas in the hardware.</p>
<p>【Keywords】:</p>
<h3 id="69. 4th workshop on recent advances in intrusion-tolerant systems WRAITS 2010.">69. 4th workshop on recent advances in intrusion-tolerant systems WRAITS 2010.</h3>
<p>【<a href="http://dx.doi.org/10.1109/DSN.2010.5544420">Paper Link</a>】    【Pages】:621-622</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/c/Correia:Miguel">Miguel Correia</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Pal:Partha_P=">Partha P. Pal</a></p>
<p>【Abstract】:
Design and operational vulnerabilities are accepted as inevitable in today's complex computer systems. The distributed and networked nature of the systems that are currently in use and being developed facilitate discovery and exploitation of these flaws in increasingly new and easier ways. Intrusion Tolerance acknowledges that it is impossible to completely prevent attacks and intrusions, and that it is often impossible to accurately detect the act of intrusion and stop it early enough. Intrusion Tolerance research therefore aims to develop technologies that enable computer systems to continue to operate correctly despite attacks, and deny the attacker/intruder the success they seek. For instance, an intrusion-tolerant system may suffer partial loss of service or resources due to the attack, but it will continue to provide critical services in a degraded mode or trigger automatic mechanisms to regain and recover the compromised services and resources. Similar goals are being pursued in Survivability, Byzantine Fault Tolerance, Self-regenerative and Autonomic Systems.</p>
<p>【Keywords】:</p>
 

<div class="home">
<i title='主页' onclick="location.href='../index.html'"><i class="fa fa-home fa-lg"></i></i>
</div>

<div class="toc">
<i id="showLeftPush" title='目录'><i class="fa fa-list fa-lg"></i></i>
</div>

<!-- Classie - class helper functions by @desandro https://github.com/desandro/classie -->
<script>
	var menuLeft = document.getElementById( 'menu-s1' ),
		showLeftPush = document.getElementById( 'showLeftPush' ),
		body = document.body;

	showLeftPush.onclick = function() {
		classie.toggle( this, 'active' );
		classie.toggle( body, 'cbp-spmenu-push-toright' );
		classie.toggle( menuLeft, 'cbp-spmenu-open' );
		disableOther( 'showLeftPush' );
	};
</script>

<div class="go-top" >
<i title='顶部' onclick="window.scrollTo('0', '0')"><i class="fa fa-angle-double-up fa-2x"></i></i>
</div>

<div class="theme" >
<i title='主题' onclick="change_css()"><i class="fa fa-adjust fa-lg"></i></i>
</div>

<div id="footer">

  <p> <i class="fa fa-envelope-o fa-1x"></i>:&nbsp huntercmd@163.com &nbsp Published under<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh"> (CC) BY-NC-SA 3.0</a></p>

  <p>&copy; 2013 HunterCmd &nbsp <a href="https://github.com/huntercmd/ccf"><i class="fa fa-github fa-1x"></i>
  </p>
</div>

</body>
